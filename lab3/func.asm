
is_correct proc
    ; Процедура для проверки корректности введенного числа
    ; число должно быть записано в буфер in_str
    ; корректный диапазон - [-32768, 32767]

    ; сохраняем состояние регистров
    push ax ; используется для хранения текущего символа
    push bx ; используется для хранения индекса в диапазоне (проход по константе MAX_NUM)
    push cx ; используется для хранения количества обработанных символов числа
    push dx ; используется для хранения последнего символа диапазона в зависимости от знака
    push si ; используется для хранения индекса в буфере ввода
    push di ; используется для хранения количества введенных символов во входном буфере

    ; очистка используемых регистров
    xor ax, ax
    xor bx, bx
    xor cx, cx
    xor dx, dx
    xor si, si
    xor di, di

    ; инициализация di количеством символов во входном буфере
    mov di, offset in_str ; помещаем в di адрес буфера ввода
    inc di          ; перемещаем на количество символов записанных в буфер
    mov di, [di]    ; загружаем 2 первых байта из in_str в di
    and di, 00FFh   ; очищаем старший байт

    ; начальная инициализация
    mov neg_flag, 0 ; очистка флага для хранения знака числа
    mov err_flag, 0 ; очистка флага для определения ошибки ввода
    mov si, 2       ; Инициализация индекса числа (пропуск служебных байтов буфера)
    mov bx, 0       ; Инициализация индекса для максимального диапазона

    mov al, in_str[si]; Загрузка текущего элемента буфера в AL
    cmp al, NEGATIVE  ; Является ли первый символ знаком '-'
    jne .is_num_cycle
    mov neg_flag, 1   ; установка флага отрицательного числа
    inc si            ; перемещаем указатель в буфере на следующий байт (символ)
    inc cx            ; увеличиваем счетчик обработанных чисел

    ; проверка: является ли числом каждый введенный символ символ (исключая первый минус)
    .is_num_cycle:
        cmp cx, di           ; если все символы обработаны
        je .max_digits_check ; выход из цикла
        mov al, in_str[si]   ; в al очередной ascii код ввода
        cmp al, 30h          ; 30h - ascii код для числа 0, если меньше - ошибка ввода
        jl .error
        cmp al, 39h          ; 39h - ascii код для числа 9, если меньше - ошибка ввода
        jg .error
        inc cx               ; увеличиваем счетчик
        inc si               ; двигаем указатель
        jmp .is_num_cycle    ; повторяем цикл


    .max_digits_check:
        ; очистка регистров
        xor cx, cx
        xor si, si

        cmp neg_flag, 0     ; проверка знака числа
        je .pos_start

        ; для отрицательных:
        .neg_start:
            cmp di, MAX_NEG_LEN ; сравнение количества введенных символов и максимального количества разрядов
            jl .corr_end        ; если меньше, завершаем без ошибки
            jg .error           ; если больше завершаем с ошибкой
            ; если равно, инициализация и переход к поразрядной проверке
            mov si, 3
            mov cx, 2            ; значение больше на 1 чем действительное чтобы выйти из range_cycle раньше на 1 символ
            jmp .range_cycle

        ; для положительных
        .pos_start:
            cmp di, MAX_POS_LEN ; сравнение количества введенных символов и максимального количества разрядов
            jl .corr_end        ; если меньше, завершаем без ошибки
            jg .error
            ; если равно, инициализация и переход к поразрядной проверке
            mov si, 2
            mov cx, 1

        ; поразрядная проверка диапазона если количество символов модуля равно 5
        .range_cycle:
            mov al, in_str[si] ; Загрузка текущего элемента буфера в AL
            cmp al, MAX_NUM[bx]
            jg .error
            jl .corr_end
            ; если символ равен ограничению:
            inc si            ; Увеличение индекса числа
            inc cx            ; Увеличение счетчика обработанных цифр
            inc bx            ; Увеличение индекса в строке содержащей максимальные цифры диапазона
            cmp cx, di        ; Проверка, достигнут ли конец буфера
            je .end_range     ; Если да, прерывание цикла
            jmp .range_cycle  ; Переход на следующую итерацию цикла

        ; проверка последнего символа если число значащих цифр равно максимальному
        .end_range:
            cmp neg_flag, 1
            je .negative
            mov dl, POS_MAX_LAST
            jmp .continue
        .negative:
            mov dl, NEG_MAX_LAST
        .continue:
            mov al, in_str[si] ; загружаем последний символ
            cmp al, dl
            jg .error          ; если есть выход за границу диапазона переход к ошибке
            jmp .corr_end

    ; завершение с ошибкой
    .error:
        mov err_flag, 1      ; установка флага ошибки

    ; завершение без ошибки
    .corr_end:
        ; восстанавливаем состояние из стека
        pop di
        pop si
        pop dx
        pop cx
        pop bx
        pop ax
        ret

is_correct endp

add_value proc
    ; Процедура для копирования числа из временной переменной в соответствующий массив
    ; число представлено в двоично-десятичном виде с незначащими нулями (размер на выходе 5 байт)
    ; в массивы записываем только модули, увеличиваем количество записанных чисел
    ; в si адрес очередного элемента в массиве положительных чисел
    ; в di адрес очередного элемента в массиве отрицательных чисел
    ; в tmp_num значение очередного введенного и преобразованного числа которое нужно скопировать

    push ax ; используется для увеличения счетчика записанных чисел в массиве и копирования очередной цифры(байта) числа
    push bx ; используется как указатель на tmp_num
    push cx ; счетчик элементов числа для цикла, инициализируется числом 5 (количеством байт в каждом числе)

    ; инициализация счетчика
    xor cx, cx
    mov cx, 10

    mov bx, offset tmp_num ; инициализируем указатель на временную переменную
    mov al, [bx]           ; в al байт знака
    inc bx                 ; перемещаем указатель на первый символ
    cmp al, 0              ; проверка на отрицательное/положительное число
    je .pos_num

    ; увеличиваем счетчик записанных чисел в массиве отрицательных чисел
    mov al, neg_array
    inc al
    mov neg_array, al

    ; по-байтовая запись модуля очередного числа в массив отрицательных чисел
    .neg_cycle:
        mov al, [bx]
        mov [di], al
        inc bx
        inc di
        loop .neg_cycle

    jmp .add_value_exit

    .pos_num:
        ; увеличиваем счетчик записанных чисел в массиве положительных (неотрицательных) чисел
        mov al, pos_array
        inc al
        mov pos_array, al

    ; по-байтовая запись модуля очередного числа в массив положительных (неотрицательных) чисел
    .pos_cycle:
        mov al, [bx]
        mov [si], al
        inc bx
        inc si
        loop .pos_cycle

    ; возврат состояния
    .add_value_exit:
        pop cx
        pop bx
        pop ax
        ret

add_value endp

clear_tmp_res proc
    push si
    push cx
    mov cx, 10
    mov si, offset tmp_res
    .clear_cycle:
        mov byte ptr [si], 0
        inc si
        loop .clear_cycle
    pop cx
    pop si

    ret
clear_tmp_res endp

fill_mul_array proc
    ; процедура для заполнения массива mul_array попарными произведениями модулей положительных и отрицательных чисел
    ; ожидается что произведен ввод с клавиатуры чисел, числа приведены к двоично-десятичному виду
    ; массивы pos_array и neg_array заполнены модулями положительных и отрицательных чисел соответственно

    ; сохраняем состояние
    push ax
    push bx
    push cx
    push dx
    push si
    push di

    ; чистим регистры
    xor ax, ax
    xor bx, bx
    xor cx, cx
    xor dx, dx
    xor si, si
    xor di, di

    ; инициализация счетчика размером меньшего из массивов введенных чисел
    mov bx, offset pos_array
    mov bl, [bx]
    mov al, bl
    mov bx, offset neg_array
    mov bl, [bx]
    cmp al, bl
    jg .pos_bigger
    mov cl, bl
    jmp .counter_initialized
.pos_bigger:
    mov cl, al

.counter_initialized:
    ; инициализация указателей на массивы с модулями чисел
    mov si, offset pos_array + 1
    mov di, offset neg_array + 1

    ; заполнение массива mul_array
    mov bx, offset mul_array
    mov [bx], byte ptr cx   ; запись в массив mul_array количества элементов
    inc bx                  ; двигаем указатель на первый результат
    .prod_loop:
        mov err_flag, 0
        call mul_values ; в tmp_res результат умножения модулей
        cmp err_flag, 1
        ; копируем результат в массив mul_array
        push cx
        push si
        je .no_mul_flag
        mov si, offset tmp_res
    .no_mul_flag:
        mov cx, 10
        .copy_loop:
            mov dl, [si]
            mov [bx], dl
            inc si
            inc bx
            loop .copy_loop
        pop si
        pop cx
        ; здесь копирование завершено

        ; перемещаем указатели к следующим элементам:
        add si, 10
        add di, 10
        loop .prod_loop

    ; восстанавливаем состояние
    pop di
    pop si
    pop dx
    pop cx
    pop bx
    pop ax

    ret     ; возврат
fill_mul_array endp


to_bin_decimal proc
    ; Процедура для перевода числа из ascii в десятичное представление
    ; В выходном массиве первый байт для учета знака (0 неотрицательное(положительное), 1 - отрицательное)
    ; все числа будут выровнены по разрядам (дополнены незначащими нулями)
    ; В in_str содержится буфер ввода
    ;   1й байт: размер буфера
    ;   2й байт: количество введенных символов (включая знак минус)
    ;   с третьего по предпоследний: ascii символы введенного числа
    ;   последний символ завершения ввода - 0Dh
    ; Результат:
    ; в буфере tmp_num записано десятичное представление введенного числа,
    ; первый байт - знаковый
    ; так как при переводе все разряды заполняются новым байтом знака, цифрами разряда или незначащими нулями,
    ; то предварительная очистка буфера перед новой записью не требуется

    ; сохранение состояния
    push ax ; используется для хранения числа 30h и использовании в команде sub
    push bx ; используется для получения ascii-кода очередного символа
    push cx ; используется в роли счетчика обработанных символов
    push dx ; используется для хранения количества незначащих нулей
    push di ; используется для адресации выходного буфера
    push si ; используется для адресации входного буфера

    ; предварительная очистка регистров
    xor ax, ax
    xor bx, bx
    xor dx, dx
    xor si, si
    xor di, di

    mov si, offset in_str
    ; начальная инициализация
    mov al, 30h
    mov di, offset tmp_num

    ; инициализируем счетчик числом символов в строке
    inc si
    mov cx, [si]
    mov dl, [si] ; записываем количество символов
    xor ch, ch   ; чистим старший(лишний) байт

    ; двигаем указатель на первый символ во входном буфере
    inc si

    ; проверка на наличие символа '-', если присутствует, записываем байт знака в выходной буфер
    ; по умолчанию байт знака инициализирован нулем, что соответствует неотрицательному числу
    ; и двигаем указатель, если нет прыгаем к основному циклу обработки
    cmp byte ptr [si], NEGATIVE
        jne .positive
        mov [di], byte ptr 1 ; запись знакового байта
        inc si
        dec cx
        dec dl      ; если был знак минус уменьшаем количество символов в буфере на 1
        inc di
        jmp .null_filling
    .positive:
        mov [di], byte ptr 0  ; запись знакового байта
        inc di      ; если число позитивное двигаем указатель выходного буфера на первый символ
    .null_filling:  ; заполнение незначащими нулями
        cmp dl, 10  ; все числа десяти разрядные с незначащими нулями
        jge .cycle
        mov [di], byte ptr 0
        inc di
        inc dl
        jmp .null_filling

    ; основной цикл - получаем ascii код, вычитаем из него 30 (так как символы 0-9 имеют коды 30-39)
    ; записываем в выходной буфер, двигаем указатели
    .cycle:
        mov bx, [si]
        xor bh, bh
        sub bx, ax    ; в bl результат вычитания
        mov [di], bl
        inc di
        inc si
        loop .cycle

    ; восстанавливаем исходное состояние регистров
    pop si
    pop di
    pop dx
    pop cx
    pop bx
    pop ax

    ret

to_bin_decimal endp

sum_values proc
    ; Процедура для сложения двух неотрицательных десяти разрядных двоично-десятичных чисел
    ; задано ограничение для числа: |-36768| * |36767| = 1 073 709 056, десять разрядов защищают от переполнения
    ; вход:
    ;     si - адрес первого числа
    ;     di - адрес второго числа
    ; результат в tmp_res

    ; сохраняем состояние стека
    push ax
    push bx
    push cx
    push dx
    push si
    push di

    ; очистка регистров
    xor ax, ax
    xor cx, cx

    mov cx, 10 ; инициализируем счетчик - 10 байт числа = 10 итераций

    ; двигаем указатели на последние разряды (байты) чисел
    add si, 9
    add di, 9

    .sum_cycle:
        ; очистка регистров
        xor bx, bx
        xor dx, dx

        add al, byte ptr [si] ; добавляем очередной разряд первого числа в al, в ax очередной разряд + переполнение
        mov bl, byte ptr [di] ; перемещаем очередной разряд второго числа в bl
        add ax, bx            ; складываем, результат в ax
        mov bx, 10            ; в bx делитель - 10
        div bx                ; в ax результат, в dx остаток от деления на 10 суммы разрядов сложенной с переполнением

        ; инициализируем bx индексом разряда в результирующем буфере (состояние декрементного счетчика - 1)
        mov bx, cx
        dec bx
        mov tmp_res[bx], dl   ; записываем остаток в разряд результата

        ; двигаем указатели в слагаемых
        dec si
        dec di

        loop .sum_cycle       ; уменьшаем cx, переходим к следующей итерации

    ; восстанавливаем состояние стека
    pop di
    pop si
    pop dx
    pop cx
    pop bx
    pop ax

    ret
sum_values endp

mul_values proc
    ; процедура для умножения двух неотрицательных десяти разрядных двоично-десятичных чисел
    ; в si - адрес первого числа
    ; в di - адрес второго числа
    ; результат - в tmp_res

    push ax
    push bx
    push cx
    push si
    push di

    xor ax, ax
    xor bx, bx
    xor cx, cx

    ; проверка на ноль в первом числе
    push di
    mov di, si
    call to_hex_decimal
    pop di
    cmp cx, 0
    je .no_mul

    ; проверка на 1 во втором числе
    call to_hex_decimal   ; преобразование второго числа к десятичному виду, результат в cx
    cmp cx, 1
    je .no_mul

    dec cx
    mov di, si            ; умножение реализуем как сложение num1 с самим собой num2 - 1 раз
    .add_cycle:
        call sum_values   ; результат сложения двоично-десятичных чисел из si и di в tmp_res
        mov si, offset tmp_res
        loop .add_cycle
    jmp .mul_exit

    .no_mul:
        mov err_flag, 1

    .mul_exit:
        pop di
        pop si
        pop cx
        pop bx
        pop ax
        ret
mul_values endp

to_hex_decimal proc
    ; Процедура для перевода числа из двоично-десятичного в десятичное представление в шестнадцатеричной записи
    ; В регистре di ожидается адрес двоично-десятичного числа
    ; Результат:
    ; в cx записано шестнадцатеричное представление  десятичного числа
    ; данная процедура необходима для инициализации счетчика для процедуры умножения чисел
    ; так как в данной программе задано ограничение по модулю для вводимого числа равное 32768,
    ; то переполнения регистра cx не случится в процессе перевода числа в нужный вид


    ; сохранение состояния
    push ax ;
    push bx ; множитель 10
    push si ; для умножения на разряд
    push di ; адрес числа которое нужно преобразовать

    ; предварительная очистка регистров
    xor ax, ax
    xor bx, bx
    xor cx, cx
    xor si, si

    ; Преобразование в десятичное число (в шестнадцатеричном представлении)
    mov cx, 0       ; счетчик для суммирования числа
    mov bx, 10      ; множитель для умножения предыдущей суммы на 10
    mov si, 10      ; в si количество разрядов числа (возможны незначащие нули слева)

.convert_loop:
    cmp si, 0
    je .conv_end
    xor ax, ax
    mov al, [di]    ; загружаем символ из строки
    cmp al, 0
    je .zero_rank
    push si         ; сохраняем текущее значение обрабатываемого разряда

; умножаем очередной разряд на 10 соответствующее количество раз
.rank_mul:
    dec si
    cmp si, 0
    je .conv_cont
    mul BX          ; умножаем предыдущую сумму на 10
    jmp .rank_mul

.conv_cont:
    pop si
    add CX, AX      ; добавляем текущее значение к сумме
.zero_rank:
    inc di          ; переходим к следующему символу
    dec si
    jmp .convert_loop


.conv_end:
    pop di
    pop si
    pop bx
    pop ax

    ret
to_hex_decimal endp

sum_mul_array proc
    ; Процедура для получения суммы элементов массива mul_array
    ; подразумевается что mul_array заполнен двоично-десятичными десяти-разрядными модулями попарных произведений
    ; результат в tmp_res

    push di ; используется как указатель на адрес слагаемого (tmp_res)
    push si ; используется как указатель на mul_array
    push cx ; счетчик обработанных элементов

    xor si, si
    xor cx, cx

    call clear_tmp_res

    ; инициализация указателей
    mov di, offset tmp_res
    mov si, offset mul_array

    mov cl, [si]         ; инициализация счетчика элементов массива
    inc si               ; двигаем указатель на первое произведение

    .sum_mul_cycle:
        call sum_values  ; результат сложения двоично-десятичных чисел из si и di в tmp_res
        add si, 10
        loop .sum_mul_cycle

    pop cx
    pop si
    pop di
    ret
sum_mul_array endp

result_to_string proc
    ; Процедура для наполнения буфера res_str символами численного результата (модуля)
    ; подразумевается что буфер tmp_res содержит результат вычисления суммы попарных (разделенных по знаку)
    ; произведений введенных чисел
    push si ; используется как указатель на tmp_res
    push di ; используется как указатель на res_str
    push ax ; используется как промежуточная переменная для обработки символа
    push cx ; счетчик обработанных символов (байт)

    ; очистка регистров
    xor si, si
    xor di, di
    xor ax, ax
    xor cx, cx

    mov si, offset tmp_res
    mov di, offset res_str + 1    ; пропускаем первый байт - символ '-'
    mov cx, 10

    .del_zeros:
        mov al, [si]
        cmp al, 0
        jne .true_num_cycle
        dec cx
        inc si
        jmp .del_zeros
    .true_num_cycle:
        mov al, [si]
        add al, 30h
        mov [di], al
        inc di
        inc si
        loop .true_num_cycle

    pop ax
    pop cx
    pop di
    pop si
    ret

result_to_string endp
