Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 1
main.asm



      1				     .8086
      2	0000			     .MODEL SMALL
      3
      4				     include macros.asm
1     5
1     6
1     7				     print macro text ;вывод сообщений на экран
1     8					     push ax
1     9					     push dx
1    10					     mov dx,offset text
1    11					     mov ah,9
1    12					     int 21h
1    13					     pop dx
1    14					     pop ax
1    15				     endm
1    16
1    17				     input macro text ;ввод	строки символов
1    18					 ; сохранение	состояния в стеке
1    19					     push ax
1    20					     push dx
1    21					     push bx
1    22					 ; запись	ввода в буфер text
1    23				     .retry:
1    24					     mov dx,offset text
1    25					     mov ah,0ah
1    26					     int 21h
1    27
1    28					     inc dx
1    29					     mov bx, dx
1    30					     mov bl, [bx] ; количество введенных символов
1    31					     cmp bl, 0h	  ; проверка на пустую строку
1    32					     jne .not_empty
1    33					     print empty_mess
1    34					 print input_mess
1    35					 jmp .retry
1    36
1    37				     .not_empty:
1    38					 mov bx, dx
1    39					     inc bx
1    40					     mov bl, [bx] ; первый введенный символ
1    41					     cmp bl, 18h  ; проверка на ввод ctrl+x (= выход)
1    42					     jne .not_exit
1    43					     print exit_mess
1    44					     jmp .end_program
1    45				     .not_exit:
1    46					     ; возврат состояния из стека
1    47					 pop bx
1    48					     pop dx
1    49					     pop ax
1    50				     endm
1    51
1    52				     exit macro
1    53					 ; завершение	программы
1    54					 mov ah, 4ch
1    55					 mov al, 0
1    56					 int 21h
1    57					 ret
Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 2
main.asm



1    58				     endm
     59				     include data.asm
1    60	0000			     .data
1    61	      =	002D			 NEGATIVE	  equ 2Dh ; шестнадцатеричный ascii код знака '-'
1    62	      =	0008			 NUMS_SIZE	  equ 8h  ; количество вводимых чисел
1    63	      =	0005			 MAX_POS_LEN	  equ 5h  ; максимальная длина	положительного+
     64				     числа
1    65	      =	0006			 MAX_NEG_LEN	  equ 6h  ; максимальная длина	отрицательного+
     66				     числа	с учетом	знака
1    67	      =	0037			 POS_MAX_LAST	  equ 37h ; младший разряд	верхнего		    +
     68				     ограничения (ascii, hex)
1    69	      =	0038			 NEG_MAX_LAST	  equ 38h ; младший разряд	нижнего			    +
     70				     ограничения (ascii, hex)
1    71	0000  33 32 37 36		 MAX_NUM    db '3276' ;	старшие разряды модуля			    +
     72				     максимального	числа без последнего разряда
1    73
1    74					 ; текстовые переменные для вывода
1    75	0004  49 6E 70 75 74 3A	20+	 start_mess db 'Input: 8 numbers in [-32768, 32767]', 10, 'Press <Enter> after each number',+
     76	      38 20 6E 75 6D 62	65+  10,13,'$'
     77	      72 73 20 69 6E 20	5B+
     78	      2D 33 32 37 36 38	2C+
     79	      20 33 32 37 36 37	5D+
     80	      0A 50 72 65 73 73	20+
     81	      3C 45 6E 74 65 72	3E+
     82	      20 61 66 74 65 72	20+
     83	      65 61 63 68 20 6E	75+
     84	      6D 62 65 72 0A 0D	24
1    85	004A  45 6E 74 65 72 20	6E+	 input_mess db 'Enter number: $'
     86	      75 6D 62 65 72 3A	20+
     87	      24
1    88	0059  6F 75 74 70 75 74	20+	 output_mess db	'output	(sum of	pairwise products of numbers of	different signs):', 10,	13, +
     89	      28 73 75 6D 20 6F	66+  '$'
     90	      20 70 61 69 72 77	69+
     91	      73 65 20 70 72 6F	64+
     92	      75 63 74 73 20 6F	66+
     93	      20 6E 75 6D 62 65	72+
     94	      73 20 6F 66 20 64	69+
     95	      66 66 65 72 65 6E	74+
     96	      20 73 69 67 6E 73	29+
     97	      3A 0A 0D 24
1    98	009C  49 6E 70 75 74 20	45+	 empty_mess db 'Input Error: empty string. Try again or	use ctrl+x and press enter for	    +
     99	      72 72 6F 72 3A 20	65+  exit.', 10, '$'
    100	      6D 70 74 79 20 73	74+
    101	      72 69 6E 67 2E 20	54+
    102	      72 79 20 61 67 61	69+
    103	      6E 20 6F 72 20 75	73+
    104	      65 20 63 74 72 6C	2B+
    105	      78 20 61 6E 64 20	70+
    106	      72 65 73 73 20 65	6E+
    107	      74 65 72 20 66 6F	72+
    108	      20 65 78 69 74 2E	0A+
    109	      24
1   110	00EA  50 72 6F 67 72 61	6D+	 exit_mess  db 'Program	was aborted by keybord', 10, '$'
    111	      20 77 61 73 20 61	62+
    112	      6F 72 74 65 64 20	62+
    113	      79 20 6B 65 79 62	6F+
    114	      72 64 0A 24
Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 3
main.asm



1   115	010A  49 6E 70 75 74 20	65+	 err_mess   db 'Input error!', 10, '$'
    116	      72 72 6F 72 21 0A	24
1   117	0118  0A 24			 carret	    db 10, '$'
1   118
1   119					 ; буферные переменные
1   120	011A  0A*(00)			 tmp_res    db 10 dup(0)	  ; переменная для	промежуточного+
    121				     сохранения результата сложения/умножения
1   122									  ; двух десяти-разрядных		    +
    123				     беззнаковых двоично-десятичных	чисел
1   124	0124  00 0A*(??)		 tmp_num    db 0, 10 dup(?)	  ; переменная для	промежуточного+
    125				     сохранения двоично-десятичного	представления числа
1   126									  ; первый байт tmp_num - знаковый,
1   127									  ; все операции над 10 разрядными  +
    128				     двоично-десятичными числами (с незначащими нулями)
1   129	012F  07 ?? 06*(??)		 in_str	    db 7, ?, 6 dup (?)	    ; буфер ввода 1 байт размер	    +
    130				     буфера, второй	-количество введенных символов
1   131	0137  0C*(24)			 res_str    db 12 dup ('$')	  ; буфер для преобразования	    +
    132				     результата в строку
1   133									  ; (произведения разных знаков, а +
    134				     также	их последующие суммы всегда отрицательны)
1   135
1   136					 ; массивы, первый	байт в массиве для учета		    +
    137				     количества записанных чисел
1   138	0143  00 04*(0A*(??))		 pos_array  db 0, 4 dup(10 dup(?)) ; массив для пяти модулей	    +
    139				     положительных	двоично-десятичных чисел размером	5   +
    140				     байт
1   141	016C  00 04*(0A*(??))		 neg_array  db 0, 4 dup(10 dup(?)) ; массив для пяти модулей	    +
    142				     отрицательных	двоично-десятичных чисел размером	5   +
    143				     байт
1   144	0195  00 04*(0A*(??))		 mul_array  db 0, 4 dup(10 dup(?)) ; массив модулей поэлементных   +
    145				     произведений массивов
1   146
1   147					 ; флаги
1   148	01BE  00			 neg_flag   db 0     ; флаг	наличия знака '-' для is_correct	proc
1   149	01BF  00			 err_flag   db 0     ; флаг	ошибки во вводе для is_correct		    +
    150				     proc/цикла ввода
1   151
1   152
    153
    154	01C0			     .code
    155	0000			     start:
    156					; инициализация памяти
    157	0000  B8 0000s			 mov ax, @data
    158	0003  8E D8			 mov ds, ax
    159
    160					 ;вызов функции 0 -	 установка 3 текстового		    +
    161				     видеорежима, очистка экрана
    162	0005  B8 0003			 mov ax, 0003  ; ah=0 (номер функции), al=3	(номер режима)
    163	0008  CD 10			 int 10h
    164
    165					 print start_mess  ; вывод	стартового сообщения
1   166	000A  50			     push ax
1   167	000B  52			     push dx
1   168	000C  BA 0004r			     mov dx,offset start_mess
1   169	000F  B4 09			     mov ah,9
1   170	0011  CD 21			     int 21h
1   171	0013  5A			     pop dx
Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 4
main.asm



1   172	0014  58			     pop ax
    173	0015  33 C9			 xor cx, cx
    174	0017  B9 0008			 mov cx, NUMS_SIZE ; в	cx количество	чисел для ввода		    +
    175				     пользователем
    176
    177					 ; инициализация указателей на	первые элементы	    +
    178				     массивов без учета	размерного байта	(используется в+
    179				     add_value proc)
    180	001A  BE 0144r			 mov si, offset	pos_array + 1
    181	001D  BF 016Dr			 mov di, offset	neg_array + 1
    182
    183					 ; цикл ввода/проверки/распределения по	массивам
    184	0020				 .input:
    185					     print input_mess  ;вывод сообщения о вводе строки
1   186	0020  50			     push ax
1   187	0021  52			     push dx
1   188	0022  BA 004Ar			     mov dx,offset input_mess
1   189	0025  B4 09			     mov ah,9
1   190	0027  CD 21			     int 21h
1   191	0029  5A			     pop dx
1   192	002A  58			     pop ax
    193					     input in_str      ;ввод числа в виде	строки
1   194	002B  50			     push ax
1   195	002C  52			     push dx
1   196	002D  53			     push bx
1   197	002E			     .retry:
1   198	002E  BA 012Fr			     mov dx,offset in_str
1   199	0031  B4 0A			     mov ah,0ah
1   200	0033  CD 21			     int 21h
1   201	0035  42			     inc dx
1   202	0036  8B DA			     mov bx, dx
1   203	0038  8A 1F			     mov bl, [bx] ; количество введенных символов
1   204	003A  80 FB 00			     cmp bl, 0h	  ; проверка на пустую строку
1   205	003D  75 18			     jne .not_empty
1   206					     print empty_mess
2   207	003F  50			     push ax
2   208	0040  52			     push dx
2   209	0041  BA 009Cr			     mov dx,offset empty_mess
2   210	0044  B4 09			     mov ah,9
2   211	0046  CD 21			     int 21h
2   212	0048  5A			     pop dx
2   213	0049  58			     pop ax
1   214					 print input_mess
2   215	004A  50			     push ax
2   216	004B  52			     push dx
2   217	004C  BA 004Ar			     mov dx,offset input_mess
2   218	004F  B4 09			     mov ah,9
2   219	0051  CD 21			     int 21h
2   220	0053  5A			     pop dx
2   221	0054  58			     pop ax
1   222	0055  EB D7			 jmp .retry
1   223	0057			     .not_empty:
1   224	0057  8B DA			 mov bx, dx
1   225	0059  43			     inc bx
1   226	005A  8A 1F			     mov bl, [bx] ; первый введенный символ
1   227	005C  80 FB 18			     cmp bl, 18h  ; проверка на ввод ctrl+x (= выход)
1   228	005F  75 0E			     jne .not_exit
Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 5
main.asm



1   229					     print exit_mess
2   230	0061  50			     push ax
2   231	0062  52			     push dx
2   232	0063  BA 00EAr			     mov dx,offset exit_mess
2   233	0066  B4 09			     mov ah,9
2   234	0068  CD 21			     int 21h
2   235	006A  5A			     pop dx
2   236	006B  58			     pop ax
1   237	006C  EB 58 90			     jmp .end_program
1   238	006F			     .not_exit:
1   239	006F  5B			 pop bx
1   240	0070  5A			     pop dx
1   241	0071  58			     pop ax
    242
    243					     ; проверки, заполнение массивов
    244	0072  E8 0058			     call is_correct   ; проверка на корректность	символов    +
    245				     числа, установка err_flag
    246	0075  80 3E 01BFr 00		     cmp err_flag, 0
    247	007A  74 0D			     je	.correct_input
    248
    249					     ; если	была ошибка вывод сообщения и			    +
    250				     циклический ввод
    251					     print err_mess
1   252	007C  50			     push ax
1   253	007D  52			     push dx
1   254	007E  BA 010Ar			     mov dx,offset err_mess
1   255	0081  B4 09			     mov ah,9
1   256	0083  CD 21			     int 21h
1   257	0085  5A			     pop dx
1   258	0086  58			     pop ax
    259	0087  EB 97			     jmp .input
    260
    261	0089				 .correct_input:
    262	0089  E8 01A1			     call to_bin_decimal  ; преобразование in_str	к			    +
    263				     двоично-десятичному виду в tmp_num (с незначащими	    +
    264				     нулями и байтом знака)
    265	008C  E8 00EF			     call add_value	  ; копирование модуля	из tmp_num в		    +
    266				     соответствующий массив
    267					     print carret	  ; печать переноса строки
1   268	008F  50			     push ax
1   269	0090  52			     push dx
1   270	0091  BA 0118r			     mov dx,offset carret
1   271	0094  B4 09			     mov ah,9
1   272	0096  CD 21			     int 21h
1   273	0098  5A			     pop dx
1   274	0099  58			     pop ax
    275	009A  E2 84			     loop .input	  ; цикл ввода
    276
    277					 ; здесь массивы pos_array и neg_array заполнены модулями	    +
    278				     соответствующих по знаку введенных чисел
    279	009C  E8 0129			 call fill_mul_array
    280	009F  E8 0284			 call sum_mul_array
    281	00A2  E8 02A0			 call result_to_string
    282					 print output_mess
1   283	00A5  50			     push ax
1   284	00A6  52			     push dx
1   285	00A7  BA 0059r			     mov dx,offset output_mess
Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 6
main.asm



1   286	00AA  B4 09			     mov ah,9
1   287	00AC  CD 21			     int 21h
1   288	00AE  5A			     pop dx
1   289	00AF  58			     pop ax
    290					 print res_str
1   291	00B0  50			     push ax
1   292	00B1  52			     push dx
1   293	00B2  BA 0137r			     mov dx,offset res_str
1   294	00B5  B4 09			     mov ah,9
1   295	00B7  CD 21			     int 21h
1   296	00B9  5A			     pop dx
1   297	00BA  58			     pop ax
    298					 print carret
1   299	00BB  50			     push ax
1   300	00BC  52			     push dx
1   301	00BD  BA 0118r			     mov dx,offset carret
1   302	00C0  B4 09			     mov ah,9
1   303	00C2  CD 21			     int 21h
1   304	00C4  5A			     pop dx
1   305	00C5  58			     pop ax
    306
    307	00C6			     .end_program:
    308					 exit ;	завершение программы
1   309	00C6  B4 4C			 mov ah, 4ch
1   310	00C8  B0 00			 mov al, 0
1   311	00CA  CD 21			 int 21h
1   312	00CC  C3			 ret
    313
    314				     include func.asm
1   315
1   316	00CD			     is_correct	proc
1   317					 ; Процедура для проверки корректности введенного +
    318				     числа
1   319					 ; число должно быть записано в	буфер in_str
1   320					 ; корректный	диапазон - [-32768, 32767]
1   321
1   322					 ; сохраняем состояние регистров
1   323	00CD  50			 push ax ; используется для хранения текущего символа
1   324	00CE  53			 push bx ; используется для хранения индекса в		    +
    325				     диапазоне	(проход по константе MAX_NUM)
1   326	00CF  51			 push cx ; используется для хранения количества	    +
    327				     обработанных символов числа
1   328	00D0  52			 push dx ; используется для хранения последнего	    +
    329				     символа диапазона в зависимости от знака
1   330	00D1  56			 push si ; используется для хранения индекса в буфере  +
    331				     ввода
1   332	00D2  57			 push di ; используется для хранения количества	    +
    333				     введенных	символов во входном буфере
1   334
1   335					 ; очистка используемых регистров
1   336	00D3  33 C0			 xor ax, ax
1   337	00D5  33 DB			 xor bx, bx
1   338	00D7  33 C9			 xor cx, cx
1   339	00D9  33 D2			 xor dx, dx
1   340	00DB  33 F6			 xor si, si
1   341	00DD  33 FF			 xor di, di
1   342
Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 7
main.asm



1   343					 ; инициализация di количеством	символов во входном+
    344				     буфере
1   345	00DF  BF 012Fr			 mov di, offset	in_str ; помещаем в di	адрес буфера	ввода
1   346	00E2  47			 inc di		 ; перемещаем	на количество символов	    +
    347				     записанных в буфер
1   348	00E3  8B 3D			 mov di, [di]	 ; загружаем 2	первых байта	из in_str в di
1   349	00E5  81 E7 00FF		 and di, 00FFh	 ; очищаем старший байт
1   350
1   351					 ; начальная инициализация
1   352	00E9  C6 06 01BEr 00		 mov neg_flag, 0 ; очистка флага для хранения знака	числа
1   353	00EE  C6 06 01BFr 00		 mov err_flag, 0 ; очистка флага для определения ошибки	    +
    354				     ввода
1   355	00F3  BE 0002			 mov si, 2	 ; Инициализация индекса числа	(пропуск	    +
    356				     служебных	байтов буфера)
1   357	00F6  BB 0000			 mov bx, 0	 ; Инициализация индекса для			    +
    358				     максимального	диапазона
1   359
1   360	00F9  8A 84 012Fr		 mov al, in_str[si]; Загрузка текущего элемента	буфера в	AL
1   361	00FD  3C 2D			 cmp al, NEGATIVE  ; Является ли первый	символ знаком '-'
1   362	00FF  75 07			 jne .is_num_cycle
1   363	0101  C6 06 01BEr 01		 mov neg_flag, 1   ; установка	флага отрицательного	числа
1   364	0106  46			 inc si		   ; перемещаем указатель в	буфере на	    +
    365				     следующий	байт (символ)
1   366	0107  41			 inc cx		   ; увеличиваем счетчик обработанных	    +
    367				     чисел
1   368
1   369					 ; проверка: является ли числом	каждый введенный	    +
    370				     символ символ (исключая первый минус)
1   371	0108				 .is_num_cycle:
1   372	0108  3B CF			     cmp cx, di		  ; если все символы обработаны
1   373	010A  74 10			     je	.max_digits_check ; выход из цикла
1   374	010C  8A 84 012Fr		     mov al, in_str[si]	  ; в al очередной ascii код ввода
1   375	0110  3C 30			     cmp al, 30h	  ; 30h	- ascii	код для числа 0, если меньше - +
    376				     ошибка ввода
1   377	0112  7C 5E			     jl	.error
1   378	0114  3C 39			     cmp al, 39h	  ; 39h	- ascii	код для числа 9, если меньше - +
    379				     ошибка ввода
1   380	0116  7F 5A			     jg	.error
1   381	0118  41			     inc cx		  ; увеличиваем счетчик
1   382	0119  46			     inc si		  ; двигаем указатель
1   383	011A  EB EC			     jmp .is_num_cycle	  ; повторяем цикл
1   384
1   385
1   386	011C				 .max_digits_check:
1   387					     ; очистка регистров
1   388	011C  33 C9			     xor cx, cx
1   389	011E  33 F6			     xor si, si
1   390
1   391	0120  80 3E 01BEr 00		     cmp neg_flag, 0	 ; проверка знака числа
1   392	0125  74 10			     je	.pos_start
1   393
1   394					     ; для отрицательных:
1   395	0127				     .neg_start:
1   396	0127  83 FF 06				 cmp di, MAX_NEG_LEN ; сравнение количества введенных   +
    397				     символов и максимального количества разрядов
1   398	012A  7C 4B				 jl .corr_end	     ; если	меньше, завершаем без	ошибки
1   399	012C  7F 44				 jg .error	     ; если	больше завершаем	с ошибкой
Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 8
main.asm



1   400						 ; если равно,	инициализация и переход к		    +
    401				     поразрядной проверке
1   402	012E  BE 0003				 mov si, 3
1   403	0131  B9 0002				 mov cx, 2	      ;	значение больше на 1 чем		    +
    404				     действительное чтобы выйти	из range_cycle раньше на 1	    +
    405				     символ
1   406	0134  EB 0E 90				 jmp .range_cycle
1   407
1   408					     ; для положительных
1   409	0137				     .pos_start:
1   410	0137  83 FF 05				 cmp di, MAX_POS_LEN ; сравнение количества введенных   +
    411				     символов и максимального количества разрядов
1   412	013A  7C 3B				 jl .corr_end	     ; если	меньше, завершаем без	ошибки
1   413	013C  7F 34				 jg .error
1   414						 ; если равно,	инициализация и переход к		    +
    415				     поразрядной проверке
1   416	013E  BE 0002				 mov si, 2
1   417	0141  B9 0001				 mov cx, 1
1   418
1   419					     ; поразрядная проверка диапазона если		    +
    420				     количество символов модуля	равно 5
1   421	0144				     .range_cycle:
1   422	0144  8A 84 012Fr			 mov al, in_str[si] ; Загрузка текущего	элемента	    +
    423				     буфера в AL
1   424	0148  3A 87 0000r			 cmp al, MAX_NUM[bx]
1   425	014C  7F 24				 jg .error
1   426	014E  7C 27				 jl .corr_end
1   427						 ; если символ равен ограничению:
1   428	0150  46				 inc si		   ; Увеличение индекса числа
1   429	0151  41				 inc cx		   ; Увеличение счетчика обработанных +
    430				     цифр
1   431	0152  43				 inc bx		   ; Увеличение индекса в строке	    +
    432				     содержащей максимальные цифры диапазона
1   433	0153  3B CF				 cmp cx, di	   ; Проверка, достигнут ли конец	    +
    434				     буфера
1   435	0155  74 02				 je .end_range	   ; Если да, прерывание цикла
1   436	0157  EB EB				 jmp .range_cycle  ; Переход на следующую итерацию	    +
    437				     цикла
1   438
1   439					     ; проверка	последнего символа если число		    +
    440				     значащих цифр равно максимальному
1   441	0159				     .end_range:
1   442	0159  80 3E 01BEr 01			 cmp neg_flag, 1
1   443	015E  74 05				 je .negative
1   444	0160  B2 37				 mov dl, POS_MAX_LAST
1   445	0162  EB 03 90				 jmp .continue
1   446	0165				     .negative:
1   447	0165  B2 38				 mov dl, NEG_MAX_LAST
1   448	0167				     .continue:
1   449	0167  8A 84 012Fr			 mov al, in_str[si] ; загружаем последний символ
1   450	016B  3A C2				 cmp al, dl
1   451	016D  7F 03				 jg .error	    ; если есть	выход за	границу		    +
    452				     диапазона	переход к ошибке
1   453	016F  EB 06 90				 jmp .corr_end
1   454
1   455					 ; завершение	с ошибкой
1   456	0172				 .error:
Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 9
main.asm



1   457	0172  C6 06 01BFr 01		     mov err_flag, 1	  ; установка флага ошибки
1   458
1   459					 ; завершение	без ошибки
1   460	0177				 .corr_end:
1   461					     ; восстанавливаем состояние из стека
1   462	0177  5F			     pop di
1   463	0178  5E			     pop si
1   464	0179  5A			     pop dx
1   465	017A  59			     pop cx
1   466	017B  5B			     pop bx
1   467	017C  58			     pop ax
1   468	017D  C3			     ret
1   469
1   470	017E			     is_correct	endp
1   471
1   472	017E			     add_value proc
1   473					 ; Процедура для копирования числа из временной	    +
    474				     переменной в соответствующий массив
1   475					 ; число представлено в двоично-десятичном виде с   +
    476				     незначащими нулями (размер на выходе 5 байт)
1   477					 ; в массивы записываем только модули, увеличиваем +
    478				     количество записанных чисел
1   479					 ; в si адрес очередного элемента в массиве		    +
    480				     положительных	чисел
1   481					 ; в di адрес очередного элемента в массиве		    +
    482				     отрицательных	чисел
1   483					 ; в tmp_num значение очередного введенного и		    +
    484				     преобразованного числа которое	нужно скопировать
1   485
1   486	017E  50			 push ax ; используется для увеличения	счетчика	    +
    487				     записанных чисел в	массиве и копирования очередной +
    488				     цифры(байта) числа
1   489	017F  53			 push bx ; используется как указатель на tmp_num
1   490	0180  51			 push cx ; счетчик элементов числа	для цикла,		    +
    491				     инициализируется числом 5 (количеством байт в	    +
    492				     каждом числе)
1   493
1   494					 ; инициализация счетчика
1   495	0181  33 C9			 xor cx, cx
1   496	0183  B9 000A			 mov cx, 10
1   497
1   498	0186  BB 0124r			 mov bx, offset	tmp_num	; инициализируем указатель на		    +
    499				     временную	переменную
1   500	0189  8A 07			 mov al, [bx]		; в al	байт знака
1   501	018B  43			 inc bx			; перемещаем указатель на первый	    +
    502				     символ
1   503	018C  3C 00			 cmp al, 0		; проверка на						    +
    504				     отрицательное/положительное число
1   505	018E  74 13			 je .pos_num
1   506
1   507					 ; увеличиваем счетчик записанных чисел в массиве  +
    508				     отрицательных	чисел
1   509	0190  A0 016Cr			 mov al, neg_array
1   510	0193  FE C0			 inc al
1   511	0195  A2 016Cr			 mov neg_array,	al
1   512
1   513					 ; по-байтовая запись модуля очередного	числа в	    +
Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 10
main.asm



    514				     массив отрицательных чисел
1   515	0198				 .neg_cycle:
1   516	0198  8A 07			     mov al, [bx]
1   517	019A  88 05			     mov [di], al
1   518	019C  43			     inc bx
1   519	019D  47			     inc di
1   520	019E  E2 F8			     loop .neg_cycle
1   521
1   522	01A0  EB 11 90			 jmp .add_value_exit
1   523
1   524	01A3				 .pos_num:
1   525					     ; увеличиваем счетчик записанных чисел в		    +
    526				     массиве положительных (неотрицательных)	чисел
1   527	01A3  A0 0143r			     mov al, pos_array
1   528	01A6  FE C0			     inc al
1   529	01A8  A2 0143r			     mov pos_array, al
1   530
1   531					 ; по-байтовая запись модуля очередного	числа в	    +
    532				     массив положительных (неотрицательных) чисел
1   533	01AB				 .pos_cycle:
1   534	01AB  8A 07			     mov al, [bx]
1   535	01AD  88 04			     mov [si], al
1   536	01AF  43			     inc bx
1   537	01B0  46			     inc si
1   538	01B1  E2 F8			     loop .pos_cycle
1   539
1   540					 ; возврат состояния
1   541	01B3				 .add_value_exit:
1   542	01B3  59			     pop cx
1   543	01B4  5B			     pop bx
1   544	01B5  58			     pop ax
1   545	01B6  C3			     ret
1   546
1   547	01B7			     add_value endp
1   548
1   549	01B7			     clear_tmp_res proc
1   550	01B7  56			 push si
1   551	01B8  51			 push cx
1   552	01B9  B9 000A			 mov cx, 10
1   553	01BC  BE 011Ar			 mov si, offset	tmp_res
1   554	01BF				 .clear_cycle:
1   555	01BF  C6 04 00			     mov byte ptr [si],	0
1   556	01C2  46			     inc si
1   557	01C3  E2 FA			     loop .clear_cycle
1   558	01C5  59			 pop cx
1   559	01C6  5E			 pop si
1   560
1   561	01C7  C3			 ret
1   562	01C8			     clear_tmp_res endp
1   563
1   564	01C8			     fill_mul_array proc
1   565					 ; процедура для заполнения массива mul_array		    +
    566				     попарными	произведениями модулей положительных и   +
    567				     отрицательных	чисел
1   568					 ; ожидается что произведен ввод с клавиатуры	    +
    569				     чисел, числа приведены к двоично-десятичному	виду
1   570					 ; массивы pos_array и neg_array заполнены модулями		    +
Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 11
main.asm



    571				     положительных	и отрицательных чисел соответственно
1   572
1   573					 ; сохраняем состояние
1   574	01C8  50			 push ax
1   575	01C9  53			 push bx
1   576	01CA  51			 push cx
1   577	01CB  52			 push dx
1   578	01CC  56			 push si
1   579	01CD  57			 push di
1   580
1   581					 ; чистим	регистры
1   582	01CE  33 C0			 xor ax, ax
1   583	01D0  33 DB			 xor bx, bx
1   584	01D2  33 C9			 xor cx, cx
1   585	01D4  33 D2			 xor dx, dx
1   586	01D6  33 F6			 xor si, si
1   587	01D8  33 FF			 xor di, di
1   588
1   589					 ; инициализация счетчика размером	меньшего из	    +
    590				     массивов введенных чисел
1   591	01DA  BB 0143r			 mov bx, offset	pos_array
1   592	01DD  8A 1F			 mov bl, [bx]
1   593	01DF  8A C3			 mov al, bl
1   594	01E1  BB 016Cr			 mov bx, offset	neg_array
1   595	01E4  8A 1F			 mov bl, [bx]
1   596	01E6  3A C3			 cmp al, bl
1   597	01E8  7F 05			 jg .pos_bigger
1   598	01EA  8A CB			 mov cl, bl
1   599	01EC  EB 03 90			 jmp .counter_initialized
1   600	01EF			     .pos_bigger:
1   601	01EF  8A C8			 mov cl, al
1   602
1   603	01F1			     .counter_initialized:
1   604					 ; инициализация указателей на	массивы с модулями  +
    605				     чисел
1   606	01F1  BE 0144r			 mov si, offset	pos_array + 1
1   607	01F4  BF 016Dr			 mov di, offset	neg_array + 1
1   608
1   609					 ; заполнение	массива mul_array
1   610	01F7  BB 0195r			 mov bx, offset	mul_array
1   611	01FA  89 0F			 mov [bx], byte	ptr cx	 ; запись	в массив	mul_array количества	    +
    612				     элементов
1   613	01FC  43			 inc bx			 ; двигаем указатель на первый		    +
    614				     результат
1   615	01FD				 .prod_loop:
1   616	01FD  C6 06 01BFr 00		     mov err_flag, 0
1   617	0202  E8 00B0			     call mul_values ; в tmp_res результат умножения	модулей
1   618	0205  80 3E 01BFr 01		     cmp err_flag, 1
1   619					     ; копируем	результат в массив mul_array
1   620	020A  51			     push cx
1   621	020B  56			     push si
1   622	020C  74 03			     je	.no_mul_flag
1   623	020E  BE 011Ar			     mov si, offset tmp_res
1   624	0211				 .no_mul_flag:
1   625	0211  B9 000A			     mov cx, 10
1   626	0214				     .copy_loop:
1   627	0214  8A 14				 mov dl, [si]
Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 12
main.asm



1   628	0216  88 17				 mov [bx], dl
1   629	0218  46				 inc si
1   630	0219  43				 inc bx
1   631	021A  E2 F8				 loop .copy_loop
1   632	021C  5E			     pop si
1   633	021D  59			     pop cx
1   634					     ; здесь копирование завершено
1   635
1   636					     ; перемещаем указатели к следующим элементам:
1   637	021E  83 C6 0A			     add si, 10
1   638	0221  83 C7 0A			     add di, 10
1   639	0224  E2 D7			     loop .prod_loop
1   640
1   641					 ; восстанавливаем состояние
1   642	0226  5F			 pop di
1   643	0227  5E			 pop si
1   644	0228  5A			 pop dx
1   645	0229  59			 pop cx
1   646	022A  5B			 pop bx
1   647	022B  58			 pop ax
1   648
1   649	022C  C3			 ret	 ; возврат
1   650	022D			     fill_mul_array endp
1   651
1   652
1   653	022D			     to_bin_decimal proc
1   654					 ; Процедура для перевода числа из ascii в десятичное +
    655				     представление
1   656					 ; В выходном массиве первый байт для учета знака (0 +
    657				     неотрицательное(положительное), 1 - отрицательное)
1   658					 ; все числа будут	выровнены по	разрядам (дополнены+
    659				     незначащими нулями)
1   660					 ; В in_str содержится буфер ввода
1   661					 ;   1й байт: размер	буфера
1   662					 ;   2й байт: количество	введенных символов (включая +
    663				     знак минус)
1   664					 ;   с	третьего по предпоследний: ascii	символы		    +
    665				     введенного числа
1   666					 ;   последний	символ завершения ввода - 0Dh
1   667					 ; Результат:
1   668					 ; в буфере tmp_num записано десятичное представление +
    669				     введенного числа,
1   670					 ; первый	байт - знаковый
1   671					 ; так как при	переводе все	разряды заполняются	    +
    672				     новым	байтом знака, цифрами	разряда или незначащими+
    673				     нулями,
1   674					 ; то	предварительная очистка буфера перед новой    +
    675				     записью не требуется
1   676
1   677					 ; сохранение	состояния
1   678	022D  50			 push ax ; используется для хранения числа 30h и		    +
    679				     использовании	в команде sub
1   680	022E  53			 push bx ; используется для получения ascii-кода		    +
    681				     очередного символа
1   682	022F  51			 push cx ; используется в роли	счетчика обработанных   +
    683				     символов
1   684	0230  52			 push dx ; используется для хранения количества	    +
Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 13
main.asm



    685				     незначащих нулей
1   686	0231  57			 push di ; используется для адресации выходного буфера
1   687	0232  56			 push si ; используется для адресации входного буфера
1   688
1   689					 ; предварительная очистка регистров
1   690	0233  33 C0			 xor ax, ax
1   691	0235  33 DB			 xor bx, bx
1   692	0237  33 D2			 xor dx, dx
1   693	0239  33 F6			 xor si, si
1   694	023B  33 FF			 xor di, di
1   695
1   696	023D  BE 012Fr			 mov si, offset	in_str
1   697					 ; начальная инициализация
1   698	0240  B0 30			 mov al, 30h
1   699	0242  BF 0124r			 mov di, offset	tmp_num
1   700
1   701					 ; инициализируем	счетчик числом символов в	строке
1   702	0245  46			 inc si
1   703	0246  8B 0C			 mov cx, [si]
1   704	0248  8A 14			 mov dl, [si] ;	записываем количество символов
1   705	024A  32 ED			 xor ch, ch   ;	чистим старший(лишний) байт
1   706
1   707					 ; двигаем указатель на первый символ во входном	    +
    708				     буфере
1   709	024C  46			 inc si
1   710
1   711					 ; проверка на наличие	символа '-', если			    +
    712				     присутствует, записываем байт знака	в выходной	    +
    713				     буфер
1   714					 ; по	умолчанию байт знака инициализирован нулем,   +
    715				     что соответствует неотрицательному	числу
1   716					 ; и двигаем указатель, если нет прыгаем	к		    +
    717				     основному	циклу обработки
1   718	024D  80 3C 2D			 cmp byte ptr [si], NEGATIVE
1   719	0250  75 0B			     jne .positive
1   720	0252  C6 05 01			     mov [di], byte ptr	1 ; запись знакового байта
1   721	0255  46			     inc si
1   722	0256  49			     dec cx
1   723	0257  FE CA			     dec dl	 ; если был знак минус уменьшаем		    +
    724				     количество символов в буфере на	1
1   725	0259  47			     inc di
1   726	025A  EB 05 90			     jmp .null_filling
1   727	025D				 .positive:
1   728	025D  C6 05 00			     mov [di], byte ptr	0  ; запись знакового байта
1   729	0260  47			     inc di	 ; если число позитивное двигаем		    +
    730				     указатель	выходного буфера	на первый символ
1   731	0261				 .null_filling:	 ; заполнение	незначащими нулями
1   732	0261  80 FA 0A			     cmp dl, 10	 ; все числа десяти разрядные с			    +
    733				     незначащими нулями
1   734	0264  7D 08			     jge .cycle
1   735	0266  C6 05 00			     mov [di], byte ptr	0
1   736	0269  47			     inc di
1   737	026A  FE C2			     inc dl
1   738	026C  EB F3			     jmp .null_filling
1   739
1   740					 ; основной цикл - получаем	ascii код, вычитаем из него+
    741				     30	(так	как символы 0-9 имеют коды 30-39)
Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 14
main.asm



1   742					 ; записываем	в выходной буфер,	двигаем указатели
1   743	026E				 .cycle:
1   744	026E  8B 1C			     mov bx, [si]
1   745	0270  32 FF			     xor bh, bh
1   746	0272  2B D8			     sub bx, ax	   ; в	bl результат вычитания
1   747	0274  88 1D			     mov [di], bl
1   748	0276  47			     inc di
1   749	0277  46			     inc si
1   750	0278  E2 F4			     loop .cycle
1   751
1   752					 ; восстанавливаем исходное состояние регистров
1   753	027A  5E			 pop si
1   754	027B  5F			 pop di
1   755	027C  5A			 pop dx
1   756	027D  59			 pop cx
1   757	027E  5B			 pop bx
1   758	027F  58			 pop ax
1   759
1   760	0280  C3			 ret
1   761
1   762	0281			     to_bin_decimal endp
1   763
1   764	0281			     sum_values	proc
1   765					 ; Процедура для сложения двух неотрицательных	    +
    766				     десяти разрядных двоично-десятичных чисел
1   767					 ; задано	ограничение для числа: |-36768| * |36767| = 1 073 709    +
    768				     056, десять разрядов	защищают от переполнения
1   769					 ; вход:
1   770					 ;     si - адрес первого числа
1   771					 ;     di - адрес второго числа
1   772					 ; результат в tmp_res
1   773
1   774					 ; сохраняем состояние стека
1   775	0281  50			 push ax
1   776	0282  53			 push bx
1   777	0283  51			 push cx
1   778	0284  52			 push dx
1   779	0285  56			 push si
1   780	0286  57			 push di
1   781
1   782					 ; очистка регистров
1   783	0287  33 C0			 xor ax, ax
1   784	0289  33 C9			 xor cx, cx
1   785
1   786	028B  B9 000A			 mov cx, 10 ; инициализируем счетчик - 10 байт	числа = 10	    +
    787				     итераций
1   788
1   789					 ; двигаем указатели на последние разряды (байты)    +
    790				     чисел
1   791	028E  83 C6 09			 add si, 9
1   792	0291  83 C7 09			 add di, 9
1   793
1   794	0294				 .sum_cycle:
1   795					     ; очистка регистров
1   796	0294  33 DB			     xor bx, bx
1   797	0296  33 D2			     xor dx, dx
1   798
Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 15
main.asm



1   799	0298  02 04			     add al, byte ptr [si] ; добавляем	очередной разряд		    +
    800				     первого числа в al, в ax очередной разряд +			    +
    801				     переполнение
1   802	029A  8A 1D			     mov bl, byte ptr [di] ; перемещаем очередной разряд	    +
    803				     второго числа в bl
1   804	029C  03 C3			     add ax, bx		   ; складываем, результат в ax
1   805	029E  BB 000A			     mov bx, 10		   ; в	bx делитель - 10
1   806	02A1  F7 F3			     div bx		   ; в	ax результат, в dx остаток от	    +
    807				     деления на 10 суммы разрядов	сложенной с			    +
    808				     переполнением
1   809
1   810					     ; инициализируем bx индексом	разряда в		    +
    811				     результирующем буфере (состояние декрементного	    +
    812				     счетчика -	1)
1   813	02A3  8B D9			     mov bx, cx
1   814	02A5  4B			     dec bx
1   815	02A6  88 97 011Ar		     mov tmp_res[bx], dl   ; записываем остаток в разряд	    +
    816				     результата
1   817
1   818					     ; двигаем указатели в слагаемых
1   819	02AA  4E			     dec si
1   820	02AB  4F			     dec di
1   821
1   822	02AC  E2 E6			     loop .sum_cycle	   ; уменьшаем	cx, переходим к следующей+
    823				     итерации
1   824
1   825					 ; восстанавливаем состояние стека
1   826	02AE  5F			 pop di
1   827	02AF  5E			 pop si
1   828	02B0  5A			 pop dx
1   829	02B1  59			 pop cx
1   830	02B2  5B			 pop bx
1   831	02B3  58			 pop ax
1   832
1   833	02B4  C3			 ret
1   834	02B5			     sum_values	endp
1   835
1   836	02B5			     mul_values	proc
1   837					 ; процедура для умножения	двух неотрицательных	    +
    838				     десяти разрядных двоично-десятичных чисел
1   839					 ; в si - адрес первого числа
1   840					 ; в di - адрес второго числа
1   841					 ; результат -	в tmp_res
1   842
1   843	02B5  50			 push ax
1   844	02B6  53			 push bx
1   845	02B7  51			 push cx
1   846	02B8  56			 push si
1   847	02B9  57			 push di
1   848
1   849	02BA  33 C0			 xor ax, ax
1   850	02BC  33 DB			 xor bx, bx
1   851	02BE  33 C9			 xor cx, cx
1   852
1   853					 ; проверка на ноль в первом числе
1   854	02C0  57			 push di
1   855	02C1  8B FE			 mov di, si
Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 16
main.asm



1   856	02C3  E8 0027			 call to_hex_decimal
1   857	02C6  5F			 pop di
1   858	02C7  83 F9 00			 cmp cx, 0
1   859	02CA  74 16			 je .no_mul
1   860
1   861					 ; проверка на 1 во	втором числе
1   862	02CC  E8 001E			 call to_hex_decimal   ; преобразование второго числа	к	    +
    863				     десятичному виду, результат в cx
1   864	02CF  83 F9 01			 cmp cx, 1
1   865	02D2  74 0E			 je .no_mul
1   866
1   867	02D4  49			 dec cx
1   868	02D5  8B FE			 mov di, si	       ; умножение реализуем как сложение num1 +
    869				     с	самим собой num2 - 1 раз
1   870	02D7				 .add_cycle:
1   871	02D7  E8 FFA7			     call sum_values   ; результат сложения				    +
    872				     двоично-десятичных чисел из si и di в tmp_res
1   873	02DA  BE 011Ar			     mov si, offset tmp_res
1   874	02DD  E2 F8			     loop .add_cycle
1   875	02DF  EB 06 90			 jmp .mul_exit
1   876
1   877	02E2				 .no_mul:
1   878	02E2  C6 06 01BFr 01		     mov err_flag, 1
1   879
1   880	02E7				 .mul_exit:
1   881	02E7  5F			     pop di
1   882	02E8  5E			     pop si
1   883	02E9  59			     pop cx
1   884	02EA  5B			     pop bx
1   885	02EB  58			     pop ax
1   886	02EC  C3			     ret
1   887	02ED			     mul_values	endp
1   888
1   889	02ED			     to_hex_decimal proc
1   890					 ; Процедура для перевода числа из				    +
    891				     двоично-десятичного в десятичное представление в    +
    892				     шестнадцатеричной	записи
1   893					 ; В регистре di ожидается адрес					    +
    894				     двоично-десятичного числа
1   895					 ; Результат:
1   896					 ; в cx записано шестнадцатеричное представление	    +
    897				     десятичного числа
1   898					 ; данная	процедура необходима	для инициализации   +
    899				     счетчика для процедуры	умножения чисел
1   900					 ; так как в данной программе задано ограничение	по+
    901				     модулю для вводимого числа равное 32768,
1   902					 ; то	переполнения регистра cx не случится в		    +
    903				     процессе перевода числа в нужный вид
1   904
1   905
1   906					 ; сохранение	состояния
1   907	02ED  50			 push ax ;
1   908	02EE  53			 push bx ; множитель 10
1   909	02EF  56			 push si ; для умножения на разряд
1   910	02F0  57			 push di ; адрес числа которое	нужно преобразовать
1   911
1   912					 ; предварительная очистка регистров
Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 17
main.asm



1   913	02F1  33 C0			 xor ax, ax
1   914	02F3  33 DB			 xor bx, bx
1   915	02F5  33 C9			 xor cx, cx
1   916	02F7  33 F6			 xor si, si
1   917
1   918					 ; Преобразование	в десятичное	число (в			    +
    919				     шестнадцатеричном	представлении)
1   920	02F9  B9 0000			 mov cx, 0	 ; счетчик для суммирования числа
1   921	02FC  BB 000A			 mov bx, 10	 ; множитель для умножения	предыдущей	    +
    922				     суммы	на 10
1   923	02FF  BE 000A			 mov si, 10	 ; в si количество разрядов числа (возможны +
    924				     незначащие нули слева)
1   925
1   926	0302			     .convert_loop:
1   927	0302  83 FE 00			 cmp si, 0
1   928	0305  74 1A			 je .conv_end
1   929	0307  33 C0			 xor ax, ax
1   930	0309  8A 05			 mov al, [di]	 ; загружаем символ из	строки
1   931	030B  3C 00			 cmp al, 0
1   932	030D  74 0E			 je .zero_rank
1   933	030F  56			 push si	 ; сохраняем текущее значение			    +
    934				     обрабатываемого разряда
1   935
1   936				     ; умножаем	очередной разряд	на 10	соответствующее	    +
    937				     количество раз
1   938	0310			     .rank_mul:
1   939	0310  4E			 dec si
1   940	0311  83 FE 00			 cmp si, 0
1   941	0314  74 04			 je .conv_cont
1   942	0316  F7 E3			 mul BX		 ; умножаем предыдущую сумму на 10
1   943	0318  EB F6			 jmp .rank_mul
1   944
1   945	031A			     .conv_cont:
1   946	031A  5E			 pop si
1   947	031B  03 C8			 add CX, AX	 ; добавляем текущее значение к сумме
1   948	031D			     .zero_rank:
1   949	031D  47			 inc di		 ; переходим к следующему символу
1   950	031E  4E			 dec si
1   951	031F  EB E1			 jmp .convert_loop
1   952
1   953
1   954	0321			     .conv_end:
1   955	0321  5F			 pop di
1   956	0322  5E			 pop si
1   957	0323  5B			 pop bx
1   958	0324  58			 pop ax
1   959
1   960	0325  C3			 ret
1   961	0326			     to_hex_decimal endp
1   962
1   963	0326			     sum_mul_array proc
1   964					 ; Процедура для получения	суммы элементов массива+
    965				     mul_array
1   966					 ; подразумевается что mul_array заполнен			    +
    967				     двоично-десятичными десяти-разрядными модулями	    +
    968				     попарных произведений
1   969					 ; результат в tmp_res
Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 18
main.asm



1   970
1   971	0326  57			 push di ; используется как указатель на адрес		    +
    972				     слагаемого (tmp_res)
1   973	0327  56			 push si ; используется как указатель на mul_array
1   974	0328  51			 push cx ; счетчик обработанных элементов
1   975
1   976	0329  33 F6			 xor si, si
1   977	032B  33 C9			 xor cx, cx
1   978
1   979	032D  E8 FE87			 call clear_tmp_res
1   980
1   981					 ; инициализация указателей
1   982	0330  BF 011Ar			 mov di, offset	tmp_res
1   983	0333  BE 0195r			 mov si, offset	mul_array
1   984
1   985	0336  8A 0C			 mov cl, [si]	      ;	инициализация счетчика элементов	    +
    986				     массива
1   987	0338  46			 inc si		      ;	двигаем указатель на первое		    +
    988				     произведение
1   989
1   990	0339				 .sum_mul_cycle:
1   991	0339  E8 FF45			     call sum_values  ;	результат сложения				    +
    992				     двоично-десятичных чисел из si и di в tmp_res
1   993	033C  83 C6 0A			     add si, 10
1   994	033F  E2 F8			     loop .sum_mul_cycle
1   995
1   996	0341  59			 pop cx
1   997	0342  5E			 pop si
1   998	0343  5F			 pop di
1   999	0344  C3			 ret
1  1000	0345			     sum_mul_array endp
1  1001
1  1002	0345			     result_to_string proc
1  1003					 ; Процедура для наполнения буфера res_str символами   +
   1004				     численного результата (модуля)
1  1005					 ; подразумевается что буфер tmp_res содержит		    +
   1006				     результат	вычисления суммы	попарных (разделенных    +
   1007				     по знаку)
1  1008					 ; произведений введенных чисел
1  1009	0345  56			 push si ; используется как указатель на tmp_res
1  1010	0346  57			 push di ; используется как указатель на res_str
1  1011	0347  50			 push ax ; используется как промежуточная переменная  +
   1012				     для обработки символа
1  1013	0348  51			 push cx ; счетчик обработанных символов (байт)
1  1014
1  1015					 ; очистка регистров
1  1016	0349  33 F6			 xor si, si
1  1017	034B  33 FF			 xor di, di
1  1018	034D  33 C0			 xor ax, ax
1  1019	034F  33 C9			 xor cx, cx
1  1020
1  1021	0351  BE 011Ar			 mov si, offset	tmp_res
1  1022	0354  BF 0138r			 mov di, offset	res_str	+ 1    ; пропускаем первый байт - символ  +
   1023				     '-'
1  1024	0357  B9 000A			 mov cx, 10
1  1025
1  1026	035A				 .del_zeros:
Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 19
main.asm



1  1027	035A  83 F9 01			     cmp cx, 1
1  1028	035D  74 0A			     je	.true_num_cycle
1  1029	035F  8A 04			     mov al, [si]
1  1030	0361  3C 00			     cmp al, 0
1  1031	0363  75 04			     jne .true_num_cycle
1  1032	0365  49			     dec cx
1  1033	0366  46			     inc si
1  1034	0367  EB F1			     jmp .del_zeros
1  1035	0369				 .true_num_cycle:
1  1036	0369  8A 04			     mov al, [si]
1  1037	036B  04 30			     add al, 30h
1  1038	036D  88 05			     mov [di], al
1  1039	036F  47			     inc di
1  1040	0370  46			     inc si
1  1041	0371  E2 F6			     loop .true_num_cycle
1  1042					 ; проверка на 0 (добавляем минус если результат не  +
   1043				     равен	нулю)
1  1044	0373  BF 0137r			 mov di, offset	res_str
1  1045	0376  8B 1D			 mov bx, [di]
1  1046	0378  80 FF 30			 cmp bh, 30h
1  1047	037B  75 0A			 jne .add_neg
1  1048	037D  C6 05 30			 mov [di], byte	ptr 30h
1  1049	0380  47			 inc di
1  1050	0381  C6 05 24			 mov [di], byte	ptr '$'
1  1051	0384  EB 04 90			 jmp .end_res_to_str
1  1052	0387			     .add_neg:
1  1053	0387  C6 05 2D			 mov [di], byte	ptr '-'
1  1054	038A			     .end_res_to_str:
1  1055	038A  59			 pop cx
1  1056	038B  58			 pop ax
1  1057	038C  5F			 pop di
1  1058	038D  5E			 pop si
1  1059	038E  C3			 ret
1  1060
1  1061	038F			     result_to_string endp
1  1062
   1063
   1064	0000			     .stack
   1065	038F  0100*(??)			 db 100h dup(?)
   1066
   1067				     end start
Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 20
Symbol Table




Symbol Name			  Type	 Value

.ADD_CYCLE			  Near	 _TEXT:02D7
.ADD_NEG			  Near	 _TEXT:0387
.ADD_VALUE_EXIT			  Near	 _TEXT:01B3
.CLEAR_CYCLE			  Near	 _TEXT:01BF
.CONTINUE			  Near	 _TEXT:0167
.CONVERT_LOOP			  Near	 _TEXT:0302
.CONV_CONT			  Near	 _TEXT:031A
.CONV_END			  Near	 _TEXT:0321
.COPY_LOOP			  Near	 _TEXT:0214
.CORRECT_INPUT			  Near	 _TEXT:0089
.CORR_END			  Near	 _TEXT:0177
.COUNTER_INITIALIZED		  Near	 _TEXT:01F1
.CYCLE				  Near	 _TEXT:026E
.DEL_ZEROS			  Near	 _TEXT:035A
.END_PROGRAM			  Near	 _TEXT:00C6
.END_RANGE			  Near	 _TEXT:0159
.END_RES_TO_STR			  Near	 _TEXT:038A
.ERROR				  Near	 _TEXT:0172
.INPUT				  Near	 _TEXT:0020
.IS_NUM_CYCLE			  Near	 _TEXT:0108
.MAX_DIGITS_CHECK		  Near	 _TEXT:011C
.MUL_EXIT			  Near	 _TEXT:02E7
.NEGATIVE			  Near	 _TEXT:0165
.NEG_CYCLE			  Near	 _TEXT:0198
.NEG_START			  Near	 _TEXT:0127
.NOT_EMPTY			  Near	 _TEXT:0057
.NOT_EXIT			  Near	 _TEXT:006F
.NO_MUL				  Near	 _TEXT:02E2
.NO_MUL_FLAG			  Near	 _TEXT:0211
.NULL_FILLING			  Near	 _TEXT:0261
.POSITIVE			  Near	 _TEXT:025D
.POS_BIGGER			  Near	 _TEXT:01EF
.POS_CYCLE			  Near	 _TEXT:01AB
.POS_NUM			  Near	 _TEXT:01A3
.POS_START			  Near	 _TEXT:0137
.PROD_LOOP			  Near	 _TEXT:01FD
.RANGE_CYCLE			  Near	 _TEXT:0144
.RANK_MUL			  Near	 _TEXT:0310
.RETRY				  Near	 _TEXT:002E
.SUM_CYCLE			  Near	 _TEXT:0294
.SUM_MUL_CYCLE			  Near	 _TEXT:0339
.TRUE_NUM_CYCLE			  Near	 _TEXT:0369
.ZERO_RANK			  Near	 _TEXT:031D
??DATE				  Text	 "12/22/23"
??FILENAME			  Text	 "main	  "
??TIME				  Text	 "20:56:00"
??VERSION			  Number 0205
@CODE				  Text	 _TEXT
@CODESIZE			  Text	 0
@CPU				  Text	 0101H
@CURSEG				  Text	 _TEXT
@DATA				  Text	 DGROUP
@DATASIZE			  Text	 0
@FILENAME			  Text	 MAIN
Turbo Assembler	 Version 2.51	     12/22/23 20:56:00	    Page 21
Symbol Table



@MODEL				  Text	 2
@WORDSIZE			  Text	 2
ADD_VALUE			  Near	 _TEXT:017E
CARRET				  Byte	 DGROUP:0118
CLEAR_TMP_RES			  Near	 _TEXT:01B7
EMPTY_MESS			  Byte	 DGROUP:009C
ERR_FLAG			  Byte	 DGROUP:01BF
ERR_MESS			  Byte	 DGROUP:010A
EXIT_MESS			  Byte	 DGROUP:00EA
FILL_MUL_ARRAY			  Near	 _TEXT:01C8
INPUT_MESS			  Byte	 DGROUP:004A
IN_STR				  Byte	 DGROUP:012F
IS_CORRECT			  Near	 _TEXT:00CD
MAX_NEG_LEN			  Number 0006
MAX_NUM				  Byte	 DGROUP:0000
MAX_POS_LEN			  Number 0005
MUL_ARRAY			  Byte	 DGROUP:0195
MUL_VALUES			  Near	 _TEXT:02B5
NEGATIVE			  Number 002D
NEG_ARRAY			  Byte	 DGROUP:016C
NEG_FLAG			  Byte	 DGROUP:01BE
NEG_MAX_LAST			  Number 0038
NUMS_SIZE			  Number 0008
OUTPUT_MESS			  Byte	 DGROUP:0059
POS_ARRAY			  Byte	 DGROUP:0143
POS_MAX_LAST			  Number 0037
RESULT_TO_STRING		  Near	 _TEXT:0345
RES_STR				  Byte	 DGROUP:0137
START				  Near	 _TEXT:0000
START_MESS			  Byte	 DGROUP:0004
SUM_MUL_ARRAY			  Near	 _TEXT:0326
SUM_VALUES			  Near	 _TEXT:0281
TMP_NUM				  Byte	 DGROUP:0124
TMP_RES				  Byte	 DGROUP:011A
TO_BIN_DECIMAL			  Near	 _TEXT:022D
TO_HEX_DECIMAL			  Near	 _TEXT:02ED

Macro Name

EXIT
INPUT
PRINT

Groups & Segments		  Bit Size Align  Combine Class

DGROUP				  Group
  STACK				  16  0400 Para	  Stack	  STACK
  _DATA				  16  01C0 Word	  Public  DATA
_TEXT				  16  048F Word	  Public  CODE
