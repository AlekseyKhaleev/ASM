Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 1
main.asm



      1				     .8086
      2	0000			     .MODEL SMALL
      3
      4				     include macros.asm
1     5
1     6
1     7				     print macro text ;вывод сообщений на экран
1     8					     push ax
1     9					     push dx
1    10					     mov dx,offset text
1    11					     mov ah,9
1    12					     int 21h
1    13					     pop dx
1    14					     pop ax
1    15				     endm
1    16
1    17				     input macro text ;ввод	строки символов
1    18					 ; сохранение	состояния в стеке
1    19					     push ax
1    20					     push dx
1    21					     push bx
1    22					 ; запись	ввода в буфер text
1    23				     .retry:
1    24					     mov dx,offset text
1    25					     mov ah,0ah
1    26					     int 21h
1    27
1    28					     inc dx
1    29					     mov bx, dx
1    30					     mov bl, [bx] ; количество введенных символов
1    31					     cmp bl, 0h	  ; проверка на пустую строку
1    32					     jne .not_empty
1    33					     print empty_mess
1    34					 print input_mess
1    35					 jmp .retry
1    36
1    37				     .not_empty:
1    38					 mov bx, dx
1    39					     inc bx
1    40					     mov bl, [bx] ; первый введенный символ
1    41					     cmp bl, 18h  ; проверка на ввод ctrl+x (= выход)
1    42					     jne .not_exit
1    43					     print exit_mess
1    44					     jmp .end_program
1    45				     .not_exit:
1    46					     ; возврат состояния из стека
1    47					 pop bx
1    48					     pop dx
1    49					     pop ax
1    50				     endm
1    51
1    52				     exit macro
1    53					 ; завершение	программы
1    54					 mov ah, 4ch
1    55					 mov al, 0
1    56					 int 21h
1    57					 ret
Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 2
main.asm



1    58				     endm
     59				     include data.asm
1    60	0000			     .data
1    61	      =	002D			 NEGATIVE	  equ 2Dh ; шестнадцатеричный ascii код знака '-'
1    62	      =	0008			 NUMS_SIZE	  equ 8h  ; количество вводимых чисел
1    63	      =	0005			 MAX_POS_LEN	  equ 5h  ; максимальная длина	положительного+
     64				     числа
1    65	      =	0006			 MAX_NEG_LEN	  equ 6h  ; максимальная длина	отрицательного+
     66				     числа	с учетом	знака
1    67	      =	0037			 POS_MAX_LAST	  equ 37h ; младший разряд	верхнего		    +
     68				     ограничения (ascii, hex)
1    69	      =	0038			 NEG_MAX_LAST	  equ 38h ; младший разряд	нижнего			    +
     70				     ограничения (ascii, hex)
1    71	0000  33 32 37 36		 MAX_NUM    db '3276' ;	старшие разряды модуля			    +
     72				     максимального	числа без последнего разряда
1    73
1    74					 ; текстовые переменные для вывода
1    75	0004  49 6E 70 75 74 3A	20+	 start_mess db 'Input: 8 numbers in [-32768, 32767]', 10, 'Press <Enter> after each number',+
     76	      38 20 6E 75 6D 62	65+  10,13,'$'
     77	      72 73 20 69 6E 20	5B+
     78	      2D 33 32 37 36 38	2C+
     79	      20 33 32 37 36 37	5D+
     80	      0A 50 72 65 73 73	20+
     81	      3C 45 6E 74 65 72	3E+
     82	      20 61 66 74 65 72	20+
     83	      65 61 63 68 20 6E	75+
     84	      6D 62 65 72 0A 0D	24
1    85	004A  45 6E 74 65 72 20	6E+	 input_mess db 'Enter number: $'
     86	      75 6D 62 65 72 3A	20+
     87	      24
1    88	0059  49 6E 70 75 74 20	45+	 empty_mess db 'Input Error: empty string. Try again or	use ctrl+x and press enter for	    +
     89	      72 72 6F 72 3A 20	65+  exit.', 10, '$'
     90	      6D 70 74 79 20 73	74+
     91	      72 69 6E 67 2E 20	54+
     92	      72 79 20 61 67 61	69+
     93	      6E 20 6F 72 20 75	73+
     94	      65 20 63 74 72 6C	2B+
     95	      78 20 61 6E 64 20	70+
     96	      72 65 73 73 20 65	6E+
     97	      74 65 72 20 66 6F	72+
     98	      20 65 78 69 74 2E	0A+
     99	      24
1   100	00A7  50 72 6F 67 72 61	6D+	 exit_mess  db 'Program	was aborted by keybord', 10, '$'
    101	      20 77 61 73 20 61	62+
    102	      6F 72 74 65 64 20	62+
    103	      79 20 6B 65 79 62	6F+
    104	      72 64 0A 24
1   105	00C7  49 6E 70 75 74 20	65+	 err_mess   db 'Input error!', 10, '$'
    106	      72 72 6F 72 21 0A	24
1   107	00D5  0A 24			 carret	    db 10, '$'
1   108
1   109					 ; буферные переменные
1   110	00D7  0A*(00)			 tmp_res    db 10 dup(0)	  ; переменная для	промежуточного+
    111				     сохранения результата сложения/умножения
1   112									  ; двух десяти-разрядных		    +
    113				     беззнаковых двоично-десятичных	чисел
1   114	00E1  00 0A*(??)		 tmp_num    db 0, 10 dup(?)	  ; переменная для	промежуточного+
Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 3
main.asm



    115				     сохранения двоично-десятичного	представления числа
1   116									  ; первый байт tmp_num - знаковый,
1   117									  ; все операции над 10 разрядными  +
    118				     двоично-десятичными числами (с незначащими нулями)
1   119	00EC  07 ?? 06*(??)		 in_str	    db 7, ?, 6 dup (?)	  ; буфер ввода 1 байт размер	    +
    120				     буфера, второй	-количество введенных символов
1   121	00F4  2D 0B*(24)		 res_str    db '-', 11 dup ('$')  ; буфер для преобразования	    +
    122				     результата в строку
1   123									  ; (произведения разных знаков, а +
    124				     также	их последующие суммы всегда отрицательны)
1   125
1   126					 ; массивы, первый	байт в массиве для учета		    +
    127				     количества записанных чисел
1   128	0100  00 04*(0A*(??))		 pos_array  db 0, 4 dup(10 dup(?)) ; массив для пяти модулей	    +
    129				     положительных	двоично-десятичных чисел размером	5   +
    130				     байт
1   131	0129  00 04*(0A*(??))		 neg_array  db 0, 4 dup(10 dup(?)) ; массив для пяти модулей	    +
    132				     отрицательных	двоично-десятичных чисел размером	5   +
    133				     байт
1   134	0152  00 04*(0A*(??))		 mul_array  db 0, 4 dup(10 dup(?)) ; массив модулей поэлементных   +
    135				     произведений массивов
1   136
1   137					 ; флаги
1   138	017B  00			 neg_flag   db 0     ; флаг	наличия знака '-' для is_correct	proc
1   139	017C  00			 err_flag   db 0     ; флаг	ошибки во вводе для is_correct		    +
    140				     proc/цикла ввода
1   141
1   142
    143
    144	017D			     .code
    145	0000			     start:
    146					; инициализация памяти
    147	0000  B8 0000s			 mov ax, @data
    148	0003  8E D8			 mov ds, ax
    149
    150					 ;вызов функции 0 -	 установка 3 текстового		    +
    151				     видеорежима, очистка экрана
    152	0005  B8 0003			 mov ax, 0003  ; ah=0 (номер функции), al=3	(номер режима)
    153	0008  CD 10			 int 10h
    154
    155					 print start_mess  ; вывод	стартового сообщения
1   156	000A  50			     push ax
1   157	000B  52			     push dx
1   158	000C  BA 0004r			     mov dx,offset start_mess
1   159	000F  B4 09			     mov ah,9
1   160	0011  CD 21			     int 21h
1   161	0013  5A			     pop dx
1   162	0014  58			     pop ax
    163	0015  33 C9			 xor cx, cx
    164	0017  B9 0008			 mov cx, NUMS_SIZE ; в	cx количество	чисел для ввода		    +
    165				     пользователем
    166
    167					 ; инициализация указателей на	первые элементы	    +
    168				     массивов без учета	размерного байта	(используется в+
    169				     add_value proc)
    170	001A  BE 0101r			 mov si, offset	pos_array + 1
    171	001D  BF 012Ar			 mov di, offset	neg_array + 1
Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 4
main.asm



    172
    173					 ; цикл ввода/проверки/распределения по	массивам
    174	0020				 .input:
    175					     print input_mess  ;вывод сообщения о вводе строки
1   176	0020  50			     push ax
1   177	0021  52			     push dx
1   178	0022  BA 004Ar			     mov dx,offset input_mess
1   179	0025  B4 09			     mov ah,9
1   180	0027  CD 21			     int 21h
1   181	0029  5A			     pop dx
1   182	002A  58			     pop ax
    183					     input in_str      ;ввод числа в виде	строки
1   184	002B  50			     push ax
1   185	002C  52			     push dx
1   186	002D  53			     push bx
1   187	002E			     .retry:
1   188	002E  BA 00ECr			     mov dx,offset in_str
1   189	0031  B4 0A			     mov ah,0ah
1   190	0033  CD 21			     int 21h
1   191	0035  42			     inc dx
1   192	0036  8B DA			     mov bx, dx
1   193	0038  8A 1F			     mov bl, [bx] ; количество введенных символов
1   194	003A  80 FB 00			     cmp bl, 0h	  ; проверка на пустую строку
1   195	003D  75 18			     jne .not_empty
1   196					     print empty_mess
2   197	003F  50			     push ax
2   198	0040  52			     push dx
2   199	0041  BA 0059r			     mov dx,offset empty_mess
2   200	0044  B4 09			     mov ah,9
2   201	0046  CD 21			     int 21h
2   202	0048  5A			     pop dx
2   203	0049  58			     pop ax
1   204					 print input_mess
2   205	004A  50			     push ax
2   206	004B  52			     push dx
2   207	004C  BA 004Ar			     mov dx,offset input_mess
2   208	004F  B4 09			     mov ah,9
2   209	0051  CD 21			     int 21h
2   210	0053  5A			     pop dx
2   211	0054  58			     pop ax
1   212	0055  EB D7			 jmp .retry
1   213	0057			     .not_empty:
1   214	0057  8B DA			 mov bx, dx
1   215	0059  43			     inc bx
1   216	005A  8A 1F			     mov bl, [bx] ; первый введенный символ
1   217	005C  80 FB 18			     cmp bl, 18h  ; проверка на ввод ctrl+x (= выход)
1   218	005F  75 0E			     jne .not_exit
1   219					     print exit_mess
2   220	0061  50			     push ax
2   221	0062  52			     push dx
2   222	0063  BA 00A7r			     mov dx,offset exit_mess
2   223	0066  B4 09			     mov ah,9
2   224	0068  CD 21			     int 21h
2   225	006A  5A			     pop dx
2   226	006B  58			     pop ax
1   227	006C  EB 4D 90			     jmp .end_program
1   228	006F			     .not_exit:
Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 5
main.asm



1   229	006F  5B			 pop bx
1   230	0070  5A			     pop dx
1   231	0071  58			     pop ax
    232
    233					     ; проверки, заполнение массивов
    234	0072  E8 004D			     call is_correct   ; проверка на корректность	символов    +
    235				     числа, установка err_flag
    236	0075  80 3E 017Cr 00		     cmp err_flag, 0
    237	007A  74 0D			     je	.correct_input
    238
    239					     ; если	была ошибка вывод сообщения и			    +
    240				     циклический ввод
    241					     print err_mess
1   242	007C  50			     push ax
1   243	007D  52			     push dx
1   244	007E  BA 00C7r			     mov dx,offset err_mess
1   245	0081  B4 09			     mov ah,9
1   246	0083  CD 21			     int 21h
1   247	0085  5A			     pop dx
1   248	0086  58			     pop ax
    249	0087  EB 97			     jmp .input
    250
    251	0089				 .correct_input:
    252	0089  E8 0196			     call to_bin_decimal  ; преобразование in_str	к			    +
    253				     двоично-десятичному виду в tmp_num (с незначащими	    +
    254				     нулями и байтом знака)
    255	008C  E8 00E4			     call add_value	  ; копирование модуля	из tmp_num в		    +
    256				     соответствующий массив
    257					     print carret	  ; печать переноса строки
1   258	008F  50			     push ax
1   259	0090  52			     push dx
1   260	0091  BA 00D5r			     mov dx,offset carret
1   261	0094  B4 09			     mov ah,9
1   262	0096  CD 21			     int 21h
1   263	0098  5A			     pop dx
1   264	0099  58			     pop ax
    265	009A  E2 84			     loop .input	  ; цикл ввода
    266
    267					 ; здесь массивы pos_array и neg_array заполнены модулями	    +
    268				     соответствующих по знаку введенных чисел
    269	009C  E8 011E			 call fill_mul_array
    270	009F  E8 0279			 call sum_mul_array
    271	00A2  E8 0295			 call result_to_string
    272					 print res_str
1   273	00A5  50			     push ax
1   274	00A6  52			     push dx
1   275	00A7  BA 00F4r			     mov dx,offset res_str
1   276	00AA  B4 09			     mov ah,9
1   277	00AC  CD 21			     int 21h
1   278	00AE  5A			     pop dx
1   279	00AF  58			     pop ax
    280					 print carret
1   281	00B0  50			     push ax
1   282	00B1  52			     push dx
1   283	00B2  BA 00D5r			     mov dx,offset carret
1   284	00B5  B4 09			     mov ah,9
1   285	00B7  CD 21			     int 21h
Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 6
main.asm



1   286	00B9  5A			     pop dx
1   287	00BA  58			     pop ax
    288
    289	00BB			     .end_program:
    290					 exit ;	завершение программы
1   291	00BB  B4 4C			 mov ah, 4ch
1   292	00BD  B0 00			 mov al, 0
1   293	00BF  CD 21			 int 21h
1   294	00C1  C3			 ret
    295
    296				     include func.asm
1   297
1   298	00C2			     is_correct	proc
1   299					 ; Процедура для проверки корректности введенного +
    300				     числа
1   301					 ; число должно быть записано в	буфер in_str
1   302					 ; корректный	диапазон - [-32768, 32767]
1   303
1   304					 ; сохраняем состояние регистров
1   305	00C2  50			 push ax ; используется для хранения текущего символа
1   306	00C3  53			 push bx ; используется для хранения индекса в		    +
    307				     диапазоне	(проход по константе MAX_NUM)
1   308	00C4  51			 push cx ; используется для хранения количества	    +
    309				     обработанных символов числа
1   310	00C5  52			 push dx ; используется для хранения последнего	    +
    311				     символа диапазона в зависимости от знака
1   312	00C6  56			 push si ; используется для хранения индекса в буфере  +
    313				     ввода
1   314	00C7  57			 push di ; используется для хранения количества	    +
    315				     введенных	символов во входном буфере
1   316
1   317					 ; очистка используемых регистров
1   318	00C8  33 C0			 xor ax, ax
1   319	00CA  33 DB			 xor bx, bx
1   320	00CC  33 C9			 xor cx, cx
1   321	00CE  33 D2			 xor dx, dx
1   322	00D0  33 F6			 xor si, si
1   323	00D2  33 FF			 xor di, di
1   324
1   325					 ; инициализация di количеством	символов во входном+
    326				     буфере
1   327	00D4  BF 00ECr			 mov di, offset	in_str ; помещаем в di	адрес буфера	ввода
1   328	00D7  47			 inc di		 ; перемещаем	на количество символов	    +
    329				     записанных в буфер
1   330	00D8  8B 3D			 mov di, [di]	 ; загружаем 2	первых байта	из in_str в di
1   331	00DA  81 E7 00FF		 and di, 00FFh	 ; очищаем старший байт
1   332
1   333					 ; начальная инициализация
1   334	00DE  C6 06 017Br 00		 mov neg_flag, 0 ; очистка флага для хранения знака	числа
1   335	00E3  C6 06 017Cr 00		 mov err_flag, 0 ; очистка флага для определения ошибки	    +
    336				     ввода
1   337	00E8  BE 0002			 mov si, 2	 ; Инициализация индекса числа	(пропуск	    +
    338				     служебных	байтов буфера)
1   339	00EB  BB 0000			 mov bx, 0	 ; Инициализация индекса для			    +
    340				     максимального	диапазона
1   341
1   342	00EE  8A 84 00ECr		 mov al, in_str[si]; Загрузка текущего элемента	буфера в	AL
Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 7
main.asm



1   343	00F2  3C 2D			 cmp al, NEGATIVE  ; Является ли первый	символ знаком '-'
1   344	00F4  75 07			 jne .is_num_cycle
1   345	00F6  C6 06 017Br 01		 mov neg_flag, 1   ; установка	флага отрицательного	числа
1   346	00FB  46			 inc si		   ; перемещаем указатель в	буфере на	    +
    347				     следующий	байт (символ)
1   348	00FC  41			 inc cx		   ; увеличиваем счетчик обработанных	    +
    349				     чисел
1   350
1   351					 ; проверка: является ли числом	каждый введенный	    +
    352				     символ символ (исключая первый минус)
1   353	00FD				 .is_num_cycle:
1   354	00FD  3B CF			     cmp cx, di		  ; если все символы обработаны
1   355	00FF  74 10			     je	.max_digits_check ; выход из цикла
1   356	0101  8A 84 00ECr		     mov al, in_str[si]	  ; в al очередной ascii код ввода
1   357	0105  3C 30			     cmp al, 30h	  ; 30h	- ascii	код для числа 0, если меньше - +
    358				     ошибка ввода
1   359	0107  7C 5E			     jl	.error
1   360	0109  3C 39			     cmp al, 39h	  ; 39h	- ascii	код для числа 9, если меньше - +
    361				     ошибка ввода
1   362	010B  7F 5A			     jg	.error
1   363	010D  41			     inc cx		  ; увеличиваем счетчик
1   364	010E  46			     inc si		  ; двигаем указатель
1   365	010F  EB EC			     jmp .is_num_cycle	  ; повторяем цикл
1   366
1   367
1   368	0111				 .max_digits_check:
1   369					     ; очистка регистров
1   370	0111  33 C9			     xor cx, cx
1   371	0113  33 F6			     xor si, si
1   372
1   373	0115  80 3E 017Br 00		     cmp neg_flag, 0	 ; проверка знака числа
1   374	011A  74 10			     je	.pos_start
1   375
1   376					     ; для отрицательных:
1   377	011C				     .neg_start:
1   378	011C  83 FF 06				 cmp di, MAX_NEG_LEN ; сравнение количества введенных   +
    379				     символов и максимального количества разрядов
1   380	011F  7C 4B				 jl .corr_end	     ; если	меньше, завершаем без	ошибки
1   381	0121  7F 44				 jg .error	     ; если	больше завершаем	с ошибкой
1   382						 ; если равно,	инициализация и переход к		    +
    383				     поразрядной проверке
1   384	0123  BE 0003				 mov si, 3
1   385	0126  B9 0002				 mov cx, 2	      ;	значение больше на 1 чем		    +
    386				     действительное чтобы выйти	из range_cycle раньше на 1	    +
    387				     символ
1   388	0129  EB 0E 90				 jmp .range_cycle
1   389
1   390					     ; для положительных
1   391	012C				     .pos_start:
1   392	012C  83 FF 05				 cmp di, MAX_POS_LEN ; сравнение количества введенных   +
    393				     символов и максимального количества разрядов
1   394	012F  7C 3B				 jl .corr_end	     ; если	меньше, завершаем без	ошибки
1   395	0131  7F 34				 jg .error
1   396						 ; если равно,	инициализация и переход к		    +
    397				     поразрядной проверке
1   398	0133  BE 0002				 mov si, 2
1   399	0136  B9 0001				 mov cx, 1
Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 8
main.asm



1   400
1   401					     ; поразрядная проверка диапазона если		    +
    402				     количество символов модуля	равно 5
1   403	0139				     .range_cycle:
1   404	0139  8A 84 00ECr			 mov al, in_str[si] ; Загрузка текущего	элемента	    +
    405				     буфера в AL
1   406	013D  3A 87 0000r			 cmp al, MAX_NUM[bx]
1   407	0141  7F 24				 jg .error
1   408	0143  7C 27				 jl .corr_end
1   409						 ; если символ равен ограничению:
1   410	0145  46				 inc si		   ; Увеличение индекса числа
1   411	0146  41				 inc cx		   ; Увеличение счетчика обработанных +
    412				     цифр
1   413	0147  43				 inc bx		   ; Увеличение индекса в строке	    +
    414				     содержащей максимальные цифры диапазона
1   415	0148  3B CF				 cmp cx, di	   ; Проверка, достигнут ли конец	    +
    416				     буфера
1   417	014A  74 02				 je .end_range	   ; Если да, прерывание цикла
1   418	014C  EB EB				 jmp .range_cycle  ; Переход на следующую итерацию	    +
    419				     цикла
1   420
1   421					     ; проверка	последнего символа если число		    +
    422				     значащих цифр равно максимальному
1   423	014E				     .end_range:
1   424	014E  80 3E 017Br 01			 cmp neg_flag, 1
1   425	0153  74 05				 je .negative
1   426	0155  B2 37				 mov dl, POS_MAX_LAST
1   427	0157  EB 03 90				 jmp .continue
1   428	015A				     .negative:
1   429	015A  B2 38				 mov dl, NEG_MAX_LAST
1   430	015C				     .continue:
1   431	015C  8A 84 00ECr			 mov al, in_str[si] ; загружаем последний символ
1   432	0160  3A C2				 cmp al, dl
1   433	0162  7F 03				 jg .error	    ; если есть	выход за	границу		    +
    434				     диапазона	переход к ошибке
1   435	0164  EB 06 90				 jmp .corr_end
1   436
1   437					 ; завершение	с ошибкой
1   438	0167				 .error:
1   439	0167  C6 06 017Cr 01		     mov err_flag, 1	  ; установка флага ошибки
1   440
1   441					 ; завершение	без ошибки
1   442	016C				 .corr_end:
1   443					     ; восстанавливаем состояние из стека
1   444	016C  5F			     pop di
1   445	016D  5E			     pop si
1   446	016E  5A			     pop dx
1   447	016F  59			     pop cx
1   448	0170  5B			     pop bx
1   449	0171  58			     pop ax
1   450	0172  C3			     ret
1   451
1   452	0173			     is_correct	endp
1   453
1   454	0173			     add_value proc
1   455					 ; Процедура для копирования числа из временной	    +
    456				     переменной в соответствующий массив
Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 9
main.asm



1   457					 ; число представлено в двоично-десятичном виде с   +
    458				     незначащими нулями (размер на выходе 5 байт)
1   459					 ; в массивы записываем только модули, увеличиваем +
    460				     количество записанных чисел
1   461					 ; в si адрес очередного элемента в массиве		    +
    462				     положительных	чисел
1   463					 ; в di адрес очередного элемента в массиве		    +
    464				     отрицательных	чисел
1   465					 ; в tmp_num значение очередного введенного и		    +
    466				     преобразованного числа которое	нужно скопировать
1   467
1   468	0173  50			 push ax ; используется для увеличения	счетчика	    +
    469				     записанных чисел в	массиве и копирования очередной +
    470				     цифры(байта) числа
1   471	0174  53			 push bx ; используется как указатель на tmp_num
1   472	0175  51			 push cx ; счетчик элементов числа	для цикла,		    +
    473				     инициализируется числом 5 (количеством байт в	    +
    474				     каждом числе)
1   475
1   476					 ; инициализация счетчика
1   477	0176  33 C9			 xor cx, cx
1   478	0178  B9 000A			 mov cx, 10
1   479
1   480	017B  BB 00E1r			 mov bx, offset	tmp_num	; инициализируем указатель на		    +
    481				     временную	переменную
1   482	017E  8A 07			 mov al, [bx]		; в al	байт знака
1   483	0180  43			 inc bx			; перемещаем указатель на первый	    +
    484				     символ
1   485	0181  3C 00			 cmp al, 0		; проверка на						    +
    486				     отрицательное/положительное число
1   487	0183  74 13			 je .pos_num
1   488
1   489					 ; увеличиваем счетчик записанных чисел в массиве  +
    490				     отрицательных	чисел
1   491	0185  A0 0129r			 mov al, neg_array
1   492	0188  FE C0			 inc al
1   493	018A  A2 0129r			 mov neg_array,	al
1   494
1   495					 ; по-байтовая запись модуля очередного	числа в	    +
    496				     массив отрицательных чисел
1   497	018D				 .neg_cycle:
1   498	018D  8A 07			     mov al, [bx]
1   499	018F  88 05			     mov [di], al
1   500	0191  43			     inc bx
1   501	0192  47			     inc di
1   502	0193  E2 F8			     loop .neg_cycle
1   503
1   504	0195  EB 11 90			 jmp .add_value_exit
1   505
1   506	0198				 .pos_num:
1   507					     ; увеличиваем счетчик записанных чисел в		    +
    508				     массиве положительных (неотрицательных)	чисел
1   509	0198  A0 0100r			     mov al, pos_array
1   510	019B  FE C0			     inc al
1   511	019D  A2 0100r			     mov pos_array, al
1   512
1   513					 ; по-байтовая запись модуля очередного	числа в	    +
Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 10
main.asm



    514				     массив положительных (неотрицательных) чисел
1   515	01A0				 .pos_cycle:
1   516	01A0  8A 07			     mov al, [bx]
1   517	01A2  88 04			     mov [si], al
1   518	01A4  43			     inc bx
1   519	01A5  46			     inc si
1   520	01A6  E2 F8			     loop .pos_cycle
1   521
1   522					 ; возврат состояния
1   523	01A8				 .add_value_exit:
1   524	01A8  59			     pop cx
1   525	01A9  5B			     pop bx
1   526	01AA  58			     pop ax
1   527	01AB  C3			     ret
1   528
1   529	01AC			     add_value endp
1   530
1   531	01AC			     clear_tmp_res proc
1   532	01AC  56			 push si
1   533	01AD  51			 push cx
1   534	01AE  B9 000A			 mov cx, 10
1   535	01B1  BE 00D7r			 mov si, offset	tmp_res
1   536	01B4				 .clear_cycle:
1   537	01B4  C6 04 00			     mov byte ptr [si],	0
1   538	01B7  46			     inc si
1   539	01B8  E2 FA			     loop .clear_cycle
1   540	01BA  59			 pop cx
1   541	01BB  5E			 pop si
1   542
1   543	01BC  C3			 ret
1   544	01BD			     clear_tmp_res endp
1   545
1   546	01BD			     fill_mul_array proc
1   547					 ; процедура для заполнения массива mul_array		    +
    548				     попарными	произведениями модулей положительных и   +
    549				     отрицательных	чисел
1   550					 ; ожидается что произведен ввод с клавиатуры	    +
    551				     чисел, числа приведены к двоично-десятичному	виду
1   552					 ; массивы pos_array и neg_array заполнены модулями		    +
    553				     положительных	и отрицательных чисел соответственно
1   554
1   555					 ; сохраняем состояние
1   556	01BD  50			 push ax
1   557	01BE  53			 push bx
1   558	01BF  51			 push cx
1   559	01C0  52			 push dx
1   560	01C1  56			 push si
1   561	01C2  57			 push di
1   562
1   563					 ; чистим	регистры
1   564	01C3  33 C0			 xor ax, ax
1   565	01C5  33 DB			 xor bx, bx
1   566	01C7  33 C9			 xor cx, cx
1   567	01C9  33 D2			 xor dx, dx
1   568	01CB  33 F6			 xor si, si
1   569	01CD  33 FF			 xor di, di
1   570
Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 11
main.asm



1   571					 ; инициализация счетчика размером	меньшего из	    +
    572				     массивов введенных чисел
1   573	01CF  BB 0100r			 mov bx, offset	pos_array
1   574	01D2  8A 1F			 mov bl, [bx]
1   575	01D4  8A C3			 mov al, bl
1   576	01D6  BB 0129r			 mov bx, offset	neg_array
1   577	01D9  8A 1F			 mov bl, [bx]
1   578	01DB  3A C3			 cmp al, bl
1   579	01DD  7F 05			 jg .pos_bigger
1   580	01DF  8A CB			 mov cl, bl
1   581	01E1  EB 03 90			 jmp .counter_initialized
1   582	01E4			     .pos_bigger:
1   583	01E4  8A C8			 mov cl, al
1   584
1   585	01E6			     .counter_initialized:
1   586					 ; инициализация указателей на	массивы с модулями  +
    587				     чисел
1   588	01E6  BE 0101r			 mov si, offset	pos_array + 1
1   589	01E9  BF 012Ar			 mov di, offset	neg_array + 1
1   590
1   591					 ; заполнение	массива mul_array
1   592	01EC  BB 0152r			 mov bx, offset	mul_array
1   593	01EF  89 0F			 mov [bx], byte	ptr cx	 ; запись	в массив	mul_array количества	    +
    594				     элементов
1   595	01F1  43			 inc bx			 ; двигаем указатель на первый		    +
    596				     результат
1   597	01F2				 .prod_loop:
1   598	01F2  C6 06 017Cr 00		     mov err_flag, 0
1   599	01F7  E8 00B0			     call mul_values ; в tmp_res результат умножения	модулей
1   600	01FA  80 3E 017Cr 01		     cmp err_flag, 1
1   601					     ; копируем	результат в массив mul_array
1   602	01FF  51			     push cx
1   603	0200  56			     push si
1   604	0201  74 03			     je	.no_mul_flag
1   605	0203  BE 00D7r			     mov si, offset tmp_res
1   606	0206				 .no_mul_flag:
1   607	0206  B9 000A			     mov cx, 10
1   608	0209				     .copy_loop:
1   609	0209  8A 14				 mov dl, [si]
1   610	020B  88 17				 mov [bx], dl
1   611	020D  46				 inc si
1   612	020E  43				 inc bx
1   613	020F  E2 F8				 loop .copy_loop
1   614	0211  5E			     pop si
1   615	0212  59			     pop cx
1   616					     ; здесь копирование завершено
1   617
1   618					     ; перемещаем указатели к следующим элементам:
1   619	0213  83 C6 0A			     add si, 10
1   620	0216  83 C7 0A			     add di, 10
1   621	0219  E2 D7			     loop .prod_loop
1   622
1   623					 ; восстанавливаем состояние
1   624	021B  5F			 pop di
1   625	021C  5E			 pop si
1   626	021D  5A			 pop dx
1   627	021E  59			 pop cx
Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 12
main.asm



1   628	021F  5B			 pop bx
1   629	0220  58			 pop ax
1   630
1   631	0221  C3			 ret	 ; возврат
1   632	0222			     fill_mul_array endp
1   633
1   634
1   635	0222			     to_bin_decimal proc
1   636					 ; Процедура для перевода числа из ascii в десятичное +
    637				     представление
1   638					 ; В выходном массиве первый байт для учета знака (0 +
    639				     неотрицательное(положительное), 1 - отрицательное)
1   640					 ; все числа будут	выровнены по	разрядам (дополнены+
    641				     незначащими нулями)
1   642					 ; В in_str содержится буфер ввода
1   643					 ;   1й байт: размер	буфера
1   644					 ;   2й байт: количество	введенных символов (включая +
    645				     знак минус)
1   646					 ;   с	третьего по предпоследний: ascii	символы		    +
    647				     введенного числа
1   648					 ;   последний	символ завершения ввода - 0Dh
1   649					 ; Результат:
1   650					 ; в буфере tmp_num записано десятичное представление +
    651				     введенного числа,
1   652					 ; первый	байт - знаковый
1   653					 ; так как при	переводе все	разряды заполняются	    +
    654				     новым	байтом знака, цифрами	разряда или незначащими+
    655				     нулями,
1   656					 ; то	предварительная очистка буфера перед новой    +
    657				     записью не требуется
1   658
1   659					 ; сохранение	состояния
1   660	0222  50			 push ax ; используется для хранения числа 30h и		    +
    661				     использовании	в команде sub
1   662	0223  53			 push bx ; используется для получения ascii-кода		    +
    663				     очередного символа
1   664	0224  51			 push cx ; используется в роли	счетчика обработанных   +
    665				     символов
1   666	0225  52			 push dx ; используется для хранения количества	    +
    667				     незначащих нулей
1   668	0226  57			 push di ; используется для адресации выходного буфера
1   669	0227  56			 push si ; используется для адресации входного буфера
1   670
1   671					 ; предварительная очистка регистров
1   672	0228  33 C0			 xor ax, ax
1   673	022A  33 DB			 xor bx, bx
1   674	022C  33 D2			 xor dx, dx
1   675	022E  33 F6			 xor si, si
1   676	0230  33 FF			 xor di, di
1   677
1   678	0232  BE 00ECr			 mov si, offset	in_str
1   679					 ; начальная инициализация
1   680	0235  B0 30			 mov al, 30h
1   681	0237  BF 00E1r			 mov di, offset	tmp_num
1   682
1   683					 ; инициализируем	счетчик числом символов в	строке
1   684	023A  46			 inc si
Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 13
main.asm



1   685	023B  8B 0C			 mov cx, [si]
1   686	023D  8A 14			 mov dl, [si] ;	записываем количество символов
1   687	023F  32 ED			 xor ch, ch   ;	чистим старший(лишний) байт
1   688
1   689					 ; двигаем указатель на первый символ во входном	    +
    690				     буфере
1   691	0241  46			 inc si
1   692
1   693					 ; проверка на наличие	символа '-', если			    +
    694				     присутствует, записываем байт знака	в выходной	    +
    695				     буфер
1   696					 ; по	умолчанию байт знака инициализирован нулем,   +
    697				     что соответствует неотрицательному	числу
1   698					 ; и двигаем указатель, если нет прыгаем	к		    +
    699				     основному	циклу обработки
1   700	0242  80 3C 2D			 cmp byte ptr [si], NEGATIVE
1   701	0245  75 0B			     jne .positive
1   702	0247  C6 05 01			     mov [di], byte ptr	1
1   703	024A  46			     inc si
1   704	024B  49			     dec cx
1   705	024C  FE CA			     dec dl	 ; если был знак минус уменьшаем		    +
    706				     количество символов в буфере на	1
1   707	024E  47			     inc di
1   708	024F  EB 05 90			     jmp .null_filling
1   709	0252				 .positive:
1   710	0252  C6 05 00			     mov [di], byte ptr	0
1   711	0255  47			     inc di	 ; если число позитивное двигаем		    +
    712				     указатель	выходного буфера	на первый символ
1   713	0256				 .null_filling:	 ; заполнение	незначащими нулями
1   714	0256  80 FA 0A			     cmp dl, 10	 ; все числа десяти разрядные с			    +
    715				     незначащими нулями
1   716	0259  7D 08			     jge .cycle
1   717	025B  C6 05 00			     mov [di], byte ptr	0
1   718	025E  47			     inc di
1   719	025F  FE C2			     inc dl
1   720	0261  EB F3			     jmp .null_filling
1   721
1   722					 ; основной цикл - получаем	ascii код, вычитаем из него+
    723				     30	(так	как символы 0-9 имеют коды 30-39)
1   724					 ; записываем	в выходной буфер,	двигаем указатели
1   725	0263				 .cycle:
1   726	0263  8B 1C			     mov bx, [si]
1   727	0265  32 FF			     xor bh, bh
1   728	0267  2B D8			     sub bx, ax	   ; в	bl результат вычитания
1   729	0269  88 1D			     mov [di], bl
1   730	026B  47			     inc di
1   731	026C  46			     inc si
1   732	026D  E2 F4			     loop .cycle
1   733
1   734					 ; восстанавливаем исходное состояние регистров
1   735	026F  5E			 pop si
1   736	0270  5F			 pop di
1   737	0271  5A			 pop dx
1   738	0272  59			 pop cx
1   739	0273  5B			 pop bx
1   740	0274  58			 pop ax
1   741
Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 14
main.asm



1   742	0275  C3			 ret
1   743
1   744	0276			     to_bin_decimal endp
1   745
1   746	0276			     sum_values	proc
1   747					 ; Процедура для сложения двух неотрицательных	    +
    748				     десяти разрядных двоично-десятичных чисел
1   749					 ; задано	ограничение для числа: |-36768| * |36767| = 1 073 709    +
    750				     056, десять разрядов	защищают от переполнения
1   751					 ; вход:
1   752					 ;     si - адрес первого числа
1   753					 ;     di - адрес второго числа
1   754					 ; результат в tmp_res
1   755
1   756					 ; сохраняем состояние стека
1   757	0276  50			 push ax
1   758	0277  53			 push bx
1   759	0278  51			 push cx
1   760	0279  52			 push dx
1   761	027A  56			 push si
1   762	027B  57			 push di
1   763
1   764					 ; очистка регистров
1   765	027C  33 C0			 xor ax, ax
1   766	027E  33 C9			 xor cx, cx
1   767
1   768	0280  B9 000A			 mov cx, 10 ; инициализируем счетчик - 10 байт	числа = 10	    +
    769				     итераций
1   770
1   771					 ; двигаем указатели на последние разряды (байты)    +
    772				     чисел
1   773	0283  83 C6 09			 add si, 9
1   774	0286  83 C7 09			 add di, 9
1   775
1   776	0289				 .sum_cycle:
1   777					     ; очистка регистров
1   778	0289  33 DB			     xor bx, bx
1   779	028B  33 D2			     xor dx, dx
1   780
1   781	028D  02 04			     add al, byte ptr [si] ; добавляем	очередной разряд		    +
    782				     первого числа в al, в ax очередной разряд +			    +
    783				     переполнение
1   784	028F  8A 1D			     mov bl, byte ptr [di] ; перемещаем очередной разряд	    +
    785				     второго числа в bl
1   786	0291  03 C3			     add ax, bx		   ; складываем, результат в ax
1   787	0293  BB 000A			     mov bx, 10		   ; в	bx делитель - 10
1   788	0296  F7 F3			     div bx		   ; в	ax результат, в dx остаток от	    +
    789				     деления на 10 суммы разрядов	сложенной с			    +
    790				     переполнением
1   791
1   792					     ; инициализируем bx индексом	разряда в		    +
    793				     результирующем буфере (состояние декрементного	    +
    794				     счетчика -	1)
1   795	0298  8B D9			     mov bx, cx
1   796	029A  4B			     dec bx
1   797	029B  88 97 00D7r		     mov tmp_res[bx], dl   ; записываем остаток в разряд	    +
    798				     результата
Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 15
main.asm



1   799
1   800					     ; двигаем указатели в слагаемых
1   801	029F  4E			     dec si
1   802	02A0  4F			     dec di
1   803
1   804	02A1  E2 E6			     loop .sum_cycle	   ; уменьшаем	cx, переходим к следующей+
    805				     итерации
1   806
1   807					 ; восстанавливаем состояние стека
1   808	02A3  5F			 pop di
1   809	02A4  5E			 pop si
1   810	02A5  5A			 pop dx
1   811	02A6  59			 pop cx
1   812	02A7  5B			 pop bx
1   813	02A8  58			 pop ax
1   814
1   815	02A9  C3			 ret
1   816	02AA			     sum_values	endp
1   817
1   818	02AA			     mul_values	proc
1   819					 ; процедура для умножения	двух неотрицательных	    +
    820				     десяти разрядных двоично-десятичных чисел
1   821					 ; в si - адрес первого числа
1   822					 ; в di - адрес второго числа
1   823					 ; результат -	в tmp_res
1   824
1   825	02AA  50			 push ax
1   826	02AB  53			 push bx
1   827	02AC  51			 push cx
1   828	02AD  56			 push si
1   829	02AE  57			 push di
1   830
1   831	02AF  33 C0			 xor ax, ax
1   832	02B1  33 DB			 xor bx, bx
1   833	02B3  33 C9			 xor cx, cx
1   834
1   835					 ; проверка на ноль в первом числе
1   836	02B5  57			 push di
1   837	02B6  8B FE			 mov di, si
1   838	02B8  E8 0027			 call to_hex_decimal
1   839	02BB  5F			 pop di
1   840	02BC  83 F9 00			 cmp cx, 0
1   841	02BF  74 16			 je .no_mul
1   842
1   843					 ; проверка на 1 во	втором числе
1   844	02C1  E8 001E			 call to_hex_decimal   ; преобразование второго числа	к	    +
    845				     десятичному виду, результат в cx
1   846	02C4  83 F9 01			 cmp cx, 1
1   847	02C7  74 0E			 je .no_mul
1   848
1   849	02C9  49			 dec cx
1   850	02CA  8B FE			 mov di, si	       ; умножение реализуем как сложение num1 +
    851				     с	самим собой num2 - 1 раз
1   852	02CC				 .add_cycle:
1   853	02CC  E8 FFA7			     call sum_values   ; результат сложения				    +
    854				     двоично-десятичных чисел из si и di в tmp_res
1   855	02CF  BE 00D7r			     mov si, offset tmp_res
Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 16
main.asm



1   856	02D2  E2 F8			     loop .add_cycle
1   857	02D4  EB 06 90			 jmp .mul_exit
1   858
1   859	02D7				 .no_mul:
1   860	02D7  C6 06 017Cr 01		     mov err_flag, 1
1   861
1   862	02DC				 .mul_exit:
1   863	02DC  5F			     pop di
1   864	02DD  5E			     pop si
1   865	02DE  59			     pop cx
1   866	02DF  5B			     pop bx
1   867	02E0  58			     pop ax
1   868	02E1  C3			     ret
1   869	02E2			     mul_values	endp
1   870
1   871	02E2			     to_hex_decimal proc
1   872					 ; Процедура для перевода числа из				    +
    873				     двоично-десятичного в десятичное представление в    +
    874				     шестнадцатеричной	записи
1   875					 ; В регистре di ожидается адрес					    +
    876				     двоично-десятичного числа
1   877					 ; Результат:
1   878					 ; в cx записано шестнадцатеричное представление	    +
    879				     десятичного числа
1   880					 ; данная	процедура необходима	для инициализации   +
    881				     счетчика для процедуры	умножения чисел
1   882					 ; так как в данной программе задано ограничение	по+
    883				     модулю для вводимого числа равное 32768,
1   884					 ; то	переполнения регистра cx не случится в		    +
    885				     процессе перевода числа в нужный вид
1   886
1   887
1   888					 ; сохранение	состояния
1   889	02E2  50			 push ax ;
1   890	02E3  53			 push bx ; множитель 10
1   891	02E4  56			 push si ; для умножения на разряд
1   892	02E5  57			 push di ; адрес числа которое	нужно преобразовать
1   893
1   894					 ; предварительная очистка регистров
1   895	02E6  33 C0			 xor ax, ax
1   896	02E8  33 DB			 xor bx, bx
1   897	02EA  33 C9			 xor cx, cx
1   898	02EC  33 F6			 xor si, si
1   899
1   900					 ; Преобразование	в десятичное	число (в			    +
    901				     шестнадцатеричном	представлении)
1   902	02EE  B9 0000			 mov cx, 0	 ; счетчик для суммирования числа
1   903	02F1  BB 000A			 mov bx, 10	 ; множитель для умножения	предыдущей	    +
    904				     суммы	на 10
1   905	02F4  BE 000A			 mov si, 10	 ; в si количество разрядов числа (возможны +
    906				     незначащие нули слева)
1   907
1   908	02F7			     .convert_loop:
1   909	02F7  83 FE 00			 cmp si, 0
1   910	02FA  74 1A			 je .conv_end
1   911	02FC  33 C0			 xor ax, ax
1   912	02FE  8A 05			 mov al, [di]	 ; загружаем символ из	строки
Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 17
main.asm



1   913	0300  3C 00			 cmp al, 0
1   914	0302  74 0E			 je .zero_rank
1   915	0304  56			 push si	 ; сохраняем текущее значение			    +
    916				     обрабатываемого разряда
1   917
1   918				     ; умножаем	очередной разряд	на 10	соответствующее	    +
    919				     количество раз
1   920	0305			     .rank_mul:
1   921	0305  4E			 dec si
1   922	0306  83 FE 00			 cmp si, 0
1   923	0309  74 04			 je .conv_cont
1   924	030B  F7 E3			 mul BX		 ; умножаем предыдущую сумму на 10
1   925	030D  EB F6			 jmp .rank_mul
1   926
1   927	030F			     .conv_cont:
1   928	030F  5E			 pop si
1   929	0310  03 C8			 add CX, AX	 ; добавляем текущее значение к сумме
1   930	0312			     .zero_rank:
1   931	0312  47			 inc di		 ; переходим к следующему символу
1   932	0313  4E			 dec si
1   933	0314  EB E1			 jmp .convert_loop
1   934
1   935
1   936	0316			     .conv_end:
1   937	0316  5F			 pop di
1   938	0317  5E			 pop si
1   939	0318  5B			 pop bx
1   940	0319  58			 pop ax
1   941
1   942	031A  C3			 ret
1   943	031B			     to_hex_decimal endp
1   944
1   945	031B			     sum_mul_array proc
1   946					 ; Процедура для получения	суммы элементов массива+
    947				     mul_array
1   948					 ; подразумевается что mul_array заполнен			    +
    949				     двоично-десятичными десяти-разрядными модулями	    +
    950				     попарных произведений
1   951					 ; результат в tmp_res
1   952
1   953	031B  57			 push di ; используется как указатель на адрес		    +
    954				     слагаемого (tmp_res)
1   955	031C  56			 push si ; используется как указатель на mul_array
1   956	031D  51			 push cx ; счетчик обработанных элементов
1   957
1   958	031E  33 F6			 xor si, si
1   959	0320  33 C9			 xor cx, cx
1   960
1   961	0322  E8 FE87			 call clear_tmp_res
1   962
1   963					 ; инициализация указателей
1   964	0325  BF 00D7r			 mov di, offset	tmp_res
1   965	0328  BE 0152r			 mov si, offset	mul_array
1   966
1   967	032B  8A 0C			 mov cl, [si]	      ;	инициализация счетчика элементов	    +
    968				     массива
1   969	032D  46			 inc si		      ;	двигаем указатель на первое		    +
Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 18
main.asm



    970				     произведение
1   971
1   972	032E				 .sum_mul_cycle:
1   973	032E  E8 FF45			     call sum_values  ;	результат сложения				    +
    974				     двоично-десятичных чисел из si и di в tmp_res
1   975	0331  83 C6 0A			     add si, 10
1   976	0334  E2 F8			     loop .sum_mul_cycle
1   977
1   978	0336  59			 pop cx
1   979	0337  5E			 pop si
1   980	0338  5F			 pop di
1   981	0339  C3			 ret
1   982	033A			     sum_mul_array endp
1   983
1   984	033A			     result_to_string proc
1   985					 ; Процедура для наполнения буфера res_str символами   +
    986				     численного результата (модуля)
1   987					 ; подразумевается что буфер tmp_res содержит		    +
    988				     результат	вычисления суммы	попарных (разделенных    +
    989				     по знаку)
1   990					 ; произведений введенных чисел
1   991	033A  56			 push si ; используется как указатель на tmp_res
1   992	033B  57			 push di ; используется как указатель на res_str
1   993	033C  50			 push ax ; используется как промежуточная переменная  +
    994				     для обработки символа
1   995	033D  51			 push cx ; счетчик обработанных символов (байт)
1   996
1   997					 ; очистка регистров
1   998	033E  33 F6			 xor si, si
1   999	0340  33 FF			 xor di, di
1  1000	0342  33 C0			 xor ax, ax
1  1001	0344  33 C9			 xor cx, cx
1  1002
1  1003	0346  BE 00D7r			 mov si, offset	tmp_res
1  1004	0349  BF 00F5r			 mov di, offset	res_str	+ 1    ; пропускаем первый байт - символ  +
   1005				     '-'
1  1006	034C  B9 000A			 mov cx, 10
1  1007
1  1008	034F				 .del_zeros:
1  1009	034F  8A 04			     mov al, [si]
1  1010	0351  3C 00			     cmp al, 0
1  1011	0353  75 04			     jne .true_num_cycle
1  1012	0355  49			     dec cx
1  1013	0356  46			     inc si
1  1014	0357  EB F6			     jmp .del_zeros
1  1015	0359				 .true_num_cycle:
1  1016	0359  8A 04			     mov al, [si]
1  1017	035B  04 30			     add al, 30h
1  1018	035D  88 05			     mov [di], al
1  1019	035F  47			     inc di
1  1020	0360  46			     inc si
1  1021	0361  E2 F6			     loop .true_num_cycle
1  1022
1  1023	0363  58			 pop ax
1  1024	0364  59			 pop cx
1  1025	0365  5F			 pop di
1  1026	0366  5E			 pop si
Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 19
main.asm



1  1027	0367  C3			 ret
1  1028
1  1029	0368			     result_to_string endp
1  1030
   1031
   1032	0000			     .stack
   1033	0368  0100*(??)			 db 100h dup(?)
   1034
   1035				     end start
Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 20
Symbol Table




Symbol Name			  Type	 Value

.ADD_CYCLE			  Near	 _TEXT:02CC
.ADD_VALUE_EXIT			  Near	 _TEXT:01A8
.CLEAR_CYCLE			  Near	 _TEXT:01B4
.CONTINUE			  Near	 _TEXT:015C
.CONVERT_LOOP			  Near	 _TEXT:02F7
.CONV_CONT			  Near	 _TEXT:030F
.CONV_END			  Near	 _TEXT:0316
.COPY_LOOP			  Near	 _TEXT:0209
.CORRECT_INPUT			  Near	 _TEXT:0089
.CORR_END			  Near	 _TEXT:016C
.COUNTER_INITIALIZED		  Near	 _TEXT:01E6
.CYCLE				  Near	 _TEXT:0263
.DEL_ZEROS			  Near	 _TEXT:034F
.END_PROGRAM			  Near	 _TEXT:00BB
.END_RANGE			  Near	 _TEXT:014E
.ERROR				  Near	 _TEXT:0167
.INPUT				  Near	 _TEXT:0020
.IS_NUM_CYCLE			  Near	 _TEXT:00FD
.MAX_DIGITS_CHECK		  Near	 _TEXT:0111
.MUL_EXIT			  Near	 _TEXT:02DC
.NEGATIVE			  Near	 _TEXT:015A
.NEG_CYCLE			  Near	 _TEXT:018D
.NEG_START			  Near	 _TEXT:011C
.NOT_EMPTY			  Near	 _TEXT:0057
.NOT_EXIT			  Near	 _TEXT:006F
.NO_MUL				  Near	 _TEXT:02D7
.NO_MUL_FLAG			  Near	 _TEXT:0206
.NULL_FILLING			  Near	 _TEXT:0256
.POSITIVE			  Near	 _TEXT:0252
.POS_BIGGER			  Near	 _TEXT:01E4
.POS_CYCLE			  Near	 _TEXT:01A0
.POS_NUM			  Near	 _TEXT:0198
.POS_START			  Near	 _TEXT:012C
.PROD_LOOP			  Near	 _TEXT:01F2
.RANGE_CYCLE			  Near	 _TEXT:0139
.RANK_MUL			  Near	 _TEXT:0305
.RETRY				  Near	 _TEXT:002E
.SUM_CYCLE			  Near	 _TEXT:0289
.SUM_MUL_CYCLE			  Near	 _TEXT:032E
.TRUE_NUM_CYCLE			  Near	 _TEXT:0359
.ZERO_RANK			  Near	 _TEXT:0312
??DATE				  Text	 "12/21/23"
??FILENAME			  Text	 "main	  "
??TIME				  Text	 "21:58:19"
??VERSION			  Number 0205
@CODE				  Text	 _TEXT
@CODESIZE			  Text	 0
@CPU				  Text	 0101H
@CURSEG				  Text	 _TEXT
@DATA				  Text	 DGROUP
@DATASIZE			  Text	 0
@FILENAME			  Text	 MAIN
@MODEL				  Text	 2
@WORDSIZE			  Text	 2
Turbo Assembler	 Version 2.51	     12/21/23 21:58:19	    Page 21
Symbol Table



ADD_VALUE			  Near	 _TEXT:0173
CARRET				  Byte	 DGROUP:00D5
CLEAR_TMP_RES			  Near	 _TEXT:01AC
EMPTY_MESS			  Byte	 DGROUP:0059
ERR_FLAG			  Byte	 DGROUP:017C
ERR_MESS			  Byte	 DGROUP:00C7
EXIT_MESS			  Byte	 DGROUP:00A7
FILL_MUL_ARRAY			  Near	 _TEXT:01BD
INPUT_MESS			  Byte	 DGROUP:004A
IN_STR				  Byte	 DGROUP:00EC
IS_CORRECT			  Near	 _TEXT:00C2
MAX_NEG_LEN			  Number 0006
MAX_NUM				  Byte	 DGROUP:0000
MAX_POS_LEN			  Number 0005
MUL_ARRAY			  Byte	 DGROUP:0152
MUL_VALUES			  Near	 _TEXT:02AA
NEGATIVE			  Number 002D
NEG_ARRAY			  Byte	 DGROUP:0129
NEG_FLAG			  Byte	 DGROUP:017B
NEG_MAX_LAST			  Number 0038
NUMS_SIZE			  Number 0008
POS_ARRAY			  Byte	 DGROUP:0100
POS_MAX_LAST			  Number 0037
RESULT_TO_STRING		  Near	 _TEXT:033A
RES_STR				  Byte	 DGROUP:00F4
START				  Near	 _TEXT:0000
START_MESS			  Byte	 DGROUP:0004
SUM_MUL_ARRAY			  Near	 _TEXT:031B
SUM_VALUES			  Near	 _TEXT:0276
TMP_NUM				  Byte	 DGROUP:00E1
TMP_RES				  Byte	 DGROUP:00D7
TO_BIN_DECIMAL			  Near	 _TEXT:0222
TO_HEX_DECIMAL			  Near	 _TEXT:02E2

Macro Name

EXIT
INPUT
PRINT

Groups & Segments		  Bit Size Align  Combine Class

DGROUP				  Group
  STACK				  16  0400 Para	  Stack	  STACK
  _DATA				  16  017D Word	  Public  DATA
_TEXT				  16  0468 Word	  Public  CODE
