;пересылка слов(W) из in_str в out_str 21-ВМз-4 07/12/2023
;слова, не равные '01' ~ 3031h, '23' ~ 3233h, '45' ~ 3435h

.model tiny  ; Устанавливает модель памяти, где весь код и данные помещаются в одном 64KB сегменте.

.code
ORG 100h ; COM-программы начинаются с этой точки
start:
; приглашение ввода:
        mov dx,offset mess1  ; Загружаем смещение строки mess1 в регистр DX
        mov ah,9             ; Устанавливаем 9 в регистр AH для функции "вывод строки" в прерывании DOS 21h
        int 21h              ; Вызываем прерывание DOS 21h, выводя строку mess1 на экран

; ввод:
        mov dx,offset in_str ; Загружаем смещение строки in_str в регистр DX
        mov in_str, 16       ; Записываем 16 в первый байт in_str, ограничивая ввод 16 байтами
        mov ah,10            ; Устанавливаем 10 в регистр AH для функции "buffered input" в прерывании DOS 21h
        int 21h              ; Вызываем прерывание DOS 21h, читая введенные данные в буфер in_str

;основная часть (модифицированный код из ЛР1):
		mov si,offset in_str+2 ; первые 2 байта служебные
		mov di,offset out_str
		mov cx,in_str+1 ; помещаем в cx количество введенных байт символов + первый символ в старший байт
        xor ch, ch      ; очистка старшего байта
        shr cx, 1       ; сдвиг вправо (целочисленное деление на 2)
cmp_cycle:
        mov ax,[si]  ; помещаем первое считанное слово в ax (байты переставлены)
		cmp ax,3130h ; 3031h ~ '01'
		je cmp_true  ; если равно - пропуск
		cmp ax,3332h ; 3233h ~ '23'
		je cmp_true  ; если равно - пропуск
		cmp ax,3534h ; 3435h ~ '45'
		je cmp_true  ; если равно - пропуск
		mov [di], ax ; запись в выходной массив
		add di, 2    ; увеличиваем выходной указатель на 2 (работаем со словами)
cmp_true:
        add si, 2    ; увеличиваем входной указатель на 2 (работаем со словами)
		loop cmp_cycle ; пока регистр счетчика не равен 0 выполняем цикл cmp_cycle

; вывод результата:
    mov dx,offset mess2  ; Загружаем смещение строки mess2 в регистр DX
    mov ah,9  ; Загружаем 9 в регистр AH, что соответствует функции "вывод строки" в прерывании DOS 21h
    int 21h   ; Вызываем DOS interrupt 21h, что выводит строку mess2 на экран

    mov dx,offset out_str  ; Загружаем смещение строки out_str в регистр DX
    mov ah,9  ; Загружаем 9 в регистр AH, что соответствует функции "вывод строки" в прерывании DOS 21h
    int 21h   ; Вызываем DOS interrupt 21h, что выводит строку out_str на экран

; задержка (ожидание нажатия клавиши):
    mov ah,7  ; Устанавливаем 7 в AH, что соответствует функции "ввод без эха" в прерывании DOS 21h
    int 21h   ; Вызываем DOS interrupt 21h, что позволяет программе ожидать нажатия клавиши пользователем

; завершение:
    mov ax,4c00h  ; Загружаем 4C00h в AX, что соответствует функции "завершение программы" в прерывании DOS 21h
    int 21h   ; Вызываем прерывание DOS 21h, что приводит к завершению программы

    ; Объявляем строку mess1, которая содержит текст, символы перевода строки (10) и возврата каретки (13),
    ;и заканчивается символом '$'
    mess1 db '21_vmz_4|A_Khaleev Input:',10,13,'$'

    ; Объявляем строку mess2, которая начинается с символов перевода строки (10) и возврата каретки (13),
    ;содержит текст 'Output:', затем еще символы перевода строки и возврата каретки, и заканчивается символом '$'
    mess2 db 10,13,'Output:',10,13,'$'

    ; Объявляем массив in_str  - выделяется неинициализированная память размером 22 байта
    in_str dw 22 dup (?)

    ; Объявляем массив out_str, состоящий из 22 элементов, каждый из которых инициализируется символом '$'
    out_str dw 22 dup ('$')

    ; в ассемблере строка заканчивается символом '$'. Это позволяет функциям ввода/вывода DOS распознавать конец строки

end start
	