Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 1
main.asm



      1				     .8086
      2	0000			     .MODEL SMALL
      3
      4				     include macros.asm
1     5
1     6				     print macro text ;вывод сообщений на экран
1     7					     push ax
1     8					     push dx
1     9					     mov dx,offset text
1    10					     mov ah,9
1    11					     int 21h
1    12					     pop dx
1    13					     pop ax
1    14				     endm
1    15
1    16				     input macro text ;ввод	строки символов
1    17					 ; сохранение	состояния в стеке
1    18					     push ax
1    19					     push dx
1    20					     push bx
1    21					 ; запись	ввода в буфер text
1    22				     .retry:
1    23					 ; вызов функции ввода	21го прерывания
1    24					     mov dx,offset text
1    25					     mov ah,0ah
1    26					     int 21h
1    27
1    28					     inc dx ; передвигаем указатель	на байт,			    +
     29				     соответствующий количеству введенных символов
1    30					     mov bx, dx
1    31					     mov bl, [bx] ; количество введенных символов
1    32					     cmp bl, 0h	  ; проверка на пустую строку
1    33					     jne .not_empty
1    34					     print empty_mess
1    35					 print input_mess
1    36					 jmp .retry
1    37
1    38				     .not_empty:
1    39					 mov bx, dx
1    40					     inc bx
1    41					     mov bl, [bx] ; первый введенный символ
1    42					     cmp bl, 18h  ; проверка на ввод ctrl+x (= выход)
1    43					     jne .not_exit
1    44					     print exit_mess
1    45					     jmp .end_program
1    46				     .not_exit:
1    47					     ; возврат состояния из стека
1    48					 pop bx
1    49					     pop dx
1    50					     pop ax
1    51				     endm
1    52
1    53				     exit macro
1    54					 ; завершение	программы
1    55					 mov ah, 4ch
1    56					 mov al, 0
1    57					 int 21h
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 2
main.asm



1    58					 ret
1    59				     endm
     60				     include data.asm
1    61	0000			     .data
1    62	      =	002D			 NEGATIVE	  equ 2Dh ; шестнадцатеричный ascii код знака '-'
1    63	      =	0008			 NUMS_SIZE	  equ 8h  ; количество вводимых чисел
1    64	      =	0005			 MAX_POS_LEN	  equ 5h  ; максимальная длина	положительного+
     65				     числа
1    66	      =	0006			 MAX_NEG_LEN	  equ 6h  ; максимальная длина	отрицательного+
     67				     числа	с учетом	знака
1    68	      =	0037			 POS_MAX_LAST	  equ 37h ; младший разряд	верхнего		    +
     69				     ограничения (ascii, hex)
1    70	      =	0038			 NEG_MAX_LAST	  equ 38h ; младший разряд	нижнего			    +
     71				     ограничения (ascii, hex)
1    72	0000  33 32 37 36		 MAX_NUM    db '3276' ;	старшие разряды модуля			    +
     73				     максимального	числа без последнего разряда
1    74
1    75					 ; текстовые переменные для вывода
1    76	0004  49 6E 70 75 74 3A	20+	 start_mess db 'Input: 8 numbers in [-32768, 32767]', 10, 'Press <Enter> after each number',+
     77	      38 20 6E 75 6D 62	65+  10,13,'$'
     78	      72 73 20 69 6E 20	5B+
     79	      2D 33 32 37 36 38	2C+
     80	      20 33 32 37 36 37	5D+
     81	      0A 50 72 65 73 73	20+
     82	      3C 45 6E 74 65 72	3E+
     83	      20 61 66 74 65 72	20+
     84	      65 61 63 68 20 6E	75+
     85	      6D 62 65 72 0A 0D	24
1    86	004A  45 6E 74 65 72 20	6E+	 input_mess db 'Enter number: $'
     87	      75 6D 62 65 72 3A	20+
     88	      24
1    89	0059  6F 75 74 70 75 74	20+	 output_mess db	'output	(sum of	pairwise products of numbers of	different signs):', 10,	13, +
     90	      28 73 75 6D 20 6F	66+  '$'
     91	      20 70 61 69 72 77	69+
     92	      73 65 20 70 72 6F	64+
     93	      75 63 74 73 20 6F	66+
     94	      20 6E 75 6D 62 65	72+
     95	      73 20 6F 66 20 64	69+
     96	      66 66 65 72 65 6E	74+
     97	      20 73 69 67 6E 73	29+
     98	      3A 0A 0D 24
1    99	009C  49 6E 70 75 74 20	45+	 empty_mess db 'Input Error: empty string. Try again or	use ctrl+x and press enter for	    +
    100	      72 72 6F 72 3A 20	65+  exit.', 10, '$'
    101	      6D 70 74 79 20 73	74+
    102	      72 69 6E 67 2E 20	54+
    103	      72 79 20 61 67 61	69+
    104	      6E 20 6F 72 20 75	73+
    105	      65 20 63 74 72 6C	2B+
    106	      78 20 61 6E 64 20	70+
    107	      72 65 73 73 20 65	6E+
    108	      74 65 72 20 66 6F	72+
    109	      20 65 78 69 74 2E	0A+
    110	      24
1   111	00EA  50 72 6F 67 72 61	6D+	 exit_mess  db 'Program	was aborted by keybord', 10, '$'
    112	      20 77 61 73 20 61	62+
    113	      6F 72 74 65 64 20	62+
    114	      79 20 6B 65 79 62	6F+
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 3
main.asm



    115	      72 64 0A 24
1   116	010A  49 6E 70 75 74 20	65+	 err_mess   db 'Input error!', 10, '$'
    117	      72 72 6F 72 21 0A	24
1   118	0118  41 6E 20 65 72 72	6F+	 no_pairs_mess db 'An error occurred: all numbers have the same	sign', 10, '$'
    119	      72 20 6F 63 63 75	72+
    120	      72 65 64 3A 20 61	6C+
    121	      6C 20 6E 75 6D 62	65+
    122	      72 73 20 68 61 76	65+
    123	      20 74 68 65 20 73	61+
    124	      6D 65 20 73 69 67	6E+
    125	      0A 24
1   126	014B  0A 24			 carret	    db 10, '$'
1   127
1   128					 ; буферные переменные
1   129	014D  0A*(00)			 tmp_res    db 10 dup(0)	  ; переменная для	промежуточного+
    130				     сохранения результата сложения/умножения
1   131									  ; двух десяти-разрядных		    +
    132				     беззнаковых двоично-десятичных	чисел
1   133	0157  00 0A*(??)		 tmp_num    db 0, 10 dup(?)	  ; переменная для	промежуточного+
    134				     сохранения двоично-десятичного	представления числа
1   135									  ; первый байт tmp_num - знаковый,
1   136									  ; все операции над 10 разрядными  +
    137				     двоично-десятичными числами (с незначащими нулями)
1   138	0162  07 ?? 06*(??)		 in_str	    db 7, ?, 6 dup (?)	    ; буфер ввода 1 байт размер	    +
    139				     буфера, второй	-количество введенных символов
1   140	016A  0C*(24)			 res_str    db 12 dup ('$')	  ; буфер для преобразования	    +
    141				     результата в строку
1   142									  ; (произведения разных знаков, а +
    143				     также	их последующие суммы всегда отрицательны)
1   144
1   145					 ; массивы, первый	байт в массиве для учета		    +
    146				     количества записанных чисел
1   147	0176  00 04*(0A*(??))		 pos_array  db 0, 4 dup(10 dup(?)) ; массив для пяти модулей	    +
    148				     положительных	двоично-десятичных чисел размером	5   +
    149				     байт
1   150	019F  00 04*(0A*(??))		 neg_array  db 0, 4 dup(10 dup(?)) ; массив для пяти модулей	    +
    151				     отрицательных	двоично-десятичных чисел размером	5   +
    152				     байт
1   153	01C8  00 04*(0A*(??))		 mul_array  db 0, 4 dup(10 dup(?)) ; массив модулей поэлементных   +
    154				     произведений массивов
1   155
1   156					 ; флаги
1   157	01F1  00			 neg_flag   db 0     ; флаг	наличия знака '-' для is_correct	proc
1   158	01F2  00			 err_flag   db 0     ; флаг	ошибки во вводе для is_correct		    +
    159				     proc/цикла ввода
1   160	01F3  00			 no_pairs_flag db 0  ; флаг	ошибки, сигнал о том. что ввдены   +
    161				     числа	одного знака
1   162
1   163
    164
    165	01F4			     .code
    166	0000			     start:
    167					; инициализация памяти
    168	0000  B8 0000s			 mov ax, @data
    169	0003  8E D8			 mov ds, ax
    170
    171					 ;вызов функции 0 -	 установка 3 текстового		    +
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 4
main.asm



    172				     видеорежима, очистка экрана
    173	0005  B8 0003			 mov ax, 0003  ; ah=0 (номер функции), al=3	(номер режима)
    174	0008  CD 10			 int 10h
    175
    176					 print start_mess  ; вывод	стартового сообщения
1   177	000A  50			     push ax
1   178	000B  52			     push dx
1   179	000C  BA 0004r			     mov dx,offset start_mess
1   180	000F  B4 09			     mov ah,9
1   181	0011  CD 21			     int 21h
1   182	0013  5A			     pop dx
1   183	0014  58			     pop ax
    184	0015  33 C9			 xor cx, cx
    185	0017  B9 0008			 mov cx, NUMS_SIZE ; в	cx количество	чисел для ввода		    +
    186				     пользователем
    187
    188					 ; инициализация указателей на	первые элементы	    +
    189				     массивов без учета	размерного байта	(используется в+
    190				     add_value proc)
    191	001A  BE 0177r			 mov si, offset	pos_array + 1
    192	001D  BF 01A0r			 mov di, offset	neg_array + 1
    193
    194					 ; цикл ввода/проверки/распределения по	массивам
    195	0020				 .input:
    196					     print input_mess  ;вывод сообщения о вводе строки
1   197	0020  50			     push ax
1   198	0021  52			     push dx
1   199	0022  BA 004Ar			     mov dx,offset input_mess
1   200	0025  B4 09			     mov ah,9
1   201	0027  CD 21			     int 21h
1   202	0029  5A			     pop dx
1   203	002A  58			     pop ax
    204					     input in_str      ;ввод числа в виде	строки
1   205	002B  50			     push ax
1   206	002C  52			     push dx
1   207	002D  53			     push bx
1   208	002E			     .retry:
1   209	002E  BA 0162r			     mov dx,offset in_str
1   210	0031  B4 0A			     mov ah,0ah
1   211	0033  CD 21			     int 21h
1   212	0035  42			     inc dx ; передвигаем указатель	на байт,			    +
    213				     соответствующий количеству введенных символов
1   214	0036  8B DA			     mov bx, dx
1   215	0038  8A 1F			     mov bl, [bx] ; количество введенных символов
1   216	003A  80 FB 00			     cmp bl, 0h	  ; проверка на пустую строку
1   217	003D  75 18			     jne .not_empty
1   218					     print empty_mess
2   219	003F  50			     push ax
2   220	0040  52			     push dx
2   221	0041  BA 009Cr			     mov dx,offset empty_mess
2   222	0044  B4 09			     mov ah,9
2   223	0046  CD 21			     int 21h
2   224	0048  5A			     pop dx
2   225	0049  58			     pop ax
1   226					 print input_mess
2   227	004A  50			     push ax
2   228	004B  52			     push dx
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 5
main.asm



2   229	004C  BA 004Ar			     mov dx,offset input_mess
2   230	004F  B4 09			     mov ah,9
2   231	0051  CD 21			     int 21h
2   232	0053  5A			     pop dx
2   233	0054  58			     pop ax
1   234	0055  EB D7			 jmp .retry
1   235	0057			     .not_empty:
1   236	0057  8B DA			 mov bx, dx
1   237	0059  43			     inc bx
1   238	005A  8A 1F			     mov bl, [bx] ; первый введенный символ
1   239	005C  80 FB 18			     cmp bl, 18h  ; проверка на ввод ctrl+x (= выход)
1   240	005F  75 0E			     jne .not_exit
1   241					     print exit_mess
2   242	0061  50			     push ax
2   243	0062  52			     push dx
2   244	0063  BA 00EAr			     mov dx,offset exit_mess
2   245	0066  B4 09			     mov ah,9
2   246	0068  CD 21			     int 21h
2   247	006A  5A			     pop dx
2   248	006B  58			     pop ax
1   249	006C  EB 73 90			     jmp .end_program
1   250	006F			     .not_exit:
1   251	006F  5B			 pop bx
1   252	0070  5A			     pop dx
1   253	0071  58			     pop ax
    254
    255					     ; проверки, заполнение массивов
    256	0072  E8 0073			     call is_correct   ; проверка на корректность	символов    +
    257				     числа, установка err_flag
    258	0075  80 3E 01F2r 00		     cmp err_flag, 0
    259	007A  74 0D			     je	.correct_input
    260
    261					     ; если	была ошибка вывод сообщения и			    +
    262				     циклический ввод
    263					     print err_mess
1   264	007C  50			     push ax
1   265	007D  52			     push dx
1   266	007E  BA 010Ar			     mov dx,offset err_mess
1   267	0081  B4 09			     mov ah,9
1   268	0083  CD 21			     int 21h
1   269	0085  5A			     pop dx
1   270	0086  58			     pop ax
    271	0087  EB 97			     jmp .input
    272
    273	0089				 .correct_input:
    274	0089  E8 01D4			     call to_bin_decimal  ; преобразование in_str	к			    +
    275				     двоично-десятичному виду в tmp_num (с незначащими	    +
    276				     нулями и байтом знака)
    277	008C  E8 010A			     call add_value	  ; копирование модуля	из tmp_num в		    +
    278				     соответствующий массив
    279					     print carret	  ; печать переноса строки
1   280	008F  50			     push ax
1   281	0090  52			     push dx
1   282	0091  BA 014Br			     mov dx,offset carret
1   283	0094  B4 09			     mov ah,9
1   284	0096  CD 21			     int 21h
1   285	0098  5A			     pop dx
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 6
main.asm



1   286	0099  58			     pop ax
    287	009A  E2 84			     loop .input	  ; цикл ввода
    288
    289					 ; здесь массивы pos_array и neg_array заполнены модулями	    +
    290				     соответствующих по знаку введенных чисел
    291	009C  E8 014C			 call fill_mul_array
    292					 ; проверка наличия хотя бы одной пары
    293	009F  53			 push bx
    294	00A0  33 DB			 xor bx, bx
    295	00A2  BB 01F3r			 mov bx, offset	no_pairs_flag
    296	00A5  8B 1F			 mov bx, [bx]
    297	00A7  80 FB 01			 cmp bl, 1h
    298	00AA  74 2A			 je .no_pairs_err
    299					 ; продолжение алгоритма, если есть	хотя бы одна	    +
    300				     пара с разными	знаками
    301	00AC  E8 02AA			 call sum_mul_array
    302	00AF  E8 02C6			 call result_to_string
    303					 print output_mess
1   304	00B2  50			     push ax
1   305	00B3  52			     push dx
1   306	00B4  BA 0059r			     mov dx,offset output_mess
1   307	00B7  B4 09			     mov ah,9
1   308	00B9  CD 21			     int 21h
1   309	00BB  5A			     pop dx
1   310	00BC  58			     pop ax
    311					 print res_str
1   312	00BD  50			     push ax
1   313	00BE  52			     push dx
1   314	00BF  BA 016Ar			     mov dx,offset res_str
1   315	00C2  B4 09			     mov ah,9
1   316	00C4  CD 21			     int 21h
1   317	00C6  5A			     pop dx
1   318	00C7  58			     pop ax
    319					 print carret
1   320	00C8  50			     push ax
1   321	00C9  52			     push dx
1   322	00CA  BA 014Br			     mov dx,offset carret
1   323	00CD  B4 09			     mov ah,9
1   324	00CF  CD 21			     int 21h
1   325	00D1  5A			     pop dx
1   326	00D2  58			     pop ax
    327
    328	00D3  EB 0C 90			 jmp .end_program
    329
    330	00D6				 .no_pairs_err:
    331					     print no_pairs_mess
1   332	00D6  50			     push ax
1   333	00D7  52			     push dx
1   334	00D8  BA 0118r			     mov dx,offset no_pairs_mess
1   335	00DB  B4 09			     mov ah,9
1   336	00DD  CD 21			     int 21h
1   337	00DF  5A			     pop dx
1   338	00E0  58			     pop ax
    339
    340	00E1			     .end_program:
    341					 exit ;	завершение программы
1   342	00E1  B4 4C			 mov ah, 4ch
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 7
main.asm



1   343	00E3  B0 00			 mov al, 0
1   344	00E5  CD 21			 int 21h
1   345	00E7  C3			 ret
    346
    347				     include func.asm
1   348
1   349	00E8			     is_correct	proc
1   350					 ; Процедура для проверки корректности введенного +
    351				     числа
1   352					 ; число должно быть записано в	буфер in_str
1   353					 ; корректный	диапазон - [-32768, 32767]
1   354
1   355					 ; сохраняем состояние регистров
1   356	00E8  50			 push ax ; используется для хранения текущего символа
1   357	00E9  53			 push bx ; используется для хранения индекса в		    +
    358				     диапазоне	(проход по константе MAX_NUM)
1   359	00EA  51			 push cx ; используется для хранения количества	    +
    360				     обработанных символов числа
1   361	00EB  52			 push dx ; используется для хранения последнего	    +
    362				     символа диапазона в зависимости от знака
1   363	00EC  56			 push si ; используется для хранения индекса в буфере  +
    364				     ввода
1   365	00ED  57			 push di ; используется для хранения количества	    +
    366				     введенных	символов во входном буфере
1   367
1   368					 ; очистка используемых регистров
1   369	00EE  33 C0			 xor ax, ax
1   370	00F0  33 DB			 xor bx, bx
1   371	00F2  33 C9			 xor cx, cx
1   372	00F4  33 D2			 xor dx, dx
1   373	00F6  33 F6			 xor si, si
1   374	00F8  33 FF			 xor di, di
1   375
1   376					 ; инициализация di количеством	символов во входном+
    377				     буфере
1   378	00FA  BF 0162r			 mov di, offset	in_str ; помещаем в di	адрес буфера	ввода
1   379	00FD  47			 inc di		 ; перемещаем	на количество символов	    +
    380				     записанных в буфер
1   381	00FE  8B 3D			 mov di, [di]	 ; загружаем 2	первых байта	из in_str в di
1   382	0100  81 E7 00FF		 and di, 00FFh	 ; очищаем старший байт
1   383
1   384					 ; начальная инициализация
1   385	0104  C6 06 01F1r 00		 mov neg_flag, 0 ; очистка флага для хранения знака	числа
1   386	0109  C6 06 01F2r 00		 mov err_flag, 0 ; очистка флага для определения ошибки	    +
    387				     ввода
1   388	010E  BE 0002			 mov si, 2	 ; Инициализация индекса числа	(пропуск	    +
    389				     служебных	байтов буфера)
1   390	0111  BB 0000			 mov bx, 0	 ; Инициализация индекса для			    +
    391				     максимального	диапазона
1   392
1   393	0114  8A 84 0162r		 mov al, in_str[si]; Загрузка текущего элемента	буфера в	AL
1   394	0118  3C 2D			 cmp al, NEGATIVE  ; Является ли первый	символ знаком '-'
1   395	011A  75 07			 jne .is_num_cycle
1   396	011C  C6 06 01F1r 01		 mov neg_flag, 1   ; установка	флага отрицательного	числа
1   397	0121  46			 inc si		   ; перемещаем указатель в	буфере на	    +
    398				     следующий	байт (символ)
1   399	0122  41			 inc cx		   ; увеличиваем счетчик обработанных	    +
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 8
main.asm



    400				     чисел
1   401
1   402					 ; проверка: является ли числом	каждый введенный	    +
    403				     символ символ (исключая первый минус)
1   404	0123				 .is_num_cycle:
1   405	0123  3B CF			     cmp cx, di		  ; если все символы обработаны
1   406	0125  74 10			     je	.max_digits_check ; выход из цикла
1   407	0127  8A 84 0162r		     mov al, in_str[si]	  ; в al очередной ascii код ввода
1   408	012B  3C 30			     cmp al, 30h	  ; 30h	- ascii	код для числа 0, если меньше - +
    409				     ошибка ввода
1   410	012D  7C 5E			     jl	.error
1   411	012F  3C 39			     cmp al, 39h	  ; 39h	- ascii	код для числа 9, если меньше - +
    412				     ошибка ввода
1   413	0131  7F 5A			     jg	.error
1   414	0133  41			     inc cx		  ; увеличиваем счетчик
1   415	0134  46			     inc si		  ; двигаем указатель
1   416	0135  EB EC			     jmp .is_num_cycle	  ; повторяем цикл
1   417
1   418
1   419	0137				 .max_digits_check:
1   420					     ; очистка регистров
1   421	0137  33 C9			     xor cx, cx
1   422	0139  33 F6			     xor si, si
1   423
1   424	013B  80 3E 01F1r 00		     cmp neg_flag, 0	 ; проверка знака числа
1   425	0140  74 10			     je	.pos_start
1   426
1   427					     ; для отрицательных:
1   428	0142				     .neg_start:
1   429	0142  83 FF 06				 cmp di, MAX_NEG_LEN ; сравнение количества введенных   +
    430				     символов и максимального количества разрядов
1   431	0145  7C 4B				 jl .corr_end	     ; если	меньше, завершаем без	ошибки
1   432	0147  7F 44				 jg .error	     ; если	больше завершаем	с ошибкой
1   433						 ; если равно,	инициализация и переход к		    +
    434				     поразрядной проверке
1   435	0149  BE 0003				 mov si, 3
1   436	014C  B9 0002				 mov cx, 2	      ;	значение больше на 1 чем		    +
    437				     действительное чтобы выйти	из range_cycle раньше на 1	    +
    438				     символ
1   439	014F  EB 0E 90				 jmp .range_cycle
1   440
1   441					     ; для положительных
1   442	0152				     .pos_start:
1   443	0152  83 FF 05				 cmp di, MAX_POS_LEN ; сравнение количества введенных   +
    444				     символов и максимального количества разрядов
1   445	0155  7C 3B				 jl .corr_end	     ; если	меньше, завершаем без	ошибки
1   446	0157  7F 34				 jg .error
1   447						 ; если равно,	инициализация и переход к		    +
    448				     поразрядной проверке
1   449	0159  BE 0002				 mov si, 2
1   450	015C  B9 0001				 mov cx, 1
1   451
1   452					     ; поразрядная проверка диапазона если		    +
    453				     количество символов модуля	равно 5
1   454	015F				     .range_cycle:
1   455	015F  8A 84 0162r			 mov al, in_str[si] ; Загрузка текущего	элемента	    +
    456				     буфера в AL
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 9
main.asm



1   457	0163  3A 87 0000r			 cmp al, MAX_NUM[bx]
1   458	0167  7F 24				 jg .error
1   459	0169  7C 27				 jl .corr_end
1   460						 ; если символ равен ограничению:
1   461	016B  46				 inc si		   ; Увеличение индекса числа
1   462	016C  41				 inc cx		   ; Увеличение счетчика обработанных +
    463				     цифр
1   464	016D  43				 inc bx		   ; Увеличение индекса в строке	    +
    465				     содержащей максимальные цифры диапазона
1   466	016E  3B CF				 cmp cx, di	   ; Проверка, достигнут ли конец	    +
    467				     буфера
1   468	0170  74 02				 je .end_range	   ; Если да, прерывание цикла
1   469	0172  EB EB				 jmp .range_cycle  ; Переход на следующую итерацию	    +
    470				     цикла
1   471
1   472					     ; проверка	последнего символа если число		    +
    473				     значащих цифр равно максимальному
1   474	0174				     .end_range:
1   475	0174  80 3E 01F1r 01			 cmp neg_flag, 1
1   476	0179  74 05				 je .negative
1   477	017B  B2 37				 mov dl, POS_MAX_LAST
1   478	017D  EB 03 90				 jmp .continue
1   479	0180				     .negative:
1   480	0180  B2 38				 mov dl, NEG_MAX_LAST
1   481	0182				     .continue:
1   482	0182  8A 84 0162r			 mov al, in_str[si] ; загружаем последний символ
1   483	0186  3A C2				 cmp al, dl
1   484	0188  7F 03				 jg .error	    ; если есть	выход за	границу		    +
    485				     диапазона	переход к ошибке
1   486	018A  EB 06 90				 jmp .corr_end
1   487
1   488					 ; завершение	с ошибкой
1   489	018D				 .error:
1   490	018D  C6 06 01F2r 01		     mov err_flag, 1	  ; установка флага ошибки
1   491
1   492					 ; завершение	без ошибки
1   493	0192				 .corr_end:
1   494					     ; восстанавливаем состояние из стека
1   495	0192  5F			     pop di
1   496	0193  5E			     pop si
1   497	0194  5A			     pop dx
1   498	0195  59			     pop cx
1   499	0196  5B			     pop bx
1   500	0197  58			     pop ax
1   501	0198  C3			     ret
1   502
1   503	0199			     is_correct	endp
1   504
1   505	0199			     add_value proc
1   506					 ; Процедура для копирования числа из временной	    +
    507				     переменной в соответствующий массив
1   508					 ; число представлено в двоично-десятичном виде с   +
    509				     незначащими нулями (размер на выходе 5 байт)
1   510					 ; в массивы записываем только модули, увеличиваем +
    511				     количество записанных чисел
1   512					 ; в si адрес очередного элемента в массиве		    +
    513				     положительных	чисел
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 10
main.asm



1   514					 ; в di адрес очередного элемента в массиве		    +
    515				     отрицательных	чисел
1   516					 ; в tmp_num значение очередного введенного и		    +
    517				     преобразованного числа которое	нужно скопировать
1   518
1   519	0199  50			 push ax ; используется для увеличения	счетчика	    +
    520				     записанных чисел в	массиве и копирования очередной +
    521				     цифры(байта) числа
1   522	019A  53			 push bx ; используется как указатель на tmp_num
1   523	019B  51			 push cx ; счетчик элементов числа	для цикла,		    +
    524				     инициализируется числом 5 (количеством байт в	    +
    525				     каждом числе)
1   526
1   527					 ; инициализация счетчика
1   528	019C  33 C9			 xor cx, cx
1   529	019E  B9 000A			 mov cx, 10
1   530
1   531	01A1  BB 0157r			 mov bx, offset	tmp_num	; инициализируем указатель на		    +
    532				     временную	переменную
1   533	01A4  8A 07			 mov al, [bx]		; в al	байт знака
1   534	01A6  43			 inc bx			; перемещаем указатель на первый	    +
    535				     символ
1   536	01A7  3C 00			 cmp al, 0		; проверка на						    +
    537				     отрицательное/положительное число
1   538	01A9  74 17			 je .pos_num
1   539
1   540					 ; увеличиваем счетчик записанных чисел в массиве  +
    541				     отрицательных	чисел
1   542	01AB  A0 019Fr			 mov al, neg_array
1   543	01AE  3C 04			 cmp al, 4
1   544	01B0  74 24			 je .add_value_exit ; в программе не может быть более	4х пар, +
    545				     предупреждение выхода за границы массива
1   546	01B2  FE C0			 inc al
1   547	01B4  A2 019Fr			 mov neg_array,	al
1   548
1   549					 ; по-байтовая запись модуля очередного	числа в	    +
    550				     массив отрицательных чисел
1   551	01B7				 .neg_cycle:
1   552	01B7  8A 07			     mov al, [bx]
1   553	01B9  88 05			     mov [di], al
1   554	01BB  43			     inc bx
1   555	01BC  47			     inc di
1   556	01BD  E2 F8			     loop .neg_cycle
1   557
1   558	01BF  EB 15 90			 jmp .add_value_exit
1   559
1   560	01C2				 .pos_num:
1   561					     ; увеличиваем счетчик записанных чисел в		    +
    562				     массиве положительных (неотрицательных)	чисел
1   563	01C2  A0 0176r			     mov al, pos_array
1   564	01C5  3C 04			     cmp al, 4
1   565	01C7  74 0D			     je	.add_value_exit	; в программе	не может	быть более 4х	    +
    566				     пар, предупреждение выхода за границы массива
1   567	01C9  FE C0			     inc al
1   568	01CB  A2 0176r			     mov pos_array, al
1   569
1   570					 ; по-байтовая запись модуля очередного	числа в	    +
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 11
main.asm



    571				     массив положительных (неотрицательных) чисел
1   572	01CE				 .pos_cycle:
1   573	01CE  8A 07			     mov al, [bx]
1   574	01D0  88 04			     mov [si], al
1   575	01D2  43			     inc bx
1   576	01D3  46			     inc si
1   577	01D4  E2 F8			     loop .pos_cycle
1   578
1   579					 ; возврат состояния
1   580	01D6				 .add_value_exit:
1   581	01D6  59			     pop cx
1   582	01D7  5B			     pop bx
1   583	01D8  58			     pop ax
1   584	01D9  C3			     ret
1   585
1   586	01DA			     add_value endp
1   587
1   588	01DA			     clear_tmp_res proc
1   589	01DA  56			 push si
1   590	01DB  51			 push cx
1   591	01DC  B9 000A			 mov cx, 10
1   592	01DF  BE 014Dr			 mov si, offset	tmp_res
1   593	01E2				 .clear_cycle:
1   594	01E2  C6 04 00			     mov byte ptr [si],	0
1   595	01E5  46			     inc si
1   596	01E6  E2 FA			     loop .clear_cycle
1   597	01E8  59			 pop cx
1   598	01E9  5E			 pop si
1   599
1   600	01EA  C3			 ret
1   601	01EB			     clear_tmp_res endp
1   602
1   603	01EB			     fill_mul_array proc
1   604					 ; процедура для заполнения массива mul_array		    +
    605				     попарными	произведениями модулей положительных и   +
    606				     отрицательных	чисел
1   607					 ; ожидается что произведен ввод с клавиатуры	    +
    608				     чисел, числа приведены к двоично-десятичному	виду
1   609					 ; массивы pos_array и neg_array заполнены модулями		    +
    610				     положительных	и отрицательных чисел соответственно
1   611
1   612					 ; сохраняем состояние
1   613	01EB  50			 push ax
1   614	01EC  53			 push bx
1   615	01ED  51			 push cx
1   616	01EE  52			 push dx
1   617	01EF  56			 push si
1   618	01F0  57			 push di
1   619
1   620					 ; чистим	регистры
1   621	01F1  33 C0			 xor ax, ax
1   622	01F3  33 DB			 xor bx, bx
1   623	01F5  33 C9			 xor cx, cx
1   624	01F7  33 D2			 xor dx, dx
1   625	01F9  33 F6			 xor si, si
1   626	01FB  33 FF			 xor di, di
1   627
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 12
main.asm



1   628					 ; инициализация счетчика размером	меньшего из	    +
    629				     массивов введенных чисел
1   630	01FD  BB 0176r			 mov bx, offset	pos_array
1   631	0200  8A 1F			 mov bl, [bx]
1   632	0202  8A C3			 mov al, bl
1   633	0204  BB 019Fr			 mov bx, offset	neg_array
1   634	0207  8A 1F			 mov bl, [bx]
1   635
1   636					 ; проверка наличия хотя бы одной пары
1   637	0209  3C 00			 cmp al, 0h
1   638	020B  74 45			 je .zero_array
1   639	020D  80 FB 00			 cmp bl, 0h
1   640	0210  74 40			 je .zero_array
1   641
1   642					 ; продолжение алгоритма, если есть	хотя бы одна	    +
    643				     пара значений
1   644	0212  3A C3			 cmp al, bl
1   645	0214  7C 05			 jl .pos_lower
1   646	0216  8A CB			 mov cl, bl
1   647	0218  EB 03 90			 jmp .counter_initialized
1   648	021B			     .pos_lower:
1   649	021B  8A C8			 mov cl, al
1   650
1   651	021D			     .counter_initialized:
1   652					 ; инициализация указателей на	массивы с модулями  +
    653				     чисел
1   654	021D  BE 0177r			 mov si, offset	pos_array + 1
1   655	0220  BF 01A0r			 mov di, offset	neg_array + 1
1   656
1   657					 ; заполнение	массива mul_array
1   658	0223  BB 01C8r			 mov bx, offset	mul_array
1   659	0226  89 0F			 mov [bx], byte	ptr cx	 ; запись	в массив	mul_array количества	    +
    660				     элементов
1   661	0228  43			 inc bx			 ; двигаем указатель на первый		    +
    662				     результат
1   663	0229				 .prod_loop:
1   664	0229  C6 06 01F2r 00		     mov err_flag, 0
1   665	022E  E8 00B7			     call mul_values ; в tmp_res результат умножения	модулей
1   666	0231  80 3E 01F2r 01		     cmp err_flag, 1
1   667					     ; копируем	результат в массив mul_array
1   668	0236  51			     push cx
1   669	0237  56			     push si
1   670	0238  74 03			     je	.no_mul_flag
1   671	023A  BE 014Dr			     mov si, offset tmp_res
1   672	023D				 .no_mul_flag:
1   673	023D  B9 000A			     mov cx, 10
1   674	0240				     .copy_loop:
1   675	0240  8A 14				 mov dl, [si]
1   676	0242  88 17				 mov [bx], dl
1   677	0244  46				 inc si
1   678	0245  43				 inc bx
1   679	0246  E2 F8				 loop .copy_loop
1   680	0248  5E			     pop si
1   681	0249  59			     pop cx
1   682					     ; здесь копирование завершено
1   683
1   684					     ; перемещаем указатели к следующим элементам:
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 13
main.asm



1   685	024A  83 C6 0A			     add si, 10
1   686	024D  83 C7 0A			     add di, 10
1   687	0250  E2 D7			     loop .prod_loop
1   688	0252				 .zero_array:
1   689	0252  BB 01F3r			     mov bx, offset no_pairs_flag
1   690	0255  C7 07 0001		     mov [bx], 1h   ; установка флага ошибки (все числа	    +
    691				     одного знака)
*Warning* func.asm(285)	Argument needs type override
1   692
1   693					 ; восстанавливаем состояние
1   694	0259  5F			 pop di
1   695	025A  5E			 pop si
1   696	025B  5A			 pop dx
1   697	025C  59			 pop cx
1   698	025D  5B			 pop bx
1   699	025E  58			 pop ax
1   700
1   701	025F  C3			 ret	 ; возврат
1   702	0260			     fill_mul_array endp
1   703
1   704
1   705	0260			     to_bin_decimal proc
1   706					 ; Процедура для перевода числа из ascii в десятичное +
    707				     представление
1   708					 ; В выходном массиве первый байт для учета знака (0 +
    709				     неотрицательное(положительное), 1 - отрицательное)
1   710					 ; все числа будут	выровнены по	разрядам (дополнены+
    711				     незначащими нулями)
1   712					 ; В in_str содержится буфер ввода
1   713					 ;   1й байт: размер	буфера
1   714					 ;   2й байт: количество	введенных символов (включая +
    715				     знак минус)
1   716					 ;   с	третьего по предпоследний: ascii	символы		    +
    717				     введенного числа
1   718					 ;   последний	символ завершения ввода - 0Dh
1   719					 ; Результат:
1   720					 ; в буфере tmp_num записано десятичное представление +
    721				     введенного числа,
1   722					 ; первый	байт - знаковый
1   723					 ; так как при	переводе все	разряды заполняются	    +
    724				     новым	байтом знака, цифрами	разряда или незначащими+
    725				     нулями,
1   726					 ; то	предварительная очистка буфера перед новой    +
    727				     записью не требуется
1   728
1   729					 ; сохранение	состояния
1   730	0260  50			 push ax ; используется для хранения числа 30h и		    +
    731				     использовании	в команде sub
1   732	0261  53			 push bx ; используется для получения ascii-кода		    +
    733				     очередного символа
1   734	0262  51			 push cx ; используется в роли	счетчика обработанных   +
    735				     символов
1   736	0263  52			 push dx ; используется для хранения количества	    +
    737				     незначащих нулей
1   738	0264  57			 push di ; используется для адресации выходного буфера
1   739	0265  56			 push si ; используется для адресации входного буфера
1   740
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 14
main.asm



1   741					 ; предварительная очистка регистров
1   742	0266  33 C0			 xor ax, ax
1   743	0268  33 DB			 xor bx, bx
1   744	026A  33 D2			 xor dx, dx
1   745	026C  33 F6			 xor si, si
1   746	026E  33 FF			 xor di, di
1   747
1   748	0270  BE 0162r			 mov si, offset	in_str
1   749					 ; начальная инициализация
1   750	0273  B0 30			 mov al, 30h
1   751	0275  BF 0157r			 mov di, offset	tmp_num
1   752
1   753					 ; инициализируем	счетчик числом символов в	строке
1   754	0278  46			 inc si
1   755	0279  8B 0C			 mov cx, [si]
1   756	027B  8A 14			 mov dl, [si] ;	записываем количество символов
1   757	027D  32 ED			 xor ch, ch   ;	чистим старший(лишний) байт
1   758
1   759					 ; двигаем указатель на первый символ во входном	    +
    760				     буфере
1   761	027F  46			 inc si
1   762
1   763					 ; проверка на наличие	символа '-', если			    +
    764				     присутствует, записываем байт знака	в выходной	    +
    765				     буфер
1   766					 ; по	умолчанию байт знака инициализирован нулем,   +
    767				     что соответствует неотрицательному	числу
1   768					 ; и двигаем указатель, если нет прыгаем	к		    +
    769				     основному	циклу обработки
1   770	0280  80 3C 2D			 cmp byte ptr [si], NEGATIVE
1   771	0283  75 0B			     jne .positive
1   772	0285  C6 05 01			     mov [di], byte ptr	1 ; запись знакового байта
1   773	0288  46			     inc si
1   774	0289  49			     dec cx
1   775	028A  FE CA			     dec dl	 ; если был знак минус уменьшаем		    +
    776				     количество символов в буфере на	1
1   777	028C  47			     inc di
1   778	028D  EB 05 90			     jmp .null_filling
1   779	0290				 .positive:
1   780	0290  C6 05 00			     mov [di], byte ptr	0  ; запись знакового байта
1   781	0293  47			     inc di	 ; если число позитивное двигаем		    +
    782				     указатель	выходного буфера	на первый символ
1   783	0294				 .null_filling:	 ; заполнение	незначащими нулями
1   784	0294  80 FA 0A			     cmp dl, 10	 ; все числа десяти разрядные с			    +
    785				     незначащими нулями
1   786	0297  7D 08			     jge .cycle
1   787	0299  C6 05 00			     mov [di], byte ptr	0
1   788	029C  47			     inc di
1   789	029D  FE C2			     inc dl
1   790	029F  EB F3			     jmp .null_filling
1   791
1   792					 ; основной цикл - получаем	ascii код, вычитаем из него+
    793				     30	(так	как символы 0-9 имеют коды 30-39)
1   794					 ; записываем	в выходной буфер,	двигаем указатели
1   795	02A1				 .cycle:
1   796	02A1  8B 1C			     mov bx, [si]
1   797	02A3  32 FF			     xor bh, bh
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 15
main.asm



1   798	02A5  2B D8			     sub bx, ax	   ; в	bl результат вычитания
1   799	02A7  88 1D			     mov [di], bl
1   800	02A9  47			     inc di
1   801	02AA  46			     inc si
1   802	02AB  E2 F4			     loop .cycle
1   803
1   804					 ; восстанавливаем исходное состояние регистров
1   805	02AD  5E			 pop si
1   806	02AE  5F			 pop di
1   807	02AF  5A			 pop dx
1   808	02B0  59			 pop cx
1   809	02B1  5B			 pop bx
1   810	02B2  58			 pop ax
1   811
1   812	02B3  C3			 ret
1   813
1   814	02B4			     to_bin_decimal endp
1   815
1   816	02B4			     sum_values	proc
1   817					 ; Процедура для сложения двух неотрицательных	    +
    818				     десяти разрядных двоично-десятичных чисел
1   819					 ; задано	ограничение для числа: |-36768| * |36767| = 1 073 709    +
    820				     056, десять разрядов	защищают от переполнения
1   821					 ; вход:
1   822					 ;     si - адрес первого числа
1   823					 ;     di - адрес второго числа
1   824					 ; результат в tmp_res
1   825
1   826					 ; сохраняем состояние стека
1   827	02B4  50			 push ax
1   828	02B5  53			 push bx
1   829	02B6  51			 push cx
1   830	02B7  52			 push dx
1   831	02B8  56			 push si
1   832	02B9  57			 push di
1   833
1   834					 ; очистка регистров
1   835	02BA  33 C0			 xor ax, ax
1   836	02BC  33 C9			 xor cx, cx
1   837
1   838	02BE  B9 000A			 mov cx, 10 ; инициализируем счетчик - 10 байт	числа = 10	    +
    839				     итераций
1   840
1   841					 ; двигаем указатели на последние разряды (байты)    +
    842				     чисел
1   843	02C1  83 C6 09			 add si, 9
1   844	02C4  83 C7 09			 add di, 9
1   845
1   846	02C7				 .sum_cycle:
1   847					     ; очистка регистров
1   848	02C7  33 DB			     xor bx, bx
1   849	02C9  33 D2			     xor dx, dx
1   850
1   851	02CB  02 04			     add al, byte ptr [si] ; добавляем	очередной разряд		    +
    852				     первого числа в al, в ax очередной разряд +			    +
    853				     переполнение
1   854	02CD  8A 1D			     mov bl, byte ptr [di] ; перемещаем очередной разряд	    +
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 16
main.asm



    855				     второго числа в bl
1   856	02CF  03 C3			     add ax, bx		   ; складываем, результат в ax
1   857	02D1  BB 000A			     mov bx, 10		   ; в	bx делитель - 10
1   858	02D4  F7 F3			     div bx		   ; в	ax результат, в dx остаток от	    +
    859				     деления на 10 суммы разрядов	сложенной с			    +
    860				     переполнением
1   861
1   862					     ; инициализируем bx индексом	разряда в		    +
    863				     результирующем буфере (состояние декрементного	    +
    864				     счетчика -	1)
1   865	02D6  8B D9			     mov bx, cx
1   866	02D8  4B			     dec bx
1   867	02D9  88 97 014Dr		     mov tmp_res[bx], dl   ; записываем остаток в разряд	    +
    868				     результата
1   869
1   870					     ; двигаем указатели в слагаемых
1   871	02DD  4E			     dec si
1   872	02DE  4F			     dec di
1   873
1   874	02DF  E2 E6			     loop .sum_cycle	   ; уменьшаем	cx, переходим к следующей+
    875				     итерации
1   876
1   877					 ; восстанавливаем состояние стека
1   878	02E1  5F			 pop di
1   879	02E2  5E			 pop si
1   880	02E3  5A			 pop dx
1   881	02E4  59			 pop cx
1   882	02E5  5B			 pop bx
1   883	02E6  58			 pop ax
1   884
1   885	02E7  C3			 ret
1   886	02E8			     sum_values	endp
1   887
1   888	02E8			     mul_values	proc
1   889					 ; процедура для умножения	двух неотрицательных	    +
    890				     десяти разрядных двоично-десятичных чисел
1   891					 ; в si - адрес первого числа
1   892					 ; в di - адрес второго числа
1   893					 ; результат -	в tmp_res
1   894
1   895	02E8  50			 push ax
1   896	02E9  53			 push bx
1   897	02EA  51			 push cx
1   898	02EB  56			 push si
1   899	02EC  57			 push di
1   900
1   901	02ED  33 C0			 xor ax, ax
1   902	02EF  33 DB			 xor bx, bx
1   903	02F1  33 C9			 xor cx, cx
1   904
1   905					 ; проверка на ноль в первом числе
1   906	02F3  57			 push di
1   907	02F4  8B FE			 mov di, si
1   908	02F6  E8 0027			 call to_hex_decimal
1   909	02F9  5F			 pop di
1   910	02FA  83 F9 00			 cmp cx, 0
1   911	02FD  74 16			 je .no_mul
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 17
main.asm



1   912
1   913					 ; проверка на 1 во	втором числе
1   914	02FF  E8 001E			 call to_hex_decimal   ; преобразование второго числа	к	    +
    915				     десятичному виду, результат в cx
1   916	0302  83 F9 01			 cmp cx, 1
1   917	0305  74 0E			 je .no_mul
1   918
1   919	0307  49			 dec cx
1   920	0308  8B FE			 mov di, si	       ; умножение реализуем как сложение num1 +
    921				     с	самим собой num2 - 1 раз
1   922	030A				 .add_cycle:
1   923	030A  E8 FFA7			     call sum_values   ; результат сложения				    +
    924				     двоично-десятичных чисел из si и di в tmp_res
1   925	030D  BE 014Dr			     mov si, offset tmp_res
1   926	0310  E2 F8			     loop .add_cycle
1   927	0312  EB 06 90			 jmp .mul_exit
1   928
1   929	0315				 .no_mul:
1   930	0315  C6 06 01F2r 01		     mov err_flag, 1
1   931
1   932	031A				 .mul_exit:
1   933	031A  5F			     pop di
1   934	031B  5E			     pop si
1   935	031C  59			     pop cx
1   936	031D  5B			     pop bx
1   937	031E  58			     pop ax
1   938	031F  C3			     ret
1   939	0320			     mul_values	endp
1   940
1   941	0320			     to_hex_decimal proc
1   942					 ; Процедура для перевода числа из				    +
    943				     двоично-десятичного в десятичное представление в    +
    944				     шестнадцатеричной	записи
1   945					 ; В регистре di ожидается адрес					    +
    946				     двоично-десятичного числа
1   947					 ; Результат:
1   948					 ; в cx записано шестнадцатеричное представление	    +
    949				     десятичного числа
1   950					 ; данная	процедура необходима	для инициализации   +
    951				     счетчика для процедуры	умножения чисел
1   952					 ; так как в данной программе задано ограничение	по+
    953				     модулю для вводимого числа равное 32768,
1   954					 ; то	переполнения регистра cx не случится в		    +
    955				     процессе перевода числа в нужный вид
1   956
1   957
1   958					 ; сохранение	состояния
1   959	0320  50			 push ax ;
1   960	0321  53			 push bx ; множитель 10
1   961	0322  56			 push si ; для умножения на разряд
1   962	0323  57			 push di ; адрес числа которое	нужно преобразовать
1   963
1   964					 ; предварительная очистка регистров
1   965	0324  33 C0			 xor ax, ax
1   966	0326  33 DB			 xor bx, bx
1   967	0328  33 C9			 xor cx, cx
1   968	032A  33 F6			 xor si, si
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 18
main.asm



1   969
1   970					 ; Преобразование	в десятичное	число (в			    +
    971				     шестнадцатеричном	представлении)
1   972	032C  B9 0000			 mov cx, 0	 ; счетчик для суммирования числа
1   973	032F  BB 000A			 mov bx, 10	 ; множитель для умножения	предыдущей	    +
    974				     суммы	на 10
1   975	0332  BE 000A			 mov si, 10	 ; в si количество разрядов числа (возможны +
    976				     незначащие нули слева)
1   977
1   978	0335			     .convert_loop:
1   979	0335  83 FE 00			 cmp si, 0
1   980	0338  74 1A			 je .conv_end
1   981	033A  33 C0			 xor ax, ax
1   982	033C  8A 05			 mov al, [di]	 ; загружаем символ из	строки
1   983	033E  3C 00			 cmp al, 0
1   984	0340  74 0E			 je .zero_rank
1   985	0342  56			 push si	 ; сохраняем текущее значение			    +
    986				     обрабатываемого разряда
1   987
1   988				     ; умножаем	очередной разряд	на 10	соответствующее	    +
    989				     количество раз
1   990	0343			     .rank_mul:
1   991	0343  4E			 dec si
1   992	0344  83 FE 00			 cmp si, 0
1   993	0347  74 04			 je .conv_cont
1   994	0349  F7 E3			 mul BX		 ; умножаем предыдущую сумму на 10
1   995	034B  EB F6			 jmp .rank_mul
1   996
1   997	034D			     .conv_cont:
1   998	034D  5E			 pop si
1   999	034E  03 C8			 add CX, AX	 ; добавляем текущее значение к сумме
1  1000	0350			     .zero_rank:
1  1001	0350  47			 inc di		 ; переходим к следующему символу
1  1002	0351  4E			 dec si
1  1003	0352  EB E1			 jmp .convert_loop
1  1004
1  1005
1  1006	0354			     .conv_end:
1  1007	0354  5F			 pop di
1  1008	0355  5E			 pop si
1  1009	0356  5B			 pop bx
1  1010	0357  58			 pop ax
1  1011
1  1012	0358  C3			 ret
1  1013	0359			     to_hex_decimal endp
1  1014
1  1015	0359			     sum_mul_array proc
1  1016					 ; Процедура для получения	суммы элементов массива+
   1017				     mul_array
1  1018					 ; подразумевается что mul_array заполнен			    +
   1019				     двоично-десятичными десяти-разрядными модулями	    +
   1020				     попарных произведений
1  1021					 ; результат в tmp_res
1  1022
1  1023	0359  57			 push di ; используется как указатель на адрес		    +
   1024				     слагаемого (tmp_res)
1  1025	035A  56			 push si ; используется как указатель на mul_array
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 19
main.asm



1  1026	035B  51			 push cx ; счетчик обработанных элементов
1  1027
1  1028	035C  33 F6			 xor si, si
1  1029	035E  33 C9			 xor cx, cx
1  1030
1  1031	0360  E8 FE77			 call clear_tmp_res
1  1032
1  1033					 ; инициализация указателей
1  1034	0363  BF 014Dr			 mov di, offset	tmp_res
1  1035	0366  BE 01C8r			 mov si, offset	mul_array
1  1036
1  1037	0369  8A 0C			 mov cl, [si]	      ;	инициализация счетчика элементов	    +
   1038				     массива
1  1039	036B  46			 inc si		      ;	двигаем указатель на первое		    +
   1040				     произведение
1  1041
1  1042	036C				 .sum_mul_cycle:
1  1043	036C  E8 FF45			     call sum_values  ;	результат сложения				    +
   1044				     двоично-десятичных чисел из si и di в tmp_res
1  1045	036F  83 C6 0A			     add si, 10
1  1046	0372  E2 F8			     loop .sum_mul_cycle
1  1047	0374  59			 pop cx
1  1048	0375  5E			 pop si
1  1049	0376  5F			 pop di
1  1050	0377  C3			 ret
1  1051	0378			     sum_mul_array endp
1  1052
1  1053	0378			     result_to_string proc
1  1054					 ; Процедура для наполнения буфера res_str символами   +
   1055				     численного результата (модуля)
1  1056					 ; подразумевается что буфер tmp_res содержит		    +
   1057				     результат	вычисления суммы	попарных (разделенных    +
   1058				     по знаку)
1  1059					 ; произведений введенных чисел
1  1060	0378  56			 push si ; используется как указатель на tmp_res
1  1061	0379  57			 push di ; используется как указатель на res_str
1  1062	037A  50			 push ax ; используется как промежуточная переменная  +
   1063				     для обработки символа
1  1064	037B  51			 push cx ; счетчик обработанных символов (байт)
1  1065
1  1066					 ; очистка регистров
1  1067	037C  33 F6			 xor si, si
1  1068	037E  33 FF			 xor di, di
1  1069	0380  33 C0			 xor ax, ax
1  1070	0382  33 C9			 xor cx, cx
1  1071
1  1072	0384  BE 014Dr			 mov si, offset	tmp_res
1  1073	0387  BF 016Br			 mov di, offset	res_str	+ 1    ; пропускаем первый байт - символ  +
   1074				     '-'
1  1075	038A  B9 000A			 mov cx, 10
1  1076
1  1077	038D				 .del_zeros:
1  1078	038D  83 F9 01			     cmp cx, 1
1  1079	0390  74 0A			     je	.true_num_cycle
1  1080	0392  8A 04			     mov al, [si]
1  1081	0394  3C 00			     cmp al, 0
1  1082	0396  75 04			     jne .true_num_cycle
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 20
main.asm



1  1083	0398  49			     dec cx
1  1084	0399  46			     inc si
1  1085	039A  EB F1			     jmp .del_zeros
1  1086	039C				 .true_num_cycle:
1  1087	039C  8A 04			     mov al, [si]
1  1088	039E  04 30			     add al, 30h
1  1089	03A0  88 05			     mov [di], al
1  1090	03A2  47			     inc di
1  1091	03A3  46			     inc si
1  1092	03A4  E2 F6			     loop .true_num_cycle
1  1093					 ; проверка на 0 (добавляем минус если результат не  +
   1094				     равен	нулю)
1  1095	03A6  BF 016Ar			 mov di, offset	res_str
1  1096	03A9  8B 1D			 mov bx, [di]
1  1097	03AB  80 FF 30			 cmp bh, 30h
1  1098	03AE  75 0A			 jne .add_neg
1  1099					 ; если результат равен 0
1  1100	03B0  C6 05 30			 mov [di], byte	ptr 30h	; первый байт	0
1  1101	03B3  47			 inc di
1  1102	03B4  C6 05 24			 mov [di], byte	ptr '$'	; второй байт	символ завершения	    +
   1103				     строки
1  1104	03B7  EB 04 90			 jmp .end_res_to_str
1  1105	03BA			     .add_neg:
1  1106	03BA  C6 05 2D			 mov [di], byte	ptr '-'
1  1107	03BD			     .end_res_to_str:
1  1108	03BD  59			 pop cx
1  1109	03BE  58			 pop ax
1  1110	03BF  5F			 pop di
1  1111	03C0  5E			 pop si
1  1112	03C1  C3			 ret
1  1113
1  1114	03C2			     result_to_string endp
1  1115
   1116
   1117	0000			     .stack
   1118	03C2  0100*(??)			 db 100h dup(?)
   1119
   1120				     end start
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 21
Symbol Table




Symbol Name			  Type	 Value

.ADD_CYCLE			  Near	 _TEXT:030A
.ADD_NEG			  Near	 _TEXT:03BA
.ADD_VALUE_EXIT			  Near	 _TEXT:01D6
.CLEAR_CYCLE			  Near	 _TEXT:01E2
.CONTINUE			  Near	 _TEXT:0182
.CONVERT_LOOP			  Near	 _TEXT:0335
.CONV_CONT			  Near	 _TEXT:034D
.CONV_END			  Near	 _TEXT:0354
.COPY_LOOP			  Near	 _TEXT:0240
.CORRECT_INPUT			  Near	 _TEXT:0089
.CORR_END			  Near	 _TEXT:0192
.COUNTER_INITIALIZED		  Near	 _TEXT:021D
.CYCLE				  Near	 _TEXT:02A1
.DEL_ZEROS			  Near	 _TEXT:038D
.END_PROGRAM			  Near	 _TEXT:00E1
.END_RANGE			  Near	 _TEXT:0174
.END_RES_TO_STR			  Near	 _TEXT:03BD
.ERROR				  Near	 _TEXT:018D
.INPUT				  Near	 _TEXT:0020
.IS_NUM_CYCLE			  Near	 _TEXT:0123
.MAX_DIGITS_CHECK		  Near	 _TEXT:0137
.MUL_EXIT			  Near	 _TEXT:031A
.NEGATIVE			  Near	 _TEXT:0180
.NEG_CYCLE			  Near	 _TEXT:01B7
.NEG_START			  Near	 _TEXT:0142
.NOT_EMPTY			  Near	 _TEXT:0057
.NOT_EXIT			  Near	 _TEXT:006F
.NO_MUL				  Near	 _TEXT:0315
.NO_MUL_FLAG			  Near	 _TEXT:023D
.NO_PAIRS_ERR			  Near	 _TEXT:00D6
.NULL_FILLING			  Near	 _TEXT:0294
.POSITIVE			  Near	 _TEXT:0290
.POS_CYCLE			  Near	 _TEXT:01CE
.POS_LOWER			  Near	 _TEXT:021B
.POS_NUM			  Near	 _TEXT:01C2
.POS_START			  Near	 _TEXT:0152
.PROD_LOOP			  Near	 _TEXT:0229
.RANGE_CYCLE			  Near	 _TEXT:015F
.RANK_MUL			  Near	 _TEXT:0343
.RETRY				  Near	 _TEXT:002E
.SUM_CYCLE			  Near	 _TEXT:02C7
.SUM_MUL_CYCLE			  Near	 _TEXT:036C
.TRUE_NUM_CYCLE			  Near	 _TEXT:039C
.ZERO_ARRAY			  Near	 _TEXT:0252
.ZERO_RANK			  Near	 _TEXT:0350
??DATE				  Text	 "01/28/24"
??FILENAME			  Text	 "main	  "
??TIME				  Text	 "21:06:30"
??VERSION			  Number 0205
@CODE				  Text	 _TEXT
@CODESIZE			  Text	 0
@CPU				  Text	 0101H
@CURSEG				  Text	 _TEXT
@DATA				  Text	 DGROUP
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 22
Symbol Table



@DATASIZE			  Text	 0
@FILENAME			  Text	 MAIN
@MODEL				  Text	 2
@WORDSIZE			  Text	 2
ADD_VALUE			  Near	 _TEXT:0199
CARRET				  Byte	 DGROUP:014B
CLEAR_TMP_RES			  Near	 _TEXT:01DA
EMPTY_MESS			  Byte	 DGROUP:009C
ERR_FLAG			  Byte	 DGROUP:01F2
ERR_MESS			  Byte	 DGROUP:010A
EXIT_MESS			  Byte	 DGROUP:00EA
FILL_MUL_ARRAY			  Near	 _TEXT:01EB
INPUT_MESS			  Byte	 DGROUP:004A
IN_STR				  Byte	 DGROUP:0162
IS_CORRECT			  Near	 _TEXT:00E8
MAX_NEG_LEN			  Number 0006
MAX_NUM				  Byte	 DGROUP:0000
MAX_POS_LEN			  Number 0005
MUL_ARRAY			  Byte	 DGROUP:01C8
MUL_VALUES			  Near	 _TEXT:02E8
NEGATIVE			  Number 002D
NEG_ARRAY			  Byte	 DGROUP:019F
NEG_FLAG			  Byte	 DGROUP:01F1
NEG_MAX_LAST			  Number 0038
NO_PAIRS_FLAG			  Byte	 DGROUP:01F3
NO_PAIRS_MESS			  Byte	 DGROUP:0118
NUMS_SIZE			  Number 0008
OUTPUT_MESS			  Byte	 DGROUP:0059
POS_ARRAY			  Byte	 DGROUP:0176
POS_MAX_LAST			  Number 0037
RESULT_TO_STRING		  Near	 _TEXT:0378
RES_STR				  Byte	 DGROUP:016A
START				  Near	 _TEXT:0000
START_MESS			  Byte	 DGROUP:0004
SUM_MUL_ARRAY			  Near	 _TEXT:0359
SUM_VALUES			  Near	 _TEXT:02B4
TMP_NUM				  Byte	 DGROUP:0157
TMP_RES				  Byte	 DGROUP:014D
TO_BIN_DECIMAL			  Near	 _TEXT:0260
TO_HEX_DECIMAL			  Near	 _TEXT:0320

Macro Name

EXIT
INPUT
PRINT

Groups & Segments		  Bit Size Align  Combine Class

DGROUP				  Group
  STACK				  16  0400 Para	  Stack	  STACK
  _DATA				  16  01F4 Word	  Public  DATA
_TEXT				  16  04C2 Word	  Public  CODE
Turbo Assembler	 Version 2.51	     01/28/24 21:06:31	    Page 23
Error Summary



*Warning* func.asm(285)	Argument needs type override
