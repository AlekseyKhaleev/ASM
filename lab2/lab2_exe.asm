;пересылка слов(W) из in_str в out_str 21-ВМз-4 07/12/2023
;слова, не равные '01' ~ 3031h, '23' ~ 3233h, '45' ~ 3435h

d1 segment para public 'data'
; Объявляем строку mess1, которая содержит текст, символы перевода строки (10) и возврата каретки (13),
;и заканчивается символом '$'
mess1 db '21_vmz_4|A_Khaleev Input:',10,13,'$'

; Объявляем строку mess2, которая начинается с символов перевода строки (10) и возврата каретки (13),
;содержит текст 'Output:', затем еще символы перевода строки и возврата каретки, и заканчивается символом '$'
mess2 db 10,13,'Output:',10,13,'$'

; Объявляем массив in_str, состоящий из 22 элементов, каждый из которых инициализируется вопросительным знаком (?),
; что означает, что начальные значения не определены
in_str db 22 dup (?)

; Объявляем массив out_str, состоящий из 22 элементов, каждый из которых инициализируется символом '$'
out_str db 22 dup ('$')

; в ассемблере строка заканчивается символом '$'. Это позволяет функциям ввода/вывода DOS распознавать конец строки
d1 ends

c1 segment para public 'code'
assume cs:c1,ds:d1,ss:st1
start:
;устанавливаем явно сегментный регистр данных:
        mov ax,d1
		mov ds,ax

; приглашение ввода:
        mov dx,offset mess1  ; Загружаем смещение строки mess1 в регистр DX
        mov ah,9             ; Устанавливаем 9 в регистр AH для функции "вывод строки" в прерывании DOS 21h
        int 21h              ; Вызываем прерывание DOS 21h, выводя строку mess1 на экран

; ввод:
        mov dx,offset in_str ; Загружаем смещение строки in_str в регистр DX
        mov in_str, 16       ; Записываем 16 в первый байт in_str, ограничивая ввод 16 байтами
        mov ah,10            ; Устанавливаем 10 в регистр AH для функции "buffered input" в прерывании DOS 21h
        int 21h              ; Вызываем прерывание DOS 21h, читая введенные данные в буфер in_str

;основная часть (модифицированный код из ЛР1):
		mov si,offset in_str+2 ; первые 2 байта служебные
		mov di,offset out_str
		xor ah, ah  ; Очистка старшего байта ax
		mov al,in_str+1 ; помещаем в al количество введенных байт символов
		xor dx, dx ; Очистка dx перед div, так как div использует dx:ax
        mov bl, 2  ; Делитель
        div bl     ; ax/bl -> результат в al, остаток в ah
        mov cl, al ; так как оперируем словами данных в регистр счетчика записываем значение деленное на 2
        test ah, ah ; Проверка, есть ли остаток
        jz noRemainder ; Если остатка нет, переход к метке noRemainder
        inc cl      ; Если был остаток, увеличиваем cl на 1
noRemainder:
        ; Здесь cl содержит количество слов, учитывая нечетное количество байт
		xor ch,ch ; очистка старшего байта счетчика
cmp_cycle:
        mov ax,[si]  ; помещаем первое считанное слово в ax (байты переставлены)
        xchg ah, al  ; обменять местами старший и младший байты
		cmp ax,3031h ; 3031h ~ '01'
		je cmp_true  ; если равно - пропуск
		cmp ax,3233h ; 3233h ~ '23'
		je cmp_true  ; если равно - пропуск
		cmp ax,3435h ; 3435h ~ '45'
		je cmp_true  ; если равно - пропуск
        xchg ah, al  ; обменять местами старший и младший байты
		mov [di], ax ; запись в выходной массив
		add di, 2    ; увеличиваем выходной указатель на 2 (работаем со словами)
cmp_true:
        add si, 2    ; увеличиваем входной указатель на 2 (работаем со словами)
		loop cmp_cycle ; пока регистр счетчика не равен 0 выполняем цикл cmp_cycle

; вывод результата:
        mov dx,offset mess2  ; Загружаем смещение строки mess2 в регистр DX
        mov ah,9  ; Загружаем 9 в регистр AH, что соответствует функции "вывод строки" в прерывании DOS 21h
        int 21h   ; Вызываем DOS interrupt 21h, что выводит строку mess2 на экран

        mov dx,offset out_str  ; Загружаем смещение строки out_str в регистр DX
        mov ah,9  ; Загружаем 9 в регистр AH, что соответствует функции "вывод строки" в прерывании DOS 21h
        int 21h   ; Вызываем DOS interrupt 21h, что выводит строку out_str на экран

; задержка (ожидание нажатия клавиши):
        mov ah,7  ; Устанавливаем 7 в AH, что соответствует функции "ввод без эха" в прерывании DOS 21h
        int 21h   ; Вызываем DOS interrupt 21h, что позволяет программе ожидать нажатия клавиши пользователем

; завершение:
        mov ax,4c00h  ; Загружаем 4C00h в AX, что соответствует функции "завершение программы" в прерывании DOS 21h
        int 21h   ; Вызываем прерывание DOS 21h, что приводит к завершению программы
c1 ends

st1 segment para stack 'stack'
	    dw 100 dup (?) ; Резервирование памяти под 100 слов (200 байт) для стека. Инициализируются неопределенными значениями
st1 ends

end start
