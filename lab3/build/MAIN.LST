Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 1
main.asm



      1				     .8086
      2	0000			     .MODEL SMALL
      3
      4				     include macros.asm
1     5
1     6				     print macro text ;вывод сообщений на экран
1     7					     push ax
1     8					     push dx
1     9					     mov dx,offset text
1    10					     mov ah,9
1    11					     int 21h
1    12					     pop dx
1    13					     pop ax
1    14				     endm
1    15
1    16				     input macro text ;ввод	строки символов
1    17					 ; сохранение	состояния в стеке
1    18					     push ax
1    19					     push dx
1    20					     push bx
1    21					 ; запись	ввода в буфер text
1    22				     .retry:
1    23					 ; вызов функции ввода	21го прерывания
1    24					     mov dx,offset text
1    25					     mov ah,0ah
1    26					     int 21h
1    27
1    28					     inc dx ; передвигаем указатель	на байт,			    +
     29				     соответствующий количеству введенных символов
1    30					     mov bx, dx
1    31					     mov bl, [bx] ; количество введенных символов
1    32					     cmp bl, 0h	  ; проверка на пустую строку
1    33					     jne .not_empty
1    34					     print empty_mess
1    35					 print input_mess
1    36					 jmp .retry
1    37
1    38				     .not_empty:
1    39					 mov bx, dx
1    40					     inc bx
1    41					     mov bl, [bx] ; первый введенный символ
1    42					     cmp bl, 18h  ; проверка на ввод ctrl+x (= выход)
1    43					     jne .not_exit
1    44					     print exit_mess
1    45					     jmp .end_program
1    46				     .not_exit:
1    47					     ; возврат состояния из стека
1    48					 pop bx
1    49					     pop dx
1    50					     pop ax
1    51				     endm
1    52
1    53				     exit macro
1    54					 ; завершение	программы
1    55					 mov ah, 4ch
1    56					 mov al, 0
1    57					 int 21h
Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 2
main.asm



1    58					 ret
1    59				     endm
     60				     include data.asm
1    61	0000			     .data
1    62	      =	002D			 NEGATIVE	  equ 2Dh ; шестнадцатеричный ascii код знака '-'
1    63	      =	0008			 NUMS_SIZE	  equ 8h  ; количество вводимых чисел
1    64	      =	0005			 MAX_POS_LEN	  equ 5h  ; максимальная длина	положительного+
     65				     числа
1    66	      =	0006			 MAX_NEG_LEN	  equ 6h  ; максимальная длина	отрицательного+
     67				     числа	с учетом	знака
1    68	      =	0037			 POS_MAX_LAST	  equ 37h ; младший разряд	верхнего		    +
     69				     ограничения (ascii, hex)
1    70	      =	0038			 NEG_MAX_LAST	  equ 38h ; младший разряд	нижнего			    +
     71				     ограничения (ascii, hex)
1    72	0000  33 32 37 36		 MAX_NUM    db '3276' ;	старшие разряды модуля			    +
     73				     максимального	числа без последнего разряда
1    74
1    75					 ; текстовые переменные для вывода
1    76	0004  49 6E 70 75 74 3A	20+	 start_mess db 'Input: 8 numbers in [-32768, 32767]', 10, 'Press <Enter> after each number',+
     77	      38 20 6E 75 6D 62	65+  10,13,'$'
     78	      72 73 20 69 6E 20	5B+
     79	      2D 33 32 37 36 38	2C+
     80	      20 33 32 37 36 37	5D+
     81	      0A 50 72 65 73 73	20+
     82	      3C 45 6E 74 65 72	3E+
     83	      20 61 66 74 65 72	20+
     84	      65 61 63 68 20 6E	75+
     85	      6D 62 65 72 0A 0D	24
1    86	004A  45 6E 74 65 72 20	6E+	 input_mess db 'Enter number: $'
     87	      75 6D 62 65 72 3A	20+
     88	      24
1    89	0059  6F 75 74 70 75 74	20+	 output_mess db	'output	(sum of	pairwise products of numbers of	different signs):', 10,	13, +
     90	      28 73 75 6D 20 6F	66+  '$'
     91	      20 70 61 69 72 77	69+
     92	      73 65 20 70 72 6F	64+
     93	      75 63 74 73 20 6F	66+
     94	      20 6E 75 6D 62 65	72+
     95	      73 20 6F 66 20 64	69+
     96	      66 66 65 72 65 6E	74+
     97	      20 73 69 67 6E 73	29+
     98	      3A 0A 0D 24
1    99	009C  49 6E 70 75 74 20	45+	 empty_mess db 'Input Error: empty string. Try again or	use ctrl+x and press enter for	    +
    100	      72 72 6F 72 3A 20	65+  exit.', 10, '$'
    101	      6D 70 74 79 20 73	74+
    102	      72 69 6E 67 2E 20	54+
    103	      72 79 20 61 67 61	69+
    104	      6E 20 6F 72 20 75	73+
    105	      65 20 63 74 72 6C	2B+
    106	      78 20 61 6E 64 20	70+
    107	      72 65 73 73 20 65	6E+
    108	      74 65 72 20 66 6F	72+
    109	      20 65 78 69 74 2E	0A+
    110	      24
1   111	00EA  50 72 6F 67 72 61	6D+	 exit_mess  db 'Program	was aborted by keybord', 10, '$'
    112	      20 77 61 73 20 61	62+
    113	      6F 72 74 65 64 20	62+
    114	      79 20 6B 65 79 62	6F+
Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 3
main.asm



    115	      72 64 0A 24
1   116	010A  49 6E 70 75 74 20	65+	 err_mess   db 'Input error!', 10, '$'
    117	      72 72 6F 72 21 0A	24
1   118	0118  0A 24			 carret	    db 10, '$'
1   119
1   120					 ; буферные переменные
1   121	011A  0A*(00)			 tmp_res    db 10 dup(0)	  ; переменная для	промежуточного+
    122				     сохранения результата сложения/умножения
1   123									  ; двух десяти-разрядных		    +
    124				     беззнаковых двоично-десятичных	чисел
1   125	0124  00 0A*(??)		 tmp_num    db 0, 10 dup(?)	  ; переменная для	промежуточного+
    126				     сохранения двоично-десятичного	представления числа
1   127									  ; первый байт tmp_num - знаковый,
1   128									  ; все операции над 10 разрядными  +
    129				     двоично-десятичными числами (с незначащими нулями)
1   130	012F  07 ?? 06*(??)		 in_str	    db 7, ?, 6 dup (?)	    ; буфер ввода 1 байт размер	    +
    131				     буфера, второй	-количество введенных символов
1   132	0137  0C*(24)			 res_str    db 12 dup ('$')	  ; буфер для преобразования	    +
    133				     результата в строку
1   134									  ; (произведения разных знаков, а +
    135				     также	их последующие суммы всегда отрицательны)
1   136
1   137					 ; массивы, первый	байт в массиве для учета		    +
    138				     количества записанных чисел
1   139	0143  00 04*(0A*(??))		 pos_array  db 0, 4 dup(10 dup(?)) ; массив для пяти модулей	    +
    140				     положительных	двоично-десятичных чисел размером	5   +
    141				     байт
1   142	016C  00 04*(0A*(??))		 neg_array  db 0, 4 dup(10 dup(?)) ; массив для пяти модулей	    +
    143				     отрицательных	двоично-десятичных чисел размером	5   +
    144				     байт
1   145	0195  00 04*(0A*(??))		 mul_array  db 0, 4 dup(10 dup(?)) ; массив модулей поэлементных   +
    146				     произведений массивов
1   147
1   148					 ; флаги
1   149	01BE  00			 neg_flag   db 0     ; флаг	наличия знака '-' для is_correct	proc
1   150	01BF  00			 err_flag   db 0     ; флаг	ошибки во вводе для is_correct		    +
    151				     proc/цикла ввода
1   152
1   153
    154
    155	01C0			     .code
    156	0000			     start:
    157					; инициализация памяти
    158	0000  B8 0000s			 mov ax, @data
    159	0003  8E D8			 mov ds, ax
    160
    161					 ;вызов функции 0 -	 установка 3 текстового		    +
    162				     видеорежима, очистка экрана
    163	0005  B8 0003			 mov ax, 0003  ; ah=0 (номер функции), al=3	(номер режима)
    164	0008  CD 10			 int 10h
    165
    166					 print start_mess  ; вывод	стартового сообщения
1   167	000A  50			     push ax
1   168	000B  52			     push dx
1   169	000C  BA 0004r			     mov dx,offset start_mess
1   170	000F  B4 09			     mov ah,9
1   171	0011  CD 21			     int 21h
Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 4
main.asm



1   172	0013  5A			     pop dx
1   173	0014  58			     pop ax
    174	0015  33 C9			 xor cx, cx
    175	0017  B9 0008			 mov cx, NUMS_SIZE ; в	cx количество	чисел для ввода		    +
    176				     пользователем
    177
    178					 ; инициализация указателей на	первые элементы	    +
    179				     массивов без учета	размерного байта	(используется в+
    180				     add_value proc)
    181	001A  BE 0144r			 mov si, offset	pos_array + 1
    182	001D  BF 016Dr			 mov di, offset	neg_array + 1
    183
    184					 ; цикл ввода/проверки/распределения по	массивам
    185	0020				 .input:
    186					     print input_mess  ;вывод сообщения о вводе строки
1   187	0020  50			     push ax
1   188	0021  52			     push dx
1   189	0022  BA 004Ar			     mov dx,offset input_mess
1   190	0025  B4 09			     mov ah,9
1   191	0027  CD 21			     int 21h
1   192	0029  5A			     pop dx
1   193	002A  58			     pop ax
    194					     input in_str      ;ввод числа в виде	строки
1   195	002B  50			     push ax
1   196	002C  52			     push dx
1   197	002D  53			     push bx
1   198	002E			     .retry:
1   199	002E  BA 012Fr			     mov dx,offset in_str
1   200	0031  B4 0A			     mov ah,0ah
1   201	0033  CD 21			     int 21h
1   202	0035  42			     inc dx ; передвигаем указатель	на байт,			    +
    203				     соответствующий количеству введенных символов
1   204	0036  8B DA			     mov bx, dx
1   205	0038  8A 1F			     mov bl, [bx] ; количество введенных символов
1   206	003A  80 FB 00			     cmp bl, 0h	  ; проверка на пустую строку
1   207	003D  75 18			     jne .not_empty
1   208					     print empty_mess
2   209	003F  50			     push ax
2   210	0040  52			     push dx
2   211	0041  BA 009Cr			     mov dx,offset empty_mess
2   212	0044  B4 09			     mov ah,9
2   213	0046  CD 21			     int 21h
2   214	0048  5A			     pop dx
2   215	0049  58			     pop ax
1   216					 print input_mess
2   217	004A  50			     push ax
2   218	004B  52			     push dx
2   219	004C  BA 004Ar			     mov dx,offset input_mess
2   220	004F  B4 09			     mov ah,9
2   221	0051  CD 21			     int 21h
2   222	0053  5A			     pop dx
2   223	0054  58			     pop ax
1   224	0055  EB D7			 jmp .retry
1   225	0057			     .not_empty:
1   226	0057  8B DA			 mov bx, dx
1   227	0059  43			     inc bx
1   228	005A  8A 1F			     mov bl, [bx] ; первый введенный символ
Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 5
main.asm



1   229	005C  80 FB 18			     cmp bl, 18h  ; проверка на ввод ctrl+x (= выход)
1   230	005F  75 0E			     jne .not_exit
1   231					     print exit_mess
2   232	0061  50			     push ax
2   233	0062  52			     push dx
2   234	0063  BA 00EAr			     mov dx,offset exit_mess
2   235	0066  B4 09			     mov ah,9
2   236	0068  CD 21			     int 21h
2   237	006A  5A			     pop dx
2   238	006B  58			     pop ax
1   239	006C  EB 58 90			     jmp .end_program
1   240	006F			     .not_exit:
1   241	006F  5B			 pop bx
1   242	0070  5A			     pop dx
1   243	0071  58			     pop ax
    244
    245					     ; проверки, заполнение массивов
    246	0072  E8 0058			     call is_correct   ; проверка на корректность	символов    +
    247				     числа, установка err_flag
    248	0075  80 3E 01BFr 00		     cmp err_flag, 0
    249	007A  74 0D			     je	.correct_input
    250
    251					     ; если	была ошибка вывод сообщения и			    +
    252				     циклический ввод
    253					     print err_mess
1   254	007C  50			     push ax
1   255	007D  52			     push dx
1   256	007E  BA 010Ar			     mov dx,offset err_mess
1   257	0081  B4 09			     mov ah,9
1   258	0083  CD 21			     int 21h
1   259	0085  5A			     pop dx
1   260	0086  58			     pop ax
    261	0087  EB 97			     jmp .input
    262
    263	0089				 .correct_input:
    264	0089  E8 01A9			     call to_bin_decimal  ; преобразование in_str	к			    +
    265				     двоично-десятичному виду в tmp_num (с незначащими	    +
    266				     нулями и байтом знака)
    267	008C  E8 00EF			     call add_value	  ; копирование модуля	из tmp_num в		    +
    268				     соответствующий массив
    269					     print carret	  ; печать переноса строки
1   270	008F  50			     push ax
1   271	0090  52			     push dx
1   272	0091  BA 0118r			     mov dx,offset carret
1   273	0094  B4 09			     mov ah,9
1   274	0096  CD 21			     int 21h
1   275	0098  5A			     pop dx
1   276	0099  58			     pop ax
    277	009A  E2 84			     loop .input	  ; цикл ввода
    278
    279					 ; здесь массивы pos_array и neg_array заполнены модулями	    +
    280				     соответствующих по знаку введенных чисел
    281	009C  E8 0131			 call fill_mul_array
    282	009F  E8 028C			 call sum_mul_array
    283	00A2  E8 02A8			 call result_to_string
    284					 print output_mess
1   285	00A5  50			     push ax
Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 6
main.asm



1   286	00A6  52			     push dx
1   287	00A7  BA 0059r			     mov dx,offset output_mess
1   288	00AA  B4 09			     mov ah,9
1   289	00AC  CD 21			     int 21h
1   290	00AE  5A			     pop dx
1   291	00AF  58			     pop ax
    292					 print res_str
1   293	00B0  50			     push ax
1   294	00B1  52			     push dx
1   295	00B2  BA 0137r			     mov dx,offset res_str
1   296	00B5  B4 09			     mov ah,9
1   297	00B7  CD 21			     int 21h
1   298	00B9  5A			     pop dx
1   299	00BA  58			     pop ax
    300					 print carret
1   301	00BB  50			     push ax
1   302	00BC  52			     push dx
1   303	00BD  BA 0118r			     mov dx,offset carret
1   304	00C0  B4 09			     mov ah,9
1   305	00C2  CD 21			     int 21h
1   306	00C4  5A			     pop dx
1   307	00C5  58			     pop ax
    308
    309	00C6			     .end_program:
    310					 exit ;	завершение программы
1   311	00C6  B4 4C			 mov ah, 4ch
1   312	00C8  B0 00			 mov al, 0
1   313	00CA  CD 21			 int 21h
1   314	00CC  C3			 ret
    315
    316				     include func.asm
1   317
1   318	00CD			     is_correct	proc
1   319					 ; Процедура для проверки корректности введенного +
    320				     числа
1   321					 ; число должно быть записано в	буфер in_str
1   322					 ; корректный	диапазон - [-32768, 32767]
1   323
1   324					 ; сохраняем состояние регистров
1   325	00CD  50			 push ax ; используется для хранения текущего символа
1   326	00CE  53			 push bx ; используется для хранения индекса в		    +
    327				     диапазоне	(проход по константе MAX_NUM)
1   328	00CF  51			 push cx ; используется для хранения количества	    +
    329				     обработанных символов числа
1   330	00D0  52			 push dx ; используется для хранения последнего	    +
    331				     символа диапазона в зависимости от знака
1   332	00D1  56			 push si ; используется для хранения индекса в буфере  +
    333				     ввода
1   334	00D2  57			 push di ; используется для хранения количества	    +
    335				     введенных	символов во входном буфере
1   336
1   337					 ; очистка используемых регистров
1   338	00D3  33 C0			 xor ax, ax
1   339	00D5  33 DB			 xor bx, bx
1   340	00D7  33 C9			 xor cx, cx
1   341	00D9  33 D2			 xor dx, dx
1   342	00DB  33 F6			 xor si, si
Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 7
main.asm



1   343	00DD  33 FF			 xor di, di
1   344
1   345					 ; инициализация di количеством	символов во входном+
    346				     буфере
1   347	00DF  BF 012Fr			 mov di, offset	in_str ; помещаем в di	адрес буфера	ввода
1   348	00E2  47			 inc di		 ; перемещаем	на количество символов	    +
    349				     записанных в буфер
1   350	00E3  8B 3D			 mov di, [di]	 ; загружаем 2	первых байта	из in_str в di
1   351	00E5  81 E7 00FF		 and di, 00FFh	 ; очищаем старший байт
1   352
1   353					 ; начальная инициализация
1   354	00E9  C6 06 01BEr 00		 mov neg_flag, 0 ; очистка флага для хранения знака	числа
1   355	00EE  C6 06 01BFr 00		 mov err_flag, 0 ; очистка флага для определения ошибки	    +
    356				     ввода
1   357	00F3  BE 0002			 mov si, 2	 ; Инициализация индекса числа	(пропуск	    +
    358				     служебных	байтов буфера)
1   359	00F6  BB 0000			 mov bx, 0	 ; Инициализация индекса для			    +
    360				     максимального	диапазона
1   361
1   362	00F9  8A 84 012Fr		 mov al, in_str[si]; Загрузка текущего элемента	буфера в	AL
1   363	00FD  3C 2D			 cmp al, NEGATIVE  ; Является ли первый	символ знаком '-'
1   364	00FF  75 07			 jne .is_num_cycle
1   365	0101  C6 06 01BEr 01		 mov neg_flag, 1   ; установка	флага отрицательного	числа
1   366	0106  46			 inc si		   ; перемещаем указатель в	буфере на	    +
    367				     следующий	байт (символ)
1   368	0107  41			 inc cx		   ; увеличиваем счетчик обработанных	    +
    369				     чисел
1   370
1   371					 ; проверка: является ли числом	каждый введенный	    +
    372				     символ символ (исключая первый минус)
1   373	0108				 .is_num_cycle:
1   374	0108  3B CF			     cmp cx, di		  ; если все символы обработаны
1   375	010A  74 10			     je	.max_digits_check ; выход из цикла
1   376	010C  8A 84 012Fr		     mov al, in_str[si]	  ; в al очередной ascii код ввода
1   377	0110  3C 30			     cmp al, 30h	  ; 30h	- ascii	код для числа 0, если меньше - +
    378				     ошибка ввода
1   379	0112  7C 5E			     jl	.error
1   380	0114  3C 39			     cmp al, 39h	  ; 39h	- ascii	код для числа 9, если меньше - +
    381				     ошибка ввода
1   382	0116  7F 5A			     jg	.error
1   383	0118  41			     inc cx		  ; увеличиваем счетчик
1   384	0119  46			     inc si		  ; двигаем указатель
1   385	011A  EB EC			     jmp .is_num_cycle	  ; повторяем цикл
1   386
1   387
1   388	011C				 .max_digits_check:
1   389					     ; очистка регистров
1   390	011C  33 C9			     xor cx, cx
1   391	011E  33 F6			     xor si, si
1   392
1   393	0120  80 3E 01BEr 00		     cmp neg_flag, 0	 ; проверка знака числа
1   394	0125  74 10			     je	.pos_start
1   395
1   396					     ; для отрицательных:
1   397	0127				     .neg_start:
1   398	0127  83 FF 06				 cmp di, MAX_NEG_LEN ; сравнение количества введенных   +
    399				     символов и максимального количества разрядов
Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 8
main.asm



1   400	012A  7C 4B				 jl .corr_end	     ; если	меньше, завершаем без	ошибки
1   401	012C  7F 44				 jg .error	     ; если	больше завершаем	с ошибкой
1   402						 ; если равно,	инициализация и переход к		    +
    403				     поразрядной проверке
1   404	012E  BE 0003				 mov si, 3
1   405	0131  B9 0002				 mov cx, 2	      ;	значение больше на 1 чем		    +
    406				     действительное чтобы выйти	из range_cycle раньше на 1	    +
    407				     символ
1   408	0134  EB 0E 90				 jmp .range_cycle
1   409
1   410					     ; для положительных
1   411	0137				     .pos_start:
1   412	0137  83 FF 05				 cmp di, MAX_POS_LEN ; сравнение количества введенных   +
    413				     символов и максимального количества разрядов
1   414	013A  7C 3B				 jl .corr_end	     ; если	меньше, завершаем без	ошибки
1   415	013C  7F 34				 jg .error
1   416						 ; если равно,	инициализация и переход к		    +
    417				     поразрядной проверке
1   418	013E  BE 0002				 mov si, 2
1   419	0141  B9 0001				 mov cx, 1
1   420
1   421					     ; поразрядная проверка диапазона если		    +
    422				     количество символов модуля	равно 5
1   423	0144				     .range_cycle:
1   424	0144  8A 84 012Fr			 mov al, in_str[si] ; Загрузка текущего	элемента	    +
    425				     буфера в AL
1   426	0148  3A 87 0000r			 cmp al, MAX_NUM[bx]
1   427	014C  7F 24				 jg .error
1   428	014E  7C 27				 jl .corr_end
1   429						 ; если символ равен ограничению:
1   430	0150  46				 inc si		   ; Увеличение индекса числа
1   431	0151  41				 inc cx		   ; Увеличение счетчика обработанных +
    432				     цифр
1   433	0152  43				 inc bx		   ; Увеличение индекса в строке	    +
    434				     содержащей максимальные цифры диапазона
1   435	0153  3B CF				 cmp cx, di	   ; Проверка, достигнут ли конец	    +
    436				     буфера
1   437	0155  74 02				 je .end_range	   ; Если да, прерывание цикла
1   438	0157  EB EB				 jmp .range_cycle  ; Переход на следующую итерацию	    +
    439				     цикла
1   440
1   441					     ; проверка	последнего символа если число		    +
    442				     значащих цифр равно максимальному
1   443	0159				     .end_range:
1   444	0159  80 3E 01BEr 01			 cmp neg_flag, 1
1   445	015E  74 05				 je .negative
1   446	0160  B2 37				 mov dl, POS_MAX_LAST
1   447	0162  EB 03 90				 jmp .continue
1   448	0165				     .negative:
1   449	0165  B2 38				 mov dl, NEG_MAX_LAST
1   450	0167				     .continue:
1   451	0167  8A 84 012Fr			 mov al, in_str[si] ; загружаем последний символ
1   452	016B  3A C2				 cmp al, dl
1   453	016D  7F 03				 jg .error	    ; если есть	выход за	границу		    +
    454				     диапазона	переход к ошибке
1   455	016F  EB 06 90				 jmp .corr_end
1   456
Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 9
main.asm



1   457					 ; завершение	с ошибкой
1   458	0172				 .error:
1   459	0172  C6 06 01BFr 01		     mov err_flag, 1	  ; установка флага ошибки
1   460
1   461					 ; завершение	без ошибки
1   462	0177				 .corr_end:
1   463					     ; восстанавливаем состояние из стека
1   464	0177  5F			     pop di
1   465	0178  5E			     pop si
1   466	0179  5A			     pop dx
1   467	017A  59			     pop cx
1   468	017B  5B			     pop bx
1   469	017C  58			     pop ax
1   470	017D  C3			     ret
1   471
1   472	017E			     is_correct	endp
1   473
1   474	017E			     add_value proc
1   475					 ; Процедура для копирования числа из временной	    +
    476				     переменной в соответствующий массив
1   477					 ; число представлено в двоично-десятичном виде с   +
    478				     незначащими нулями (размер на выходе 5 байт)
1   479					 ; в массивы записываем только модули, увеличиваем +
    480				     количество записанных чисел
1   481					 ; в si адрес очередного элемента в массиве		    +
    482				     положительных	чисел
1   483					 ; в di адрес очередного элемента в массиве		    +
    484				     отрицательных	чисел
1   485					 ; в tmp_num значение очередного введенного и		    +
    486				     преобразованного числа которое	нужно скопировать
1   487
1   488	017E  50			 push ax ; используется для увеличения	счетчика	    +
    489				     записанных чисел в	массиве и копирования очередной +
    490				     цифры(байта) числа
1   491	017F  53			 push bx ; используется как указатель на tmp_num
1   492	0180  51			 push cx ; счетчик элементов числа	для цикла,		    +
    493				     инициализируется числом 5 (количеством байт в	    +
    494				     каждом числе)
1   495
1   496					 ; инициализация счетчика
1   497	0181  33 C9			 xor cx, cx
1   498	0183  B9 000A			 mov cx, 10
1   499
1   500	0186  BB 0124r			 mov bx, offset	tmp_num	; инициализируем указатель на		    +
    501				     временную	переменную
1   502	0189  8A 07			 mov al, [bx]		; в al	байт знака
1   503	018B  43			 inc bx			; перемещаем указатель на первый	    +
    504				     символ
1   505	018C  3C 00			 cmp al, 0		; проверка на						    +
    506				     отрицательное/положительное число
1   507	018E  74 17			 je .pos_num
1   508
1   509					 ; увеличиваем счетчик записанных чисел в массиве  +
    510				     отрицательных	чисел
1   511	0190  A0 016Cr			 mov al, neg_array
1   512	0193  3C 04			 cmp al, 4
1   513	0195  74 24			 je .add_value_exit ; в программе не может быть более	4х пар, +
Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 10
main.asm



    514				     предупреждение выхода за границы массива
1   515	0197  FE C0			 inc al
1   516	0199  A2 016Cr			 mov neg_array,	al
1   517
1   518					 ; по-байтовая запись модуля очередного	числа в	    +
    519				     массив отрицательных чисел
1   520	019C				 .neg_cycle:
1   521	019C  8A 07			     mov al, [bx]
1   522	019E  88 05			     mov [di], al
1   523	01A0  43			     inc bx
1   524	01A1  47			     inc di
1   525	01A2  E2 F8			     loop .neg_cycle
1   526
1   527	01A4  EB 15 90			 jmp .add_value_exit
1   528
1   529	01A7				 .pos_num:
1   530					     ; увеличиваем счетчик записанных чисел в		    +
    531				     массиве положительных (неотрицательных)	чисел
1   532	01A7  A0 0143r			     mov al, pos_array
1   533	01AA  3C 04			     cmp al, 4
1   534	01AC  74 0D			     je	.add_value_exit	; в программе	не может	быть более 4х	    +
    535				     пар, предупреждение выхода за границы массива
1   536	01AE  FE C0			     inc al
1   537	01B0  A2 0143r			     mov pos_array, al
1   538
1   539					 ; по-байтовая запись модуля очередного	числа в	    +
    540				     массив положительных (неотрицательных) чисел
1   541	01B3				 .pos_cycle:
1   542	01B3  8A 07			     mov al, [bx]
1   543	01B5  88 04			     mov [si], al
1   544	01B7  43			     inc bx
1   545	01B8  46			     inc si
1   546	01B9  E2 F8			     loop .pos_cycle
1   547
1   548					 ; возврат состояния
1   549	01BB				 .add_value_exit:
1   550	01BB  59			     pop cx
1   551	01BC  5B			     pop bx
1   552	01BD  58			     pop ax
1   553	01BE  C3			     ret
1   554
1   555	01BF			     add_value endp
1   556
1   557	01BF			     clear_tmp_res proc
1   558	01BF  56			 push si
1   559	01C0  51			 push cx
1   560	01C1  B9 000A			 mov cx, 10
1   561	01C4  BE 011Ar			 mov si, offset	tmp_res
1   562	01C7				 .clear_cycle:
1   563	01C7  C6 04 00			     mov byte ptr [si],	0
1   564	01CA  46			     inc si
1   565	01CB  E2 FA			     loop .clear_cycle
1   566	01CD  59			 pop cx
1   567	01CE  5E			 pop si
1   568
1   569	01CF  C3			 ret
1   570	01D0			     clear_tmp_res endp
Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 11
main.asm



1   571
1   572	01D0			     fill_mul_array proc
1   573					 ; процедура для заполнения массива mul_array		    +
    574				     попарными	произведениями модулей положительных и   +
    575				     отрицательных	чисел
1   576					 ; ожидается что произведен ввод с клавиатуры	    +
    577				     чисел, числа приведены к двоично-десятичному	виду
1   578					 ; массивы pos_array и neg_array заполнены модулями		    +
    579				     положительных	и отрицательных чисел соответственно
1   580
1   581					 ; сохраняем состояние
1   582	01D0  50			 push ax
1   583	01D1  53			 push bx
1   584	01D2  51			 push cx
1   585	01D3  52			 push dx
1   586	01D4  56			 push si
1   587	01D5  57			 push di
1   588
1   589					 ; чистим	регистры
1   590	01D6  33 C0			 xor ax, ax
1   591	01D8  33 DB			 xor bx, bx
1   592	01DA  33 C9			 xor cx, cx
1   593	01DC  33 D2			 xor dx, dx
1   594	01DE  33 F6			 xor si, si
1   595	01E0  33 FF			 xor di, di
1   596
1   597					 ; инициализация счетчика размером	меньшего из	    +
    598				     массивов введенных чисел
1   599	01E2  BB 0143r			 mov bx, offset	pos_array
1   600	01E5  8A 1F			 mov bl, [bx]
1   601	01E7  8A C3			 mov al, bl
1   602	01E9  BB 016Cr			 mov bx, offset	neg_array
1   603	01EC  8A 1F			 mov bl, [bx]
1   604	01EE  3A C3			 cmp al, bl
1   605	01F0  7C 05			 jl .pos_lower
1   606	01F2  8A CB			 mov cl, bl
1   607	01F4  EB 03 90			 jmp .counter_initialized
1   608	01F7			     .pos_lower:
1   609	01F7  8A C8			 mov cl, al
1   610
1   611	01F9			     .counter_initialized:
1   612					 ; инициализация указателей на	массивы с модулями  +
    613				     чисел
1   614	01F9  BE 0144r			 mov si, offset	pos_array + 1
1   615	01FC  BF 016Dr			 mov di, offset	neg_array + 1
1   616
1   617					 ; заполнение	массива mul_array
1   618	01FF  BB 0195r			 mov bx, offset	mul_array
1   619	0202  89 0F			 mov [bx], byte	ptr cx	 ; запись	в массив	mul_array количества	    +
    620				     элементов
1   621	0204  43			 inc bx			 ; двигаем указатель на первый		    +
    622				     результат
1   623	0205				 .prod_loop:
1   624	0205  C6 06 01BFr 00		     mov err_flag, 0
1   625	020A  E8 00B0			     call mul_values ; в tmp_res результат умножения	модулей
1   626	020D  80 3E 01BFr 01		     cmp err_flag, 1
1   627					     ; копируем	результат в массив mul_array
Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 12
main.asm



1   628	0212  51			     push cx
1   629	0213  56			     push si
1   630	0214  74 03			     je	.no_mul_flag
1   631	0216  BE 011Ar			     mov si, offset tmp_res
1   632	0219				 .no_mul_flag:
1   633	0219  B9 000A			     mov cx, 10
1   634	021C				     .copy_loop:
1   635	021C  8A 14				 mov dl, [si]
1   636	021E  88 17				 mov [bx], dl
1   637	0220  46				 inc si
1   638	0221  43				 inc bx
1   639	0222  E2 F8				 loop .copy_loop
1   640	0224  5E			     pop si
1   641	0225  59			     pop cx
1   642					     ; здесь копирование завершено
1   643
1   644					     ; перемещаем указатели к следующим элементам:
1   645	0226  83 C6 0A			     add si, 10
1   646	0229  83 C7 0A			     add di, 10
1   647	022C  E2 D7			     loop .prod_loop
1   648
1   649					 ; восстанавливаем состояние
1   650	022E  5F			 pop di
1   651	022F  5E			 pop si
1   652	0230  5A			 pop dx
1   653	0231  59			 pop cx
1   654	0232  5B			 pop bx
1   655	0233  58			 pop ax
1   656
1   657	0234  C3			 ret	 ; возврат
1   658	0235			     fill_mul_array endp
1   659
1   660
1   661	0235			     to_bin_decimal proc
1   662					 ; Процедура для перевода числа из ascii в десятичное +
    663				     представление
1   664					 ; В выходном массиве первый байт для учета знака (0 +
    665				     неотрицательное(положительное), 1 - отрицательное)
1   666					 ; все числа будут	выровнены по	разрядам (дополнены+
    667				     незначащими нулями)
1   668					 ; В in_str содержится буфер ввода
1   669					 ;   1й байт: размер	буфера
1   670					 ;   2й байт: количество	введенных символов (включая +
    671				     знак минус)
1   672					 ;   с	третьего по предпоследний: ascii	символы		    +
    673				     введенного числа
1   674					 ;   последний	символ завершения ввода - 0Dh
1   675					 ; Результат:
1   676					 ; в буфере tmp_num записано десятичное представление +
    677				     введенного числа,
1   678					 ; первый	байт - знаковый
1   679					 ; так как при	переводе все	разряды заполняются	    +
    680				     новым	байтом знака, цифрами	разряда или незначащими+
    681				     нулями,
1   682					 ; то	предварительная очистка буфера перед новой    +
    683				     записью не требуется
1   684
Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 13
main.asm



1   685					 ; сохранение	состояния
1   686	0235  50			 push ax ; используется для хранения числа 30h и		    +
    687				     использовании	в команде sub
1   688	0236  53			 push bx ; используется для получения ascii-кода		    +
    689				     очередного символа
1   690	0237  51			 push cx ; используется в роли	счетчика обработанных   +
    691				     символов
1   692	0238  52			 push dx ; используется для хранения количества	    +
    693				     незначащих нулей
1   694	0239  57			 push di ; используется для адресации выходного буфера
1   695	023A  56			 push si ; используется для адресации входного буфера
1   696
1   697					 ; предварительная очистка регистров
1   698	023B  33 C0			 xor ax, ax
1   699	023D  33 DB			 xor bx, bx
1   700	023F  33 D2			 xor dx, dx
1   701	0241  33 F6			 xor si, si
1   702	0243  33 FF			 xor di, di
1   703
1   704	0245  BE 012Fr			 mov si, offset	in_str
1   705					 ; начальная инициализация
1   706	0248  B0 30			 mov al, 30h
1   707	024A  BF 0124r			 mov di, offset	tmp_num
1   708
1   709					 ; инициализируем	счетчик числом символов в	строке
1   710	024D  46			 inc si
1   711	024E  8B 0C			 mov cx, [si]
1   712	0250  8A 14			 mov dl, [si] ;	записываем количество символов
1   713	0252  32 ED			 xor ch, ch   ;	чистим старший(лишний) байт
1   714
1   715					 ; двигаем указатель на первый символ во входном	    +
    716				     буфере
1   717	0254  46			 inc si
1   718
1   719					 ; проверка на наличие	символа '-', если			    +
    720				     присутствует, записываем байт знака	в выходной	    +
    721				     буфер
1   722					 ; по	умолчанию байт знака инициализирован нулем,   +
    723				     что соответствует неотрицательному	числу
1   724					 ; и двигаем указатель, если нет прыгаем	к		    +
    725				     основному	циклу обработки
1   726	0255  80 3C 2D			 cmp byte ptr [si], NEGATIVE
1   727	0258  75 0B			     jne .positive
1   728	025A  C6 05 01			     mov [di], byte ptr	1 ; запись знакового байта
1   729	025D  46			     inc si
1   730	025E  49			     dec cx
1   731	025F  FE CA			     dec dl	 ; если был знак минус уменьшаем		    +
    732				     количество символов в буфере на	1
1   733	0261  47			     inc di
1   734	0262  EB 05 90			     jmp .null_filling
1   735	0265				 .positive:
1   736	0265  C6 05 00			     mov [di], byte ptr	0  ; запись знакового байта
1   737	0268  47			     inc di	 ; если число позитивное двигаем		    +
    738				     указатель	выходного буфера	на первый символ
1   739	0269				 .null_filling:	 ; заполнение	незначащими нулями
1   740	0269  80 FA 0A			     cmp dl, 10	 ; все числа десяти разрядные с			    +
    741				     незначащими нулями
Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 14
main.asm



1   742	026C  7D 08			     jge .cycle
1   743	026E  C6 05 00			     mov [di], byte ptr	0
1   744	0271  47			     inc di
1   745	0272  FE C2			     inc dl
1   746	0274  EB F3			     jmp .null_filling
1   747
1   748					 ; основной цикл - получаем	ascii код, вычитаем из него+
    749				     30	(так	как символы 0-9 имеют коды 30-39)
1   750					 ; записываем	в выходной буфер,	двигаем указатели
1   751	0276				 .cycle:
1   752	0276  8B 1C			     mov bx, [si]
1   753	0278  32 FF			     xor bh, bh
1   754	027A  2B D8			     sub bx, ax	   ; в	bl результат вычитания
1   755	027C  88 1D			     mov [di], bl
1   756	027E  47			     inc di
1   757	027F  46			     inc si
1   758	0280  E2 F4			     loop .cycle
1   759
1   760					 ; восстанавливаем исходное состояние регистров
1   761	0282  5E			 pop si
1   762	0283  5F			 pop di
1   763	0284  5A			 pop dx
1   764	0285  59			 pop cx
1   765	0286  5B			 pop bx
1   766	0287  58			 pop ax
1   767
1   768	0288  C3			 ret
1   769
1   770	0289			     to_bin_decimal endp
1   771
1   772	0289			     sum_values	proc
1   773					 ; Процедура для сложения двух неотрицательных	    +
    774				     десяти разрядных двоично-десятичных чисел
1   775					 ; задано	ограничение для числа: |-36768| * |36767| = 1 073 709    +
    776				     056, десять разрядов	защищают от переполнения
1   777					 ; вход:
1   778					 ;     si - адрес первого числа
1   779					 ;     di - адрес второго числа
1   780					 ; результат в tmp_res
1   781
1   782					 ; сохраняем состояние стека
1   783	0289  50			 push ax
1   784	028A  53			 push bx
1   785	028B  51			 push cx
1   786	028C  52			 push dx
1   787	028D  56			 push si
1   788	028E  57			 push di
1   789
1   790					 ; очистка регистров
1   791	028F  33 C0			 xor ax, ax
1   792	0291  33 C9			 xor cx, cx
1   793
1   794	0293  B9 000A			 mov cx, 10 ; инициализируем счетчик - 10 байт	числа = 10	    +
    795				     итераций
1   796
1   797					 ; двигаем указатели на последние разряды (байты)    +
    798				     чисел
Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 15
main.asm



1   799	0296  83 C6 09			 add si, 9
1   800	0299  83 C7 09			 add di, 9
1   801
1   802	029C				 .sum_cycle:
1   803					     ; очистка регистров
1   804	029C  33 DB			     xor bx, bx
1   805	029E  33 D2			     xor dx, dx
1   806
1   807	02A0  02 04			     add al, byte ptr [si] ; добавляем	очередной разряд		    +
    808				     первого числа в al, в ax очередной разряд +			    +
    809				     переполнение
1   810	02A2  8A 1D			     mov bl, byte ptr [di] ; перемещаем очередной разряд	    +
    811				     второго числа в bl
1   812	02A4  03 C3			     add ax, bx		   ; складываем, результат в ax
1   813	02A6  BB 000A			     mov bx, 10		   ; в	bx делитель - 10
1   814	02A9  F7 F3			     div bx		   ; в	ax результат, в dx остаток от	    +
    815				     деления на 10 суммы разрядов	сложенной с			    +
    816				     переполнением
1   817
1   818					     ; инициализируем bx индексом	разряда в		    +
    819				     результирующем буфере (состояние декрементного	    +
    820				     счетчика -	1)
1   821	02AB  8B D9			     mov bx, cx
1   822	02AD  4B			     dec bx
1   823	02AE  88 97 011Ar		     mov tmp_res[bx], dl   ; записываем остаток в разряд	    +
    824				     результата
1   825
1   826					     ; двигаем указатели в слагаемых
1   827	02B2  4E			     dec si
1   828	02B3  4F			     dec di
1   829
1   830	02B4  E2 E6			     loop .sum_cycle	   ; уменьшаем	cx, переходим к следующей+
    831				     итерации
1   832
1   833					 ; восстанавливаем состояние стека
1   834	02B6  5F			 pop di
1   835	02B7  5E			 pop si
1   836	02B8  5A			 pop dx
1   837	02B9  59			 pop cx
1   838	02BA  5B			 pop bx
1   839	02BB  58			 pop ax
1   840
1   841	02BC  C3			 ret
1   842	02BD			     sum_values	endp
1   843
1   844	02BD			     mul_values	proc
1   845					 ; процедура для умножения	двух неотрицательных	    +
    846				     десяти разрядных двоично-десятичных чисел
1   847					 ; в si - адрес первого числа
1   848					 ; в di - адрес второго числа
1   849					 ; результат -	в tmp_res
1   850
1   851	02BD  50			 push ax
1   852	02BE  53			 push bx
1   853	02BF  51			 push cx
1   854	02C0  56			 push si
1   855	02C1  57			 push di
Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 16
main.asm



1   856
1   857	02C2  33 C0			 xor ax, ax
1   858	02C4  33 DB			 xor bx, bx
1   859	02C6  33 C9			 xor cx, cx
1   860
1   861					 ; проверка на ноль в первом числе
1   862	02C8  57			 push di
1   863	02C9  8B FE			 mov di, si
1   864	02CB  E8 0027			 call to_hex_decimal
1   865	02CE  5F			 pop di
1   866	02CF  83 F9 00			 cmp cx, 0
1   867	02D2  74 16			 je .no_mul
1   868
1   869					 ; проверка на 1 во	втором числе
1   870	02D4  E8 001E			 call to_hex_decimal   ; преобразование второго числа	к	    +
    871				     десятичному виду, результат в cx
1   872	02D7  83 F9 01			 cmp cx, 1
1   873	02DA  74 0E			 je .no_mul
1   874
1   875	02DC  49			 dec cx
1   876	02DD  8B FE			 mov di, si	       ; умножение реализуем как сложение num1 +
    877				     с	самим собой num2 - 1 раз
1   878	02DF				 .add_cycle:
1   879	02DF  E8 FFA7			     call sum_values   ; результат сложения				    +
    880				     двоично-десятичных чисел из si и di в tmp_res
1   881	02E2  BE 011Ar			     mov si, offset tmp_res
1   882	02E5  E2 F8			     loop .add_cycle
1   883	02E7  EB 06 90			 jmp .mul_exit
1   884
1   885	02EA				 .no_mul:
1   886	02EA  C6 06 01BFr 01		     mov err_flag, 1
1   887
1   888	02EF				 .mul_exit:
1   889	02EF  5F			     pop di
1   890	02F0  5E			     pop si
1   891	02F1  59			     pop cx
1   892	02F2  5B			     pop bx
1   893	02F3  58			     pop ax
1   894	02F4  C3			     ret
1   895	02F5			     mul_values	endp
1   896
1   897	02F5			     to_hex_decimal proc
1   898					 ; Процедура для перевода числа из				    +
    899				     двоично-десятичного в десятичное представление в    +
    900				     шестнадцатеричной	записи
1   901					 ; В регистре di ожидается адрес					    +
    902				     двоично-десятичного числа
1   903					 ; Результат:
1   904					 ; в cx записано шестнадцатеричное представление	    +
    905				     десятичного числа
1   906					 ; данная	процедура необходима	для инициализации   +
    907				     счетчика для процедуры	умножения чисел
1   908					 ; так как в данной программе задано ограничение	по+
    909				     модулю для вводимого числа равное 32768,
1   910					 ; то	переполнения регистра cx не случится в		    +
    911				     процессе перевода числа в нужный вид
1   912
Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 17
main.asm



1   913
1   914					 ; сохранение	состояния
1   915	02F5  50			 push ax ;
1   916	02F6  53			 push bx ; множитель 10
1   917	02F7  56			 push si ; для умножения на разряд
1   918	02F8  57			 push di ; адрес числа которое	нужно преобразовать
1   919
1   920					 ; предварительная очистка регистров
1   921	02F9  33 C0			 xor ax, ax
1   922	02FB  33 DB			 xor bx, bx
1   923	02FD  33 C9			 xor cx, cx
1   924	02FF  33 F6			 xor si, si
1   925
1   926					 ; Преобразование	в десятичное	число (в			    +
    927				     шестнадцатеричном	представлении)
1   928	0301  B9 0000			 mov cx, 0	 ; счетчик для суммирования числа
1   929	0304  BB 000A			 mov bx, 10	 ; множитель для умножения	предыдущей	    +
    930				     суммы	на 10
1   931	0307  BE 000A			 mov si, 10	 ; в si количество разрядов числа (возможны +
    932				     незначащие нули слева)
1   933
1   934	030A			     .convert_loop:
1   935	030A  83 FE 00			 cmp si, 0
1   936	030D  74 1A			 je .conv_end
1   937	030F  33 C0			 xor ax, ax
1   938	0311  8A 05			 mov al, [di]	 ; загружаем символ из	строки
1   939	0313  3C 00			 cmp al, 0
1   940	0315  74 0E			 je .zero_rank
1   941	0317  56			 push si	 ; сохраняем текущее значение			    +
    942				     обрабатываемого разряда
1   943
1   944				     ; умножаем	очередной разряд	на 10	соответствующее	    +
    945				     количество раз
1   946	0318			     .rank_mul:
1   947	0318  4E			 dec si
1   948	0319  83 FE 00			 cmp si, 0
1   949	031C  74 04			 je .conv_cont
1   950	031E  F7 E3			 mul BX		 ; умножаем предыдущую сумму на 10
1   951	0320  EB F6			 jmp .rank_mul
1   952
1   953	0322			     .conv_cont:
1   954	0322  5E			 pop si
1   955	0323  03 C8			 add CX, AX	 ; добавляем текущее значение к сумме
1   956	0325			     .zero_rank:
1   957	0325  47			 inc di		 ; переходим к следующему символу
1   958	0326  4E			 dec si
1   959	0327  EB E1			 jmp .convert_loop
1   960
1   961
1   962	0329			     .conv_end:
1   963	0329  5F			 pop di
1   964	032A  5E			 pop si
1   965	032B  5B			 pop bx
1   966	032C  58			 pop ax
1   967
1   968	032D  C3			 ret
1   969	032E			     to_hex_decimal endp
Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 18
main.asm



1   970
1   971	032E			     sum_mul_array proc
1   972					 ; Процедура для получения	суммы элементов массива+
    973				     mul_array
1   974					 ; подразумевается что mul_array заполнен			    +
    975				     двоично-десятичными десяти-разрядными модулями	    +
    976				     попарных произведений
1   977					 ; результат в tmp_res
1   978
1   979	032E  57			 push di ; используется как указатель на адрес		    +
    980				     слагаемого (tmp_res)
1   981	032F  56			 push si ; используется как указатель на mul_array
1   982	0330  51			 push cx ; счетчик обработанных элементов
1   983
1   984	0331  33 F6			 xor si, si
1   985	0333  33 C9			 xor cx, cx
1   986
1   987	0335  E8 FE87			 call clear_tmp_res
1   988
1   989					 ; инициализация указателей
1   990	0338  BF 011Ar			 mov di, offset	tmp_res
1   991	033B  BE 0195r			 mov si, offset	mul_array
1   992
1   993	033E  8A 0C			 mov cl, [si]	      ;	инициализация счетчика элементов	    +
    994				     массива
1   995	0340  46			 inc si		      ;	двигаем указатель на первое		    +
    996				     произведение
1   997
1   998	0341				 .sum_mul_cycle:
1   999	0341  E8 FF45			     call sum_values  ;	результат сложения				    +
   1000				     двоично-десятичных чисел из si и di в tmp_res
1  1001	0344  83 C6 0A			     add si, 10
1  1002	0347  E2 F8			     loop .sum_mul_cycle
1  1003
1  1004	0349  59			 pop cx
1  1005	034A  5E			 pop si
1  1006	034B  5F			 pop di
1  1007	034C  C3			 ret
1  1008	034D			     sum_mul_array endp
1  1009
1  1010	034D			     result_to_string proc
1  1011					 ; Процедура для наполнения буфера res_str символами   +
   1012				     численного результата (модуля)
1  1013					 ; подразумевается что буфер tmp_res содержит		    +
   1014				     результат	вычисления суммы	попарных (разделенных    +
   1015				     по знаку)
1  1016					 ; произведений введенных чисел
1  1017	034D  56			 push si ; используется как указатель на tmp_res
1  1018	034E  57			 push di ; используется как указатель на res_str
1  1019	034F  50			 push ax ; используется как промежуточная переменная  +
   1020				     для обработки символа
1  1021	0350  51			 push cx ; счетчик обработанных символов (байт)
1  1022
1  1023					 ; очистка регистров
1  1024	0351  33 F6			 xor si, si
1  1025	0353  33 FF			 xor di, di
1  1026	0355  33 C0			 xor ax, ax
Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 19
main.asm



1  1027	0357  33 C9			 xor cx, cx
1  1028
1  1029	0359  BE 011Ar			 mov si, offset	tmp_res
1  1030	035C  BF 0138r			 mov di, offset	res_str	+ 1    ; пропускаем первый байт - символ  +
   1031				     '-'
1  1032	035F  B9 000A			 mov cx, 10
1  1033
1  1034	0362				 .del_zeros:
1  1035	0362  83 F9 01			     cmp cx, 1
1  1036	0365  74 0A			     je	.true_num_cycle
1  1037	0367  8A 04			     mov al, [si]
1  1038	0369  3C 00			     cmp al, 0
1  1039	036B  75 04			     jne .true_num_cycle
1  1040	036D  49			     dec cx
1  1041	036E  46			     inc si
1  1042	036F  EB F1			     jmp .del_zeros
1  1043	0371				 .true_num_cycle:
1  1044	0371  8A 04			     mov al, [si]
1  1045	0373  04 30			     add al, 30h
1  1046	0375  88 05			     mov [di], al
1  1047	0377  47			     inc di
1  1048	0378  46			     inc si
1  1049	0379  E2 F6			     loop .true_num_cycle
1  1050					 ; проверка на 0 (добавляем минус если результат не  +
   1051				     равен	нулю)
1  1052	037B  BF 0137r			 mov di, offset	res_str
1  1053	037E  8B 1D			 mov bx, [di]
1  1054	0380  80 FF 30			 cmp bh, 30h
1  1055	0383  75 0A			 jne .add_neg
1  1056					 ; если результат равен 0
1  1057	0385  C6 05 30			 mov [di], byte	ptr 30h	; первый байт	0
1  1058	0388  47			 inc di
1  1059	0389  C6 05 24			 mov [di], byte	ptr '$'	; второй байт	символ завершения	    +
   1060				     строки
1  1061	038C  EB 04 90			 jmp .end_res_to_str
1  1062	038F			     .add_neg:
1  1063	038F  C6 05 2D			 mov [di], byte	ptr '-'
1  1064	0392			     .end_res_to_str:
1  1065	0392  59			 pop cx
1  1066	0393  58			 pop ax
1  1067	0394  5F			 pop di
1  1068	0395  5E			 pop si
1  1069	0396  C3			 ret
1  1070
1  1071	0397			     result_to_string endp
1  1072
   1073
   1074	0000			     .stack
   1075	0397  0100*(??)			 db 100h dup(?)
   1076
   1077				     end start
Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 20
Symbol Table




Symbol Name			  Type	 Value

.ADD_CYCLE			  Near	 _TEXT:02DF
.ADD_NEG			  Near	 _TEXT:038F
.ADD_VALUE_EXIT			  Near	 _TEXT:01BB
.CLEAR_CYCLE			  Near	 _TEXT:01C7
.CONTINUE			  Near	 _TEXT:0167
.CONVERT_LOOP			  Near	 _TEXT:030A
.CONV_CONT			  Near	 _TEXT:0322
.CONV_END			  Near	 _TEXT:0329
.COPY_LOOP			  Near	 _TEXT:021C
.CORRECT_INPUT			  Near	 _TEXT:0089
.CORR_END			  Near	 _TEXT:0177
.COUNTER_INITIALIZED		  Near	 _TEXT:01F9
.CYCLE				  Near	 _TEXT:0276
.DEL_ZEROS			  Near	 _TEXT:0362
.END_PROGRAM			  Near	 _TEXT:00C6
.END_RANGE			  Near	 _TEXT:0159
.END_RES_TO_STR			  Near	 _TEXT:0392
.ERROR				  Near	 _TEXT:0172
.INPUT				  Near	 _TEXT:0020
.IS_NUM_CYCLE			  Near	 _TEXT:0108
.MAX_DIGITS_CHECK		  Near	 _TEXT:011C
.MUL_EXIT			  Near	 _TEXT:02EF
.NEGATIVE			  Near	 _TEXT:0165
.NEG_CYCLE			  Near	 _TEXT:019C
.NEG_START			  Near	 _TEXT:0127
.NOT_EMPTY			  Near	 _TEXT:0057
.NOT_EXIT			  Near	 _TEXT:006F
.NO_MUL				  Near	 _TEXT:02EA
.NO_MUL_FLAG			  Near	 _TEXT:0219
.NULL_FILLING			  Near	 _TEXT:0269
.POSITIVE			  Near	 _TEXT:0265
.POS_CYCLE			  Near	 _TEXT:01B3
.POS_LOWER			  Near	 _TEXT:01F7
.POS_NUM			  Near	 _TEXT:01A7
.POS_START			  Near	 _TEXT:0137
.PROD_LOOP			  Near	 _TEXT:0205
.RANGE_CYCLE			  Near	 _TEXT:0144
.RANK_MUL			  Near	 _TEXT:0318
.RETRY				  Near	 _TEXT:002E
.SUM_CYCLE			  Near	 _TEXT:029C
.SUM_MUL_CYCLE			  Near	 _TEXT:0341
.TRUE_NUM_CYCLE			  Near	 _TEXT:0371
.ZERO_RANK			  Near	 _TEXT:0325
??DATE				  Text	 "12/25/23"
??FILENAME			  Text	 "main	  "
??TIME				  Text	 "23:37:46"
??VERSION			  Number 0205
@CODE				  Text	 _TEXT
@CODESIZE			  Text	 0
@CPU				  Text	 0101H
@CURSEG				  Text	 _TEXT
@DATA				  Text	 DGROUP
@DATASIZE			  Text	 0
@FILENAME			  Text	 MAIN
Turbo Assembler	 Version 2.51	     12/25/23 23:37:47	    Page 21
Symbol Table



@MODEL				  Text	 2
@WORDSIZE			  Text	 2
ADD_VALUE			  Near	 _TEXT:017E
CARRET				  Byte	 DGROUP:0118
CLEAR_TMP_RES			  Near	 _TEXT:01BF
EMPTY_MESS			  Byte	 DGROUP:009C
ERR_FLAG			  Byte	 DGROUP:01BF
ERR_MESS			  Byte	 DGROUP:010A
EXIT_MESS			  Byte	 DGROUP:00EA
FILL_MUL_ARRAY			  Near	 _TEXT:01D0
INPUT_MESS			  Byte	 DGROUP:004A
IN_STR				  Byte	 DGROUP:012F
IS_CORRECT			  Near	 _TEXT:00CD
MAX_NEG_LEN			  Number 0006
MAX_NUM				  Byte	 DGROUP:0000
MAX_POS_LEN			  Number 0005
MUL_ARRAY			  Byte	 DGROUP:0195
MUL_VALUES			  Near	 _TEXT:02BD
NEGATIVE			  Number 002D
NEG_ARRAY			  Byte	 DGROUP:016C
NEG_FLAG			  Byte	 DGROUP:01BE
NEG_MAX_LAST			  Number 0038
NUMS_SIZE			  Number 0008
OUTPUT_MESS			  Byte	 DGROUP:0059
POS_ARRAY			  Byte	 DGROUP:0143
POS_MAX_LAST			  Number 0037
RESULT_TO_STRING		  Near	 _TEXT:034D
RES_STR				  Byte	 DGROUP:0137
START				  Near	 _TEXT:0000
START_MESS			  Byte	 DGROUP:0004
SUM_MUL_ARRAY			  Near	 _TEXT:032E
SUM_VALUES			  Near	 _TEXT:0289
TMP_NUM				  Byte	 DGROUP:0124
TMP_RES				  Byte	 DGROUP:011A
TO_BIN_DECIMAL			  Near	 _TEXT:0235
TO_HEX_DECIMAL			  Near	 _TEXT:02F5

Macro Name

EXIT
INPUT
PRINT

Groups & Segments		  Bit Size Align  Combine Class

DGROUP				  Group
  STACK				  16  0400 Para	  Stack	  STACK
  _DATA				  16  01C0 Word	  Public  DATA
_TEXT				  16  0497 Word	  Public  CODE
