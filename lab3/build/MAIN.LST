Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 1
main.asm



      1				     .8086
      2	0000			     .MODEL SMALL
      3
      4				     include macros.asm
1     5
1     6				     print macro text ;вывод сообщений на экран
1     7					     push ax
1     8					     push dx
1     9					     mov dx,offset text
1    10					     mov ah,9
1    11					     int 21h
1    12					     pop dx
1    13					     pop ax
1    14				     endm
1    15
1    16				     input macro text ;ввод	строки символов
1    17					 ; сохранение	состояния в стеке
1    18					     push ax
1    19					     push dx
1    20					     push bx
1    21					 ; запись	ввода в буфер text
1    22				     .retry:
1    23					 ; вызов функции ввода	21го прерывания
1    24					     mov dx,offset text
1    25					     mov ah,0ah
1    26					     int 21h
1    27
1    28					     inc dx ; передвигаем указатель	на байт,			    +
     29				     соответствующий количеству введенных символов
1    30					     mov bx, dx
1    31					     mov bl, [bx] ; количество введенных символов
1    32					     cmp bl, 0h	  ; проверка на пустую строку
1    33					     jne .not_empty
1    34					     print empty_mess
1    35					 print input_mess
1    36					 jmp .retry
1    37
1    38				     .not_empty:
1    39					 mov bx, dx
1    40					     inc bx
1    41					     mov bl, [bx] ; первый введенный символ
1    42					     cmp bl, 18h  ; проверка на ввод ctrl+x (= выход)
1    43					     jne .not_exit
1    44					     print exit_mess
1    45					     jmp .end_program
1    46				     .not_exit:
1    47					     ; возврат состояния из стека
1    48					 pop bx
1    49					     pop dx
1    50					     pop ax
1    51				     endm
1    52
1    53				     exit macro
1    54					 ; завершение	программы
1    55					 mov ah, 4ch
1    56					 mov al, 0
1    57					 int 21h
Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 2
main.asm



1    58					 ret
1    59				     endm
     60				     include data.asm
1    61	0000			     .data
1    62	      =	002D			 NEGATIVE	  equ 2Dh ; шестнадцатеричный ascii код знака '-'
1    63	      =	0008			 NUMS_SIZE	  equ 8h  ; количество вводимых чисел
1    64	      =	0005			 MAX_POS_LEN	  equ 5h  ; максимальная длина	положительного+
     65				     числа
1    66	      =	0006			 MAX_NEG_LEN	  equ 6h  ; максимальная длина	отрицательного+
     67				     числа	с учетом	знака
1    68	      =	0037			 POS_MAX_LAST	  equ 37h ; младший разряд	верхнего		    +
     69				     ограничения (ascii, hex)
1    70	      =	0038			 NEG_MAX_LAST	  equ 38h ; младший разряд	нижнего			    +
     71				     ограничения (ascii, hex)
1    72	0000  33 32 37 36		 MAX_NUM    db '3276' ;	старшие разряды модуля			    +
     73				     максимального	числа без последнего разряда
1    74
1    75					 ; текстовые переменные для вывода
1    76	0004  49 6E 70 75 74 3A	20+	 start_mess db 'Input: 8 numbers in [-32768, 32767]', 10, 'Press <Enter> after each number',+
     77	      38 20 6E 75 6D 62	65+  10,13,'$'
     78	      72 73 20 69 6E 20	5B+
     79	      2D 33 32 37 36 38	2C+
     80	      20 33 32 37 36 37	5D+
     81	      0A 50 72 65 73 73	20+
     82	      3C 45 6E 74 65 72	3E+
     83	      20 61 66 74 65 72	20+
     84	      65 61 63 68 20 6E	75+
     85	      6D 62 65 72 0A 0D	24
1    86	004A  45 6E 74 65 72 20	6E+	 input_mess db 'Enter number: $'
     87	      75 6D 62 65 72 3A	20+
     88	      24
1    89	0059  6F 75 74 70 75 74	20+	 output_mess db	'output	(sum of	pairwise products of numbers of	different signs):', 10,	13, +
     90	      28 73 75 6D 20 6F	66+  '$'
     91	      20 70 61 69 72 77	69+
     92	      73 65 20 70 72 6F	64+
     93	      75 63 74 73 20 6F	66+
     94	      20 6E 75 6D 62 65	72+
     95	      73 20 6F 66 20 64	69+
     96	      66 66 65 72 65 6E	74+
     97	      20 73 69 67 6E 73	29+
     98	      3A 0A 0D 24
1    99	009C  49 6E 70 75 74 20	45+	 empty_mess db 'Input Error: empty string. Try again or	use ctrl+x and press enter for	    +
    100	      72 72 6F 72 3A 20	65+  exit.', 10, '$'
    101	      6D 70 74 79 20 73	74+
    102	      72 69 6E 67 2E 20	54+
    103	      72 79 20 61 67 61	69+
    104	      6E 20 6F 72 20 75	73+
    105	      65 20 63 74 72 6C	2B+
    106	      78 20 61 6E 64 20	70+
    107	      72 65 73 73 20 65	6E+
    108	      74 65 72 20 66 6F	72+
    109	      20 65 78 69 74 2E	0A+
    110	      24
1   111	00EA  50 72 6F 67 72 61	6D+	 exit_mess  db 'Program	was aborted by keybord', 10, '$'
    112	      20 77 61 73 20 61	62+
    113	      6F 72 74 65 64 20	62+
    114	      79 20 6B 65 79 62	6F+
Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 3
main.asm



    115	      72 64 0A 24
1   116	010A  49 6E 70 75 74 20	65+	 err_mess   db 'Input error!', 10, '$'
    117	      72 72 6F 72 21 0A	24
1   118	0118  0A 24			 carret	    db 10, '$'
1   119
1   120					 ; буферные переменные
1   121	011A  0A*(00)			 tmp_res    db 10 dup(0)	  ; переменная для	промежуточного+
    122				     сохранения результата сложения/умножения
1   123									  ; двух десяти-разрядных		    +
    124				     беззнаковых двоично-десятичных	чисел
1   125	0124  00 0A*(??)		 tmp_num    db 0, 10 dup(?)	  ; переменная для	промежуточного+
    126				     сохранения двоично-десятичного	представления числа
1   127									  ; первый байт tmp_num - знаковый,
1   128									  ; все операции над 10 разрядными  +
    129				     двоично-десятичными числами (с незначащими нулями)
1   130	012F  07 ?? 06*(??)		 in_str	    db 7, ?, 6 dup (?)	    ; буфер ввода 1 байт размер	    +
    131				     буфера, второй	-количество введенных символов
1   132	0137  0C*(24)			 res_str    db 12 dup ('$')	  ; буфер для преобразования	    +
    133				     результата в строку
1   134									  ; (произведения разных знаков, а +
    135				     также	их последующие суммы всегда отрицательны)
1   136
1   137					 ; массивы, первый	байт в массиве для учета		    +
    138				     количества записанных чисел
1   139	0143  00 04*(0A*(??))		 pos_array  db 0, 4 dup(10 dup(?)) ; массив для пяти модулей	    +
    140				     положительных	двоично-десятичных чисел размером	5   +
    141				     байт
1   142	016C  00 04*(0A*(??))		 neg_array  db 0, 4 dup(10 dup(?)) ; массив для пяти модулей	    +
    143				     отрицательных	двоично-десятичных чисел размером	5   +
    144				     байт
1   145	0195  00 04*(0A*(??))		 mul_array  db 0, 4 dup(10 dup(?)) ; массив модулей поэлементных   +
    146				     произведений массивов
1   147
1   148					 ; флаги
1   149	01BE  00			 neg_flag   db 0     ; флаг	наличия знака '-' для is_correct	proc
1   150	01BF  00			 err_flag   db 0     ; флаг	ошибки во вводе для is_correct		    +
    151				     proc/цикла ввода
1   152
1   153
    154
    155	01C0			     .code
    156	0000			     start:
    157					; инициализация памяти
    158	0000  B8 0000s			 mov ax, @data
    159	0003  8E D8			 mov ds, ax
    160
    161					 ;вызов функции 0 -	 установка 3 текстового		    +
    162				     видеорежима, очистка экрана
    163	0005  B8 0003			 mov ax, 0003  ; ah=0 (номер функции), al=3	(номер режима)
    164	0008  CD 10			 int 10h
    165
    166					 print start_mess  ; вывод	стартового сообщения
1   167	000A  50			     push ax
1   168	000B  52			     push dx
1   169	000C  BA 0004r			     mov dx,offset start_mess
1   170	000F  B4 09			     mov ah,9
1   171	0011  CD 21			     int 21h
Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 4
main.asm



1   172	0013  5A			     pop dx
1   173	0014  58			     pop ax
    174	0015  33 C9			 xor cx, cx
    175	0017  B9 0008			 mov cx, NUMS_SIZE ; в	cx количество	чисел для ввода		    +
    176				     пользователем
    177
    178					 ; инициализация указателей на	первые элементы	    +
    179				     массивов без учета	размерного байта	(используется в+
    180				     add_value proc)
    181	001A  BE 0144r			 mov si, offset	pos_array + 1
    182	001D  BF 016Dr			 mov di, offset	neg_array + 1
    183
    184					 ; цикл ввода/проверки/распределения по	массивам
    185	0020				 .input:
    186					     print input_mess  ;вывод сообщения о вводе строки
1   187	0020  50			     push ax
1   188	0021  52			     push dx
1   189	0022  BA 004Ar			     mov dx,offset input_mess
1   190	0025  B4 09			     mov ah,9
1   191	0027  CD 21			     int 21h
1   192	0029  5A			     pop dx
1   193	002A  58			     pop ax
    194					     input in_str      ;ввод числа в виде	строки
1   195	002B  50			     push ax
1   196	002C  52			     push dx
1   197	002D  53			     push bx
1   198	002E			     .retry:
1   199	002E  BA 012Fr			     mov dx,offset in_str
1   200	0031  B4 0A			     mov ah,0ah
1   201	0033  CD 21			     int 21h
1   202	0035  42			     inc dx ; передвигаем указатель	на байт,			    +
    203				     соответствующий количеству введенных символов
1   204	0036  8B DA			     mov bx, dx
1   205	0038  8A 1F			     mov bl, [bx] ; количество введенных символов
1   206	003A  80 FB 00			     cmp bl, 0h	  ; проверка на пустую строку
1   207	003D  75 18			     jne .not_empty
1   208					     print empty_mess
2   209	003F  50			     push ax
2   210	0040  52			     push dx
2   211	0041  BA 009Cr			     mov dx,offset empty_mess
2   212	0044  B4 09			     mov ah,9
2   213	0046  CD 21			     int 21h
2   214	0048  5A			     pop dx
2   215	0049  58			     pop ax
1   216					 print input_mess
2   217	004A  50			     push ax
2   218	004B  52			     push dx
2   219	004C  BA 004Ar			     mov dx,offset input_mess
2   220	004F  B4 09			     mov ah,9
2   221	0051  CD 21			     int 21h
2   222	0053  5A			     pop dx
2   223	0054  58			     pop ax
1   224	0055  EB D7			 jmp .retry
1   225	0057			     .not_empty:
1   226	0057  8B DA			 mov bx, dx
1   227	0059  43			     inc bx
1   228	005A  8A 1F			     mov bl, [bx] ; первый введенный символ
Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 5
main.asm



1   229	005C  80 FB 18			     cmp bl, 18h  ; проверка на ввод ctrl+x (= выход)
1   230	005F  75 0E			     jne .not_exit
1   231					     print exit_mess
2   232	0061  50			     push ax
2   233	0062  52			     push dx
2   234	0063  BA 00EAr			     mov dx,offset exit_mess
2   235	0066  B4 09			     mov ah,9
2   236	0068  CD 21			     int 21h
2   237	006A  5A			     pop dx
2   238	006B  58			     pop ax
1   239	006C  EB 58 90			     jmp .end_program
1   240	006F			     .not_exit:
1   241	006F  5B			 pop bx
1   242	0070  5A			     pop dx
1   243	0071  58			     pop ax
    244
    245					     ; проверки, заполнение массивов
    246	0072  E8 0058			     call is_correct   ; проверка на корректность	символов    +
    247				     числа, установка err_flag
    248	0075  80 3E 01BFr 00		     cmp err_flag, 0
    249	007A  74 0D			     je	.correct_input
    250
    251					     ; если	была ошибка вывод сообщения и			    +
    252				     циклический ввод
    253					     print err_mess
1   254	007C  50			     push ax
1   255	007D  52			     push dx
1   256	007E  BA 010Ar			     mov dx,offset err_mess
1   257	0081  B4 09			     mov ah,9
1   258	0083  CD 21			     int 21h
1   259	0085  5A			     pop dx
1   260	0086  58			     pop ax
    261	0087  EB 97			     jmp .input
    262
    263	0089				 .correct_input:
    264	0089  E8 01A1			     call to_bin_decimal  ; преобразование in_str	к			    +
    265				     двоично-десятичному виду в tmp_num (с незначащими	    +
    266				     нулями и байтом знака)
    267	008C  E8 00EF			     call add_value	  ; копирование модуля	из tmp_num в		    +
    268				     соответствующий массив
    269					     print carret	  ; печать переноса строки
1   270	008F  50			     push ax
1   271	0090  52			     push dx
1   272	0091  BA 0118r			     mov dx,offset carret
1   273	0094  B4 09			     mov ah,9
1   274	0096  CD 21			     int 21h
1   275	0098  5A			     pop dx
1   276	0099  58			     pop ax
    277	009A  E2 84			     loop .input	  ; цикл ввода
    278
    279					 ; здесь массивы pos_array и neg_array заполнены модулями	    +
    280				     соответствующих по знаку введенных чисел
    281	009C  E8 0129			 call fill_mul_array
    282	009F  E8 0284			 call sum_mul_array
    283	00A2  E8 02A0			 call result_to_string
    284					 print output_mess
1   285	00A5  50			     push ax
Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 6
main.asm



1   286	00A6  52			     push dx
1   287	00A7  BA 0059r			     mov dx,offset output_mess
1   288	00AA  B4 09			     mov ah,9
1   289	00AC  CD 21			     int 21h
1   290	00AE  5A			     pop dx
1   291	00AF  58			     pop ax
    292					 print res_str
1   293	00B0  50			     push ax
1   294	00B1  52			     push dx
1   295	00B2  BA 0137r			     mov dx,offset res_str
1   296	00B5  B4 09			     mov ah,9
1   297	00B7  CD 21			     int 21h
1   298	00B9  5A			     pop dx
1   299	00BA  58			     pop ax
    300					 print carret
1   301	00BB  50			     push ax
1   302	00BC  52			     push dx
1   303	00BD  BA 0118r			     mov dx,offset carret
1   304	00C0  B4 09			     mov ah,9
1   305	00C2  CD 21			     int 21h
1   306	00C4  5A			     pop dx
1   307	00C5  58			     pop ax
    308
    309	00C6			     .end_program:
    310					 exit ;	завершение программы
1   311	00C6  B4 4C			 mov ah, 4ch
1   312	00C8  B0 00			 mov al, 0
1   313	00CA  CD 21			 int 21h
1   314	00CC  C3			 ret
    315
    316				     include func.asm
1   317
1   318	00CD			     is_correct	proc
1   319					 ; Процедура для проверки корректности введенного +
    320				     числа
1   321					 ; число должно быть записано в	буфер in_str
1   322					 ; корректный	диапазон - [-32768, 32767]
1   323
1   324					 ; сохраняем состояние регистров
1   325	00CD  50			 push ax ; используется для хранения текущего символа
1   326	00CE  53			 push bx ; используется для хранения индекса в		    +
    327				     диапазоне	(проход по константе MAX_NUM)
1   328	00CF  51			 push cx ; используется для хранения количества	    +
    329				     обработанных символов числа
1   330	00D0  52			 push dx ; используется для хранения последнего	    +
    331				     символа диапазона в зависимости от знака
1   332	00D1  56			 push si ; используется для хранения индекса в буфере  +
    333				     ввода
1   334	00D2  57			 push di ; используется для хранения количества	    +
    335				     введенных	символов во входном буфере
1   336
1   337					 ; очистка используемых регистров
1   338	00D3  33 C0			 xor ax, ax
1   339	00D5  33 DB			 xor bx, bx
1   340	00D7  33 C9			 xor cx, cx
1   341	00D9  33 D2			 xor dx, dx
1   342	00DB  33 F6			 xor si, si
Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 7
main.asm



1   343	00DD  33 FF			 xor di, di
1   344
1   345					 ; инициализация di количеством	символов во входном+
    346				     буфере
1   347	00DF  BF 012Fr			 mov di, offset	in_str ; помещаем в di	адрес буфера	ввода
1   348	00E2  47			 inc di		 ; перемещаем	на количество символов	    +
    349				     записанных в буфер
1   350	00E3  8B 3D			 mov di, [di]	 ; загружаем 2	первых байта	из in_str в di
1   351	00E5  81 E7 00FF		 and di, 00FFh	 ; очищаем старший байт
1   352
1   353					 ; начальная инициализация
1   354	00E9  C6 06 01BEr 00		 mov neg_flag, 0 ; очистка флага для хранения знака	числа
1   355	00EE  C6 06 01BFr 00		 mov err_flag, 0 ; очистка флага для определения ошибки	    +
    356				     ввода
1   357	00F3  BE 0002			 mov si, 2	 ; Инициализация индекса числа	(пропуск	    +
    358				     служебных	байтов буфера)
1   359	00F6  BB 0000			 mov bx, 0	 ; Инициализация индекса для			    +
    360				     максимального	диапазона
1   361
1   362	00F9  8A 84 012Fr		 mov al, in_str[si]; Загрузка текущего элемента	буфера в	AL
1   363	00FD  3C 2D			 cmp al, NEGATIVE  ; Является ли первый	символ знаком '-'
1   364	00FF  75 07			 jne .is_num_cycle
1   365	0101  C6 06 01BEr 01		 mov neg_flag, 1   ; установка	флага отрицательного	числа
1   366	0106  46			 inc si		   ; перемещаем указатель в	буфере на	    +
    367				     следующий	байт (символ)
1   368	0107  41			 inc cx		   ; увеличиваем счетчик обработанных	    +
    369				     чисел
1   370
1   371					 ; проверка: является ли числом	каждый введенный	    +
    372				     символ символ (исключая первый минус)
1   373	0108				 .is_num_cycle:
1   374	0108  3B CF			     cmp cx, di		  ; если все символы обработаны
1   375	010A  74 10			     je	.max_digits_check ; выход из цикла
1   376	010C  8A 84 012Fr		     mov al, in_str[si]	  ; в al очередной ascii код ввода
1   377	0110  3C 30			     cmp al, 30h	  ; 30h	- ascii	код для числа 0, если меньше - +
    378				     ошибка ввода
1   379	0112  7C 5E			     jl	.error
1   380	0114  3C 39			     cmp al, 39h	  ; 39h	- ascii	код для числа 9, если меньше - +
    381				     ошибка ввода
1   382	0116  7F 5A			     jg	.error
1   383	0118  41			     inc cx		  ; увеличиваем счетчик
1   384	0119  46			     inc si		  ; двигаем указатель
1   385	011A  EB EC			     jmp .is_num_cycle	  ; повторяем цикл
1   386
1   387
1   388	011C				 .max_digits_check:
1   389					     ; очистка регистров
1   390	011C  33 C9			     xor cx, cx
1   391	011E  33 F6			     xor si, si
1   392
1   393	0120  80 3E 01BEr 00		     cmp neg_flag, 0	 ; проверка знака числа
1   394	0125  74 10			     je	.pos_start
1   395
1   396					     ; для отрицательных:
1   397	0127				     .neg_start:
1   398	0127  83 FF 06				 cmp di, MAX_NEG_LEN ; сравнение количества введенных   +
    399				     символов и максимального количества разрядов
Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 8
main.asm



1   400	012A  7C 4B				 jl .corr_end	     ; если	меньше, завершаем без	ошибки
1   401	012C  7F 44				 jg .error	     ; если	больше завершаем	с ошибкой
1   402						 ; если равно,	инициализация и переход к		    +
    403				     поразрядной проверке
1   404	012E  BE 0003				 mov si, 3
1   405	0131  B9 0002				 mov cx, 2	      ;	значение больше на 1 чем		    +
    406				     действительное чтобы выйти	из range_cycle раньше на 1	    +
    407				     символ
1   408	0134  EB 0E 90				 jmp .range_cycle
1   409
1   410					     ; для положительных
1   411	0137				     .pos_start:
1   412	0137  83 FF 05				 cmp di, MAX_POS_LEN ; сравнение количества введенных   +
    413				     символов и максимального количества разрядов
1   414	013A  7C 3B				 jl .corr_end	     ; если	меньше, завершаем без	ошибки
1   415	013C  7F 34				 jg .error
1   416						 ; если равно,	инициализация и переход к		    +
    417				     поразрядной проверке
1   418	013E  BE 0002				 mov si, 2
1   419	0141  B9 0001				 mov cx, 1
1   420
1   421					     ; поразрядная проверка диапазона если		    +
    422				     количество символов модуля	равно 5
1   423	0144				     .range_cycle:
1   424	0144  8A 84 012Fr			 mov al, in_str[si] ; Загрузка текущего	элемента	    +
    425				     буфера в AL
1   426	0148  3A 87 0000r			 cmp al, MAX_NUM[bx]
1   427	014C  7F 24				 jg .error
1   428	014E  7C 27				 jl .corr_end
1   429						 ; если символ равен ограничению:
1   430	0150  46				 inc si		   ; Увеличение индекса числа
1   431	0151  41				 inc cx		   ; Увеличение счетчика обработанных +
    432				     цифр
1   433	0152  43				 inc bx		   ; Увеличение индекса в строке	    +
    434				     содержащей максимальные цифры диапазона
1   435	0153  3B CF				 cmp cx, di	   ; Проверка, достигнут ли конец	    +
    436				     буфера
1   437	0155  74 02				 je .end_range	   ; Если да, прерывание цикла
1   438	0157  EB EB				 jmp .range_cycle  ; Переход на следующую итерацию	    +
    439				     цикла
1   440
1   441					     ; проверка	последнего символа если число		    +
    442				     значащих цифр равно максимальному
1   443	0159				     .end_range:
1   444	0159  80 3E 01BEr 01			 cmp neg_flag, 1
1   445	015E  74 05				 je .negative
1   446	0160  B2 37				 mov dl, POS_MAX_LAST
1   447	0162  EB 03 90				 jmp .continue
1   448	0165				     .negative:
1   449	0165  B2 38				 mov dl, NEG_MAX_LAST
1   450	0167				     .continue:
1   451	0167  8A 84 012Fr			 mov al, in_str[si] ; загружаем последний символ
1   452	016B  3A C2				 cmp al, dl
1   453	016D  7F 03				 jg .error	    ; если есть	выход за	границу		    +
    454				     диапазона	переход к ошибке
1   455	016F  EB 06 90				 jmp .corr_end
1   456
Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 9
main.asm



1   457					 ; завершение	с ошибкой
1   458	0172				 .error:
1   459	0172  C6 06 01BFr 01		     mov err_flag, 1	  ; установка флага ошибки
1   460
1   461					 ; завершение	без ошибки
1   462	0177				 .corr_end:
1   463					     ; восстанавливаем состояние из стека
1   464	0177  5F			     pop di
1   465	0178  5E			     pop si
1   466	0179  5A			     pop dx
1   467	017A  59			     pop cx
1   468	017B  5B			     pop bx
1   469	017C  58			     pop ax
1   470	017D  C3			     ret
1   471
1   472	017E			     is_correct	endp
1   473
1   474	017E			     add_value proc
1   475					 ; Процедура для копирования числа из временной	    +
    476				     переменной в соответствующий массив
1   477					 ; число представлено в двоично-десятичном виде с   +
    478				     незначащими нулями (размер на выходе 5 байт)
1   479					 ; в массивы записываем только модули, увеличиваем +
    480				     количество записанных чисел
1   481					 ; в si адрес очередного элемента в массиве		    +
    482				     положительных	чисел
1   483					 ; в di адрес очередного элемента в массиве		    +
    484				     отрицательных	чисел
1   485					 ; в tmp_num значение очередного введенного и		    +
    486				     преобразованного числа которое	нужно скопировать
1   487
1   488	017E  50			 push ax ; используется для увеличения	счетчика	    +
    489				     записанных чисел в	массиве и копирования очередной +
    490				     цифры(байта) числа
1   491	017F  53			 push bx ; используется как указатель на tmp_num
1   492	0180  51			 push cx ; счетчик элементов числа	для цикла,		    +
    493				     инициализируется числом 5 (количеством байт в	    +
    494				     каждом числе)
1   495
1   496					 ; инициализация счетчика
1   497	0181  33 C9			 xor cx, cx
1   498	0183  B9 000A			 mov cx, 10
1   499
1   500	0186  BB 0124r			 mov bx, offset	tmp_num	; инициализируем указатель на		    +
    501				     временную	переменную
1   502	0189  8A 07			 mov al, [bx]		; в al	байт знака
1   503	018B  43			 inc bx			; перемещаем указатель на первый	    +
    504				     символ
1   505	018C  3C 00			 cmp al, 0		; проверка на						    +
    506				     отрицательное/положительное число
1   507	018E  74 13			 je .pos_num
1   508
1   509					 ; увеличиваем счетчик записанных чисел в массиве  +
    510				     отрицательных	чисел
1   511	0190  A0 016Cr			 mov al, neg_array
1   512	0193  FE C0			 inc al
1   513	0195  A2 016Cr			 mov neg_array,	al
Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 10
main.asm



1   514
1   515					 ; по-байтовая запись модуля очередного	числа в	    +
    516				     массив отрицательных чисел
1   517	0198				 .neg_cycle:
1   518	0198  8A 07			     mov al, [bx]
1   519	019A  88 05			     mov [di], al
1   520	019C  43			     inc bx
1   521	019D  47			     inc di
1   522	019E  E2 F8			     loop .neg_cycle
1   523
1   524	01A0  EB 11 90			 jmp .add_value_exit
1   525
1   526	01A3				 .pos_num:
1   527					     ; увеличиваем счетчик записанных чисел в		    +
    528				     массиве положительных (неотрицательных)	чисел
1   529	01A3  A0 0143r			     mov al, pos_array
1   530	01A6  FE C0			     inc al
1   531	01A8  A2 0143r			     mov pos_array, al
1   532
1   533					 ; по-байтовая запись модуля очередного	числа в	    +
    534				     массив положительных (неотрицательных) чисел
1   535	01AB				 .pos_cycle:
1   536	01AB  8A 07			     mov al, [bx]
1   537	01AD  88 04			     mov [si], al
1   538	01AF  43			     inc bx
1   539	01B0  46			     inc si
1   540	01B1  E2 F8			     loop .pos_cycle
1   541
1   542					 ; возврат состояния
1   543	01B3				 .add_value_exit:
1   544	01B3  59			     pop cx
1   545	01B4  5B			     pop bx
1   546	01B5  58			     pop ax
1   547	01B6  C3			     ret
1   548
1   549	01B7			     add_value endp
1   550
1   551	01B7			     clear_tmp_res proc
1   552	01B7  56			 push si
1   553	01B8  51			 push cx
1   554	01B9  B9 000A			 mov cx, 10
1   555	01BC  BE 011Ar			 mov si, offset	tmp_res
1   556	01BF				 .clear_cycle:
1   557	01BF  C6 04 00			     mov byte ptr [si],	0
1   558	01C2  46			     inc si
1   559	01C3  E2 FA			     loop .clear_cycle
1   560	01C5  59			 pop cx
1   561	01C6  5E			 pop si
1   562
1   563	01C7  C3			 ret
1   564	01C8			     clear_tmp_res endp
1   565
1   566	01C8			     fill_mul_array proc
1   567					 ; процедура для заполнения массива mul_array		    +
    568				     попарными	произведениями модулей положительных и   +
    569				     отрицательных	чисел
1   570					 ; ожидается что произведен ввод с клавиатуры	    +
Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 11
main.asm



    571				     чисел, числа приведены к двоично-десятичному	виду
1   572					 ; массивы pos_array и neg_array заполнены модулями		    +
    573				     положительных	и отрицательных чисел соответственно
1   574
1   575					 ; сохраняем состояние
1   576	01C8  50			 push ax
1   577	01C9  53			 push bx
1   578	01CA  51			 push cx
1   579	01CB  52			 push dx
1   580	01CC  56			 push si
1   581	01CD  57			 push di
1   582
1   583					 ; чистим	регистры
1   584	01CE  33 C0			 xor ax, ax
1   585	01D0  33 DB			 xor bx, bx
1   586	01D2  33 C9			 xor cx, cx
1   587	01D4  33 D2			 xor dx, dx
1   588	01D6  33 F6			 xor si, si
1   589	01D8  33 FF			 xor di, di
1   590
1   591					 ; инициализация счетчика размером	меньшего из	    +
    592				     массивов введенных чисел
1   593	01DA  BB 0143r			 mov bx, offset	pos_array
1   594	01DD  8A 1F			 mov bl, [bx]
1   595	01DF  8A C3			 mov al, bl
1   596	01E1  BB 016Cr			 mov bx, offset	neg_array
1   597	01E4  8A 1F			 mov bl, [bx]
1   598	01E6  3A C3			 cmp al, bl
1   599	01E8  7F 05			 jg .pos_bigger
1   600	01EA  8A CB			 mov cl, bl
1   601	01EC  EB 03 90			 jmp .counter_initialized
1   602	01EF			     .pos_bigger:
1   603	01EF  8A C8			 mov cl, al
1   604
1   605	01F1			     .counter_initialized:
1   606					 ; инициализация указателей на	массивы с модулями  +
    607				     чисел
1   608	01F1  BE 0144r			 mov si, offset	pos_array + 1
1   609	01F4  BF 016Dr			 mov di, offset	neg_array + 1
1   610
1   611					 ; заполнение	массива mul_array
1   612	01F7  BB 0195r			 mov bx, offset	mul_array
1   613	01FA  89 0F			 mov [bx], byte	ptr cx	 ; запись	в массив	mul_array количества	    +
    614				     элементов
1   615	01FC  43			 inc bx			 ; двигаем указатель на первый		    +
    616				     результат
1   617	01FD				 .prod_loop:
1   618	01FD  C6 06 01BFr 00		     mov err_flag, 0
1   619	0202  E8 00B0			     call mul_values ; в tmp_res результат умножения	модулей
1   620	0205  80 3E 01BFr 01		     cmp err_flag, 1
1   621					     ; копируем	результат в массив mul_array
1   622	020A  51			     push cx
1   623	020B  56			     push si
1   624	020C  74 03			     je	.no_mul_flag
1   625	020E  BE 011Ar			     mov si, offset tmp_res
1   626	0211				 .no_mul_flag:
1   627	0211  B9 000A			     mov cx, 10
Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 12
main.asm



1   628	0214				     .copy_loop:
1   629	0214  8A 14				 mov dl, [si]
1   630	0216  88 17				 mov [bx], dl
1   631	0218  46				 inc si
1   632	0219  43				 inc bx
1   633	021A  E2 F8				 loop .copy_loop
1   634	021C  5E			     pop si
1   635	021D  59			     pop cx
1   636					     ; здесь копирование завершено
1   637
1   638					     ; перемещаем указатели к следующим элементам:
1   639	021E  83 C6 0A			     add si, 10
1   640	0221  83 C7 0A			     add di, 10
1   641	0224  E2 D7			     loop .prod_loop
1   642
1   643					 ; восстанавливаем состояние
1   644	0226  5F			 pop di
1   645	0227  5E			 pop si
1   646	0228  5A			 pop dx
1   647	0229  59			 pop cx
1   648	022A  5B			 pop bx
1   649	022B  58			 pop ax
1   650
1   651	022C  C3			 ret	 ; возврат
1   652	022D			     fill_mul_array endp
1   653
1   654
1   655	022D			     to_bin_decimal proc
1   656					 ; Процедура для перевода числа из ascii в десятичное +
    657				     представление
1   658					 ; В выходном массиве первый байт для учета знака (0 +
    659				     неотрицательное(положительное), 1 - отрицательное)
1   660					 ; все числа будут	выровнены по	разрядам (дополнены+
    661				     незначащими нулями)
1   662					 ; В in_str содержится буфер ввода
1   663					 ;   1й байт: размер	буфера
1   664					 ;   2й байт: количество	введенных символов (включая +
    665				     знак минус)
1   666					 ;   с	третьего по предпоследний: ascii	символы		    +
    667				     введенного числа
1   668					 ;   последний	символ завершения ввода - 0Dh
1   669					 ; Результат:
1   670					 ; в буфере tmp_num записано десятичное представление +
    671				     введенного числа,
1   672					 ; первый	байт - знаковый
1   673					 ; так как при	переводе все	разряды заполняются	    +
    674				     новым	байтом знака, цифрами	разряда или незначащими+
    675				     нулями,
1   676					 ; то	предварительная очистка буфера перед новой    +
    677				     записью не требуется
1   678
1   679					 ; сохранение	состояния
1   680	022D  50			 push ax ; используется для хранения числа 30h и		    +
    681				     использовании	в команде sub
1   682	022E  53			 push bx ; используется для получения ascii-кода		    +
    683				     очередного символа
1   684	022F  51			 push cx ; используется в роли	счетчика обработанных   +
Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 13
main.asm



    685				     символов
1   686	0230  52			 push dx ; используется для хранения количества	    +
    687				     незначащих нулей
1   688	0231  57			 push di ; используется для адресации выходного буфера
1   689	0232  56			 push si ; используется для адресации входного буфера
1   690
1   691					 ; предварительная очистка регистров
1   692	0233  33 C0			 xor ax, ax
1   693	0235  33 DB			 xor bx, bx
1   694	0237  33 D2			 xor dx, dx
1   695	0239  33 F6			 xor si, si
1   696	023B  33 FF			 xor di, di
1   697
1   698	023D  BE 012Fr			 mov si, offset	in_str
1   699					 ; начальная инициализация
1   700	0240  B0 30			 mov al, 30h
1   701	0242  BF 0124r			 mov di, offset	tmp_num
1   702
1   703					 ; инициализируем	счетчик числом символов в	строке
1   704	0245  46			 inc si
1   705	0246  8B 0C			 mov cx, [si]
1   706	0248  8A 14			 mov dl, [si] ;	записываем количество символов
1   707	024A  32 ED			 xor ch, ch   ;	чистим старший(лишний) байт
1   708
1   709					 ; двигаем указатель на первый символ во входном	    +
    710				     буфере
1   711	024C  46			 inc si
1   712
1   713					 ; проверка на наличие	символа '-', если			    +
    714				     присутствует, записываем байт знака	в выходной	    +
    715				     буфер
1   716					 ; по	умолчанию байт знака инициализирован нулем,   +
    717				     что соответствует неотрицательному	числу
1   718					 ; и двигаем указатель, если нет прыгаем	к		    +
    719				     основному	циклу обработки
1   720	024D  80 3C 2D			 cmp byte ptr [si], NEGATIVE
1   721	0250  75 0B			     jne .positive
1   722	0252  C6 05 01			     mov [di], byte ptr	1 ; запись знакового байта
1   723	0255  46			     inc si
1   724	0256  49			     dec cx
1   725	0257  FE CA			     dec dl	 ; если был знак минус уменьшаем		    +
    726				     количество символов в буфере на	1
1   727	0259  47			     inc di
1   728	025A  EB 05 90			     jmp .null_filling
1   729	025D				 .positive:
1   730	025D  C6 05 00			     mov [di], byte ptr	0  ; запись знакового байта
1   731	0260  47			     inc di	 ; если число позитивное двигаем		    +
    732				     указатель	выходного буфера	на первый символ
1   733	0261				 .null_filling:	 ; заполнение	незначащими нулями
1   734	0261  80 FA 0A			     cmp dl, 10	 ; все числа десяти разрядные с			    +
    735				     незначащими нулями
1   736	0264  7D 08			     jge .cycle
1   737	0266  C6 05 00			     mov [di], byte ptr	0
1   738	0269  47			     inc di
1   739	026A  FE C2			     inc dl
1   740	026C  EB F3			     jmp .null_filling
1   741
Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 14
main.asm



1   742					 ; основной цикл - получаем	ascii код, вычитаем из него+
    743				     30	(так	как символы 0-9 имеют коды 30-39)
1   744					 ; записываем	в выходной буфер,	двигаем указатели
1   745	026E				 .cycle:
1   746	026E  8B 1C			     mov bx, [si]
1   747	0270  32 FF			     xor bh, bh
1   748	0272  2B D8			     sub bx, ax	   ; в	bl результат вычитания
1   749	0274  88 1D			     mov [di], bl
1   750	0276  47			     inc di
1   751	0277  46			     inc si
1   752	0278  E2 F4			     loop .cycle
1   753
1   754					 ; восстанавливаем исходное состояние регистров
1   755	027A  5E			 pop si
1   756	027B  5F			 pop di
1   757	027C  5A			 pop dx
1   758	027D  59			 pop cx
1   759	027E  5B			 pop bx
1   760	027F  58			 pop ax
1   761
1   762	0280  C3			 ret
1   763
1   764	0281			     to_bin_decimal endp
1   765
1   766	0281			     sum_values	proc
1   767					 ; Процедура для сложения двух неотрицательных	    +
    768				     десяти разрядных двоично-десятичных чисел
1   769					 ; задано	ограничение для числа: |-36768| * |36767| = 1 073 709    +
    770				     056, десять разрядов	защищают от переполнения
1   771					 ; вход:
1   772					 ;     si - адрес первого числа
1   773					 ;     di - адрес второго числа
1   774					 ; результат в tmp_res
1   775
1   776					 ; сохраняем состояние стека
1   777	0281  50			 push ax
1   778	0282  53			 push bx
1   779	0283  51			 push cx
1   780	0284  52			 push dx
1   781	0285  56			 push si
1   782	0286  57			 push di
1   783
1   784					 ; очистка регистров
1   785	0287  33 C0			 xor ax, ax
1   786	0289  33 C9			 xor cx, cx
1   787
1   788	028B  B9 000A			 mov cx, 10 ; инициализируем счетчик - 10 байт	числа = 10	    +
    789				     итераций
1   790
1   791					 ; двигаем указатели на последние разряды (байты)    +
    792				     чисел
1   793	028E  83 C6 09			 add si, 9
1   794	0291  83 C7 09			 add di, 9
1   795
1   796	0294				 .sum_cycle:
1   797					     ; очистка регистров
1   798	0294  33 DB			     xor bx, bx
Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 15
main.asm



1   799	0296  33 D2			     xor dx, dx
1   800
1   801	0298  02 04			     add al, byte ptr [si] ; добавляем	очередной разряд		    +
    802				     первого числа в al, в ax очередной разряд +			    +
    803				     переполнение
1   804	029A  8A 1D			     mov bl, byte ptr [di] ; перемещаем очередной разряд	    +
    805				     второго числа в bl
1   806	029C  03 C3			     add ax, bx		   ; складываем, результат в ax
1   807	029E  BB 000A			     mov bx, 10		   ; в	bx делитель - 10
1   808	02A1  F7 F3			     div bx		   ; в	ax результат, в dx остаток от	    +
    809				     деления на 10 суммы разрядов	сложенной с			    +
    810				     переполнением
1   811
1   812					     ; инициализируем bx индексом	разряда в		    +
    813				     результирующем буфере (состояние декрементного	    +
    814				     счетчика -	1)
1   815	02A3  8B D9			     mov bx, cx
1   816	02A5  4B			     dec bx
1   817	02A6  88 97 011Ar		     mov tmp_res[bx], dl   ; записываем остаток в разряд	    +
    818				     результата
1   819
1   820					     ; двигаем указатели в слагаемых
1   821	02AA  4E			     dec si
1   822	02AB  4F			     dec di
1   823
1   824	02AC  E2 E6			     loop .sum_cycle	   ; уменьшаем	cx, переходим к следующей+
    825				     итерации
1   826
1   827					 ; восстанавливаем состояние стека
1   828	02AE  5F			 pop di
1   829	02AF  5E			 pop si
1   830	02B0  5A			 pop dx
1   831	02B1  59			 pop cx
1   832	02B2  5B			 pop bx
1   833	02B3  58			 pop ax
1   834
1   835	02B4  C3			 ret
1   836	02B5			     sum_values	endp
1   837
1   838	02B5			     mul_values	proc
1   839					 ; процедура для умножения	двух неотрицательных	    +
    840				     десяти разрядных двоично-десятичных чисел
1   841					 ; в si - адрес первого числа
1   842					 ; в di - адрес второго числа
1   843					 ; результат -	в tmp_res
1   844
1   845	02B5  50			 push ax
1   846	02B6  53			 push bx
1   847	02B7  51			 push cx
1   848	02B8  56			 push si
1   849	02B9  57			 push di
1   850
1   851	02BA  33 C0			 xor ax, ax
1   852	02BC  33 DB			 xor bx, bx
1   853	02BE  33 C9			 xor cx, cx
1   854
1   855					 ; проверка на ноль в первом числе
Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 16
main.asm



1   856	02C0  57			 push di
1   857	02C1  8B FE			 mov di, si
1   858	02C3  E8 0027			 call to_hex_decimal
1   859	02C6  5F			 pop di
1   860	02C7  83 F9 00			 cmp cx, 0
1   861	02CA  74 16			 je .no_mul
1   862
1   863					 ; проверка на 1 во	втором числе
1   864	02CC  E8 001E			 call to_hex_decimal   ; преобразование второго числа	к	    +
    865				     десятичному виду, результат в cx
1   866	02CF  83 F9 01			 cmp cx, 1
1   867	02D2  74 0E			 je .no_mul
1   868
1   869	02D4  49			 dec cx
1   870	02D5  8B FE			 mov di, si	       ; умножение реализуем как сложение num1 +
    871				     с	самим собой num2 - 1 раз
1   872	02D7				 .add_cycle:
1   873	02D7  E8 FFA7			     call sum_values   ; результат сложения				    +
    874				     двоично-десятичных чисел из si и di в tmp_res
1   875	02DA  BE 011Ar			     mov si, offset tmp_res
1   876	02DD  E2 F8			     loop .add_cycle
1   877	02DF  EB 06 90			 jmp .mul_exit
1   878
1   879	02E2				 .no_mul:
1   880	02E2  C6 06 01BFr 01		     mov err_flag, 1
1   881
1   882	02E7				 .mul_exit:
1   883	02E7  5F			     pop di
1   884	02E8  5E			     pop si
1   885	02E9  59			     pop cx
1   886	02EA  5B			     pop bx
1   887	02EB  58			     pop ax
1   888	02EC  C3			     ret
1   889	02ED			     mul_values	endp
1   890
1   891	02ED			     to_hex_decimal proc
1   892					 ; Процедура для перевода числа из				    +
    893				     двоично-десятичного в десятичное представление в    +
    894				     шестнадцатеричной	записи
1   895					 ; В регистре di ожидается адрес					    +
    896				     двоично-десятичного числа
1   897					 ; Результат:
1   898					 ; в cx записано шестнадцатеричное представление	    +
    899				     десятичного числа
1   900					 ; данная	процедура необходима	для инициализации   +
    901				     счетчика для процедуры	умножения чисел
1   902					 ; так как в данной программе задано ограничение	по+
    903				     модулю для вводимого числа равное 32768,
1   904					 ; то	переполнения регистра cx не случится в		    +
    905				     процессе перевода числа в нужный вид
1   906
1   907
1   908					 ; сохранение	состояния
1   909	02ED  50			 push ax ;
1   910	02EE  53			 push bx ; множитель 10
1   911	02EF  56			 push si ; для умножения на разряд
1   912	02F0  57			 push di ; адрес числа которое	нужно преобразовать
Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 17
main.asm



1   913
1   914					 ; предварительная очистка регистров
1   915	02F1  33 C0			 xor ax, ax
1   916	02F3  33 DB			 xor bx, bx
1   917	02F5  33 C9			 xor cx, cx
1   918	02F7  33 F6			 xor si, si
1   919
1   920					 ; Преобразование	в десятичное	число (в			    +
    921				     шестнадцатеричном	представлении)
1   922	02F9  B9 0000			 mov cx, 0	 ; счетчик для суммирования числа
1   923	02FC  BB 000A			 mov bx, 10	 ; множитель для умножения	предыдущей	    +
    924				     суммы	на 10
1   925	02FF  BE 000A			 mov si, 10	 ; в si количество разрядов числа (возможны +
    926				     незначащие нули слева)
1   927
1   928	0302			     .convert_loop:
1   929	0302  83 FE 00			 cmp si, 0
1   930	0305  74 1A			 je .conv_end
1   931	0307  33 C0			 xor ax, ax
1   932	0309  8A 05			 mov al, [di]	 ; загружаем символ из	строки
1   933	030B  3C 00			 cmp al, 0
1   934	030D  74 0E			 je .zero_rank
1   935	030F  56			 push si	 ; сохраняем текущее значение			    +
    936				     обрабатываемого разряда
1   937
1   938				     ; умножаем	очередной разряд	на 10	соответствующее	    +
    939				     количество раз
1   940	0310			     .rank_mul:
1   941	0310  4E			 dec si
1   942	0311  83 FE 00			 cmp si, 0
1   943	0314  74 04			 je .conv_cont
1   944	0316  F7 E3			 mul BX		 ; умножаем предыдущую сумму на 10
1   945	0318  EB F6			 jmp .rank_mul
1   946
1   947	031A			     .conv_cont:
1   948	031A  5E			 pop si
1   949	031B  03 C8			 add CX, AX	 ; добавляем текущее значение к сумме
1   950	031D			     .zero_rank:
1   951	031D  47			 inc di		 ; переходим к следующему символу
1   952	031E  4E			 dec si
1   953	031F  EB E1			 jmp .convert_loop
1   954
1   955
1   956	0321			     .conv_end:
1   957	0321  5F			 pop di
1   958	0322  5E			 pop si
1   959	0323  5B			 pop bx
1   960	0324  58			 pop ax
1   961
1   962	0325  C3			 ret
1   963	0326			     to_hex_decimal endp
1   964
1   965	0326			     sum_mul_array proc
1   966					 ; Процедура для получения	суммы элементов массива+
    967				     mul_array
1   968					 ; подразумевается что mul_array заполнен			    +
    969				     двоично-десятичными десяти-разрядными модулями	    +
Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 18
main.asm



    970				     попарных произведений
1   971					 ; результат в tmp_res
1   972
1   973	0326  57			 push di ; используется как указатель на адрес		    +
    974				     слагаемого (tmp_res)
1   975	0327  56			 push si ; используется как указатель на mul_array
1   976	0328  51			 push cx ; счетчик обработанных элементов
1   977
1   978	0329  33 F6			 xor si, si
1   979	032B  33 C9			 xor cx, cx
1   980
1   981	032D  E8 FE87			 call clear_tmp_res
1   982
1   983					 ; инициализация указателей
1   984	0330  BF 011Ar			 mov di, offset	tmp_res
1   985	0333  BE 0195r			 mov si, offset	mul_array
1   986
1   987	0336  8A 0C			 mov cl, [si]	      ;	инициализация счетчика элементов	    +
    988				     массива
1   989	0338  46			 inc si		      ;	двигаем указатель на первое		    +
    990				     произведение
1   991
1   992	0339				 .sum_mul_cycle:
1   993	0339  E8 FF45			     call sum_values  ;	результат сложения				    +
    994				     двоично-десятичных чисел из si и di в tmp_res
1   995	033C  83 C6 0A			     add si, 10
1   996	033F  E2 F8			     loop .sum_mul_cycle
1   997
1   998	0341  59			 pop cx
1   999	0342  5E			 pop si
1  1000	0343  5F			 pop di
1  1001	0344  C3			 ret
1  1002	0345			     sum_mul_array endp
1  1003
1  1004	0345			     result_to_string proc
1  1005					 ; Процедура для наполнения буфера res_str символами   +
   1006				     численного результата (модуля)
1  1007					 ; подразумевается что буфер tmp_res содержит		    +
   1008				     результат	вычисления суммы	попарных (разделенных    +
   1009				     по знаку)
1  1010					 ; произведений введенных чисел
1  1011	0345  56			 push si ; используется как указатель на tmp_res
1  1012	0346  57			 push di ; используется как указатель на res_str
1  1013	0347  50			 push ax ; используется как промежуточная переменная  +
   1014				     для обработки символа
1  1015	0348  51			 push cx ; счетчик обработанных символов (байт)
1  1016
1  1017					 ; очистка регистров
1  1018	0349  33 F6			 xor si, si
1  1019	034B  33 FF			 xor di, di
1  1020	034D  33 C0			 xor ax, ax
1  1021	034F  33 C9			 xor cx, cx
1  1022
1  1023	0351  BE 011Ar			 mov si, offset	tmp_res
1  1024	0354  BF 0138r			 mov di, offset	res_str	+ 1    ; пропускаем первый байт - символ  +
   1025				     '-'
1  1026	0357  B9 000A			 mov cx, 10
Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 19
main.asm



1  1027
1  1028	035A				 .del_zeros:
1  1029	035A  83 F9 01			     cmp cx, 1
1  1030	035D  74 0A			     je	.true_num_cycle
1  1031	035F  8A 04			     mov al, [si]
1  1032	0361  3C 00			     cmp al, 0
1  1033	0363  75 04			     jne .true_num_cycle
1  1034	0365  49			     dec cx
1  1035	0366  46			     inc si
1  1036	0367  EB F1			     jmp .del_zeros
1  1037	0369				 .true_num_cycle:
1  1038	0369  8A 04			     mov al, [si]
1  1039	036B  04 30			     add al, 30h
1  1040	036D  88 05			     mov [di], al
1  1041	036F  47			     inc di
1  1042	0370  46			     inc si
1  1043	0371  E2 F6			     loop .true_num_cycle
1  1044					 ; проверка на 0 (добавляем минус если результат не  +
   1045				     равен	нулю)
1  1046	0373  BF 0137r			 mov di, offset	res_str
1  1047	0376  8B 1D			 mov bx, [di]
1  1048	0378  80 FF 30			 cmp bh, 30h
1  1049	037B  75 0A			 jne .add_neg
1  1050					 ; если результат равен 0
1  1051	037D  C6 05 30			 mov [di], byte	ptr 30h	; первый байт	0
1  1052	0380  47			 inc di
1  1053	0381  C6 05 24			 mov [di], byte	ptr '$'	; второй байт	символ завершения	    +
   1054				     строки
1  1055	0384  EB 04 90			 jmp .end_res_to_str
1  1056	0387			     .add_neg:
1  1057	0387  C6 05 2D			 mov [di], byte	ptr '-'
1  1058	038A			     .end_res_to_str:
1  1059	038A  59			 pop cx
1  1060	038B  58			 pop ax
1  1061	038C  5F			 pop di
1  1062	038D  5E			 pop si
1  1063	038E  C3			 ret
1  1064
1  1065	038F			     result_to_string endp
1  1066
   1067
   1068	0000			     .stack
   1069	038F  0100*(??)			 db 100h dup(?)
   1070
   1071				     end start
Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 20
Symbol Table




Symbol Name			  Type	 Value

.ADD_CYCLE			  Near	 _TEXT:02D7
.ADD_NEG			  Near	 _TEXT:0387
.ADD_VALUE_EXIT			  Near	 _TEXT:01B3
.CLEAR_CYCLE			  Near	 _TEXT:01BF
.CONTINUE			  Near	 _TEXT:0167
.CONVERT_LOOP			  Near	 _TEXT:0302
.CONV_CONT			  Near	 _TEXT:031A
.CONV_END			  Near	 _TEXT:0321
.COPY_LOOP			  Near	 _TEXT:0214
.CORRECT_INPUT			  Near	 _TEXT:0089
.CORR_END			  Near	 _TEXT:0177
.COUNTER_INITIALIZED		  Near	 _TEXT:01F1
.CYCLE				  Near	 _TEXT:026E
.DEL_ZEROS			  Near	 _TEXT:035A
.END_PROGRAM			  Near	 _TEXT:00C6
.END_RANGE			  Near	 _TEXT:0159
.END_RES_TO_STR			  Near	 _TEXT:038A
.ERROR				  Near	 _TEXT:0172
.INPUT				  Near	 _TEXT:0020
.IS_NUM_CYCLE			  Near	 _TEXT:0108
.MAX_DIGITS_CHECK		  Near	 _TEXT:011C
.MUL_EXIT			  Near	 _TEXT:02E7
.NEGATIVE			  Near	 _TEXT:0165
.NEG_CYCLE			  Near	 _TEXT:0198
.NEG_START			  Near	 _TEXT:0127
.NOT_EMPTY			  Near	 _TEXT:0057
.NOT_EXIT			  Near	 _TEXT:006F
.NO_MUL				  Near	 _TEXT:02E2
.NO_MUL_FLAG			  Near	 _TEXT:0211
.NULL_FILLING			  Near	 _TEXT:0261
.POSITIVE			  Near	 _TEXT:025D
.POS_BIGGER			  Near	 _TEXT:01EF
.POS_CYCLE			  Near	 _TEXT:01AB
.POS_NUM			  Near	 _TEXT:01A3
.POS_START			  Near	 _TEXT:0137
.PROD_LOOP			  Near	 _TEXT:01FD
.RANGE_CYCLE			  Near	 _TEXT:0144
.RANK_MUL			  Near	 _TEXT:0310
.RETRY				  Near	 _TEXT:002E
.SUM_CYCLE			  Near	 _TEXT:0294
.SUM_MUL_CYCLE			  Near	 _TEXT:0339
.TRUE_NUM_CYCLE			  Near	 _TEXT:0369
.ZERO_RANK			  Near	 _TEXT:031D
??DATE				  Text	 "12/25/23"
??FILENAME			  Text	 "main	  "
??TIME				  Text	 "21:51:16"
??VERSION			  Number 0205
@CODE				  Text	 _TEXT
@CODESIZE			  Text	 0
@CPU				  Text	 0101H
@CURSEG				  Text	 _TEXT
@DATA				  Text	 DGROUP
@DATASIZE			  Text	 0
@FILENAME			  Text	 MAIN
Turbo Assembler	 Version 2.51	     12/25/23 21:51:16	    Page 21
Symbol Table



@MODEL				  Text	 2
@WORDSIZE			  Text	 2
ADD_VALUE			  Near	 _TEXT:017E
CARRET				  Byte	 DGROUP:0118
CLEAR_TMP_RES			  Near	 _TEXT:01B7
EMPTY_MESS			  Byte	 DGROUP:009C
ERR_FLAG			  Byte	 DGROUP:01BF
ERR_MESS			  Byte	 DGROUP:010A
EXIT_MESS			  Byte	 DGROUP:00EA
FILL_MUL_ARRAY			  Near	 _TEXT:01C8
INPUT_MESS			  Byte	 DGROUP:004A
IN_STR				  Byte	 DGROUP:012F
IS_CORRECT			  Near	 _TEXT:00CD
MAX_NEG_LEN			  Number 0006
MAX_NUM				  Byte	 DGROUP:0000
MAX_POS_LEN			  Number 0005
MUL_ARRAY			  Byte	 DGROUP:0195
MUL_VALUES			  Near	 _TEXT:02B5
NEGATIVE			  Number 002D
NEG_ARRAY			  Byte	 DGROUP:016C
NEG_FLAG			  Byte	 DGROUP:01BE
NEG_MAX_LAST			  Number 0038
NUMS_SIZE			  Number 0008
OUTPUT_MESS			  Byte	 DGROUP:0059
POS_ARRAY			  Byte	 DGROUP:0143
POS_MAX_LAST			  Number 0037
RESULT_TO_STRING		  Near	 _TEXT:0345
RES_STR				  Byte	 DGROUP:0137
START				  Near	 _TEXT:0000
START_MESS			  Byte	 DGROUP:0004
SUM_MUL_ARRAY			  Near	 _TEXT:0326
SUM_VALUES			  Near	 _TEXT:0281
TMP_NUM				  Byte	 DGROUP:0124
TMP_RES				  Byte	 DGROUP:011A
TO_BIN_DECIMAL			  Near	 _TEXT:022D
TO_HEX_DECIMAL			  Near	 _TEXT:02ED

Macro Name

EXIT
INPUT
PRINT

Groups & Segments		  Bit Size Align  Combine Class

DGROUP				  Group
  STACK				  16  0400 Para	  Stack	  STACK
  _DATA				  16  01C0 Word	  Public  DATA
_TEXT				  16  048F Word	  Public  CODE
