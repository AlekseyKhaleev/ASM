Turbo Assembler	 Version 2.51	     12/09/23 18:55:06	    Page 1
lab2_exe.ASM



      1				     ;пересылка слов(W) из in_str в out_str 21-ВМз-4	07/12/2023
      2				     ;слова, не равные '01' ~ 3031h, '23' ~ 3233h,	'45' ~ 3435h
      3
      4	0000			     d1	segment	para public 'data'
      5				     ; Объявляем строку mess1, которая содержит текст,	    +
      6				     символы перевода строки (10) и возврата каретки (13),
      7				     ;и заканчивается символом '$'
      8	0000  32 31 5F 76 6D 7A	5F+  mess1 db '21_vmz_4|A_Khaleev Input:',10,13,'$'
      9	      34 7C 41 5F 4B 68	61+
     10	      6C 65 65 76 20 49	6E+
     11	      70 75 74 3A 0A 0D	24
     12
     13				     ; Объявляем строку mess2, которая начинается с		    +
     14				     символов перевода строки (10) и возврата каретки (13),
     15				     ;содержит текст 'Output:', затем	еще символы перевода	    +
     16				     строки и возврата каретки, и заканчивается символом+
     17				     '$'
     18	001C  0A 0D 4F 75 74 70	75+  mess2 db 10,13,'Output:',10,13,'$'
     19	      74 3A 0A 0D 24
     20
     21				     ; Объявляем массив in_str, состоящий из 22 элементов,	    +
     22				     каждый из которых инициализируется вопросительным +
     23				     знаком (?),
     24				     ; что означает,	что начальные значения не	определены
     25	0028  16*(??)		     in_str db 22 dup (?)
     26
     27				     ; Объявляем массив out_str,	состоящий из	22 элементов,	    +
     28				     каждый из которых инициализируется символом	'$'
     29	003E  16*(24)		     out_str db	22 dup ('$')
     30
     31				     ; в ассемблере строка заканчивается символом	'$'. Это +
     32				     позволяет	функциям ввода/вывода DOS распознавать	    +
     33				     конец	строки
     34	0054			     d1	ends
     35
     36	0000			     c1	segment	para public 'code'
     37				     assume cs:c1,ds:d1,ss:st1
     38	0000			     start:
     39				     ;устанавливаем явно сегментный регистр данных:
     40	0000  B8 0000s			     mov ax,d1
     41	0003  8E D8				     mov ds,ax
     42
     43				     ; приглашение ввода:
     44	0005  BA 0000r			     mov dx,offset mess1  ; Загружаем смещение	строки mess1 в	    +
     45				     регистр DX
     46	0008  B4 09			     mov ah,9		  ; Устанавливаем 9 в регистр AH для	    +
     47				     функции "вывод	строки" в прерывании DOS 21h
     48	000A  CD 21			     int 21h		  ; Вызываем прерывание DOS 21h, выводя	    +
     49				     строку mess1	на экран
     50
     51				     ; ввод:
     52	000C  BA 0028r			     mov dx,offset in_str ; Загружаем смещение	строки in_str в	    +
     53				     регистр DX
     54	000F  C6 06 0028r 10		     mov in_str, 16	  ; Записываем 16 в первый байт in_str,	    +
     55				     ограничивая ввод 16	байтами
     56	0014  B4 0A			     mov ah,10		  ; Устанавливаем 10 в регистр AH для	    +
     57				     функции "buffered input" в	прерывании DOS 21h
Turbo Assembler	 Version 2.51	     12/09/23 18:55:06	    Page 2
lab2_exe.ASM



     58	0016  CD 21			     int 21h		  ; Вызываем прерывание DOS 21h, читая	    +
     59				     введенные	данные в	буфер in_str
     60
     61				     ;основная часть (модифицированный код из	ЛР1):
     62	0018  BE 002Ar				     mov si,offset in_str+2 ; первые 2 байта	служебные
     63	001B  BF 003Er				     mov di,offset out_str
     64	001E  32 E4				     xor ah, ah	 ; Очистка старшего байта ax
     65	0020  A0 0029r				     mov al,in_str+1 ; помещаем	в al количество		    +
     66				     введенных	байт символов
     67	0023  33 D2				     xor dx, dx	; Очистка dx перед div, так как div		    +
     68				     использует dx:ax
     69	0025  B3 02			     mov bl, 2	; Делитель
     70	0027  F6 F3			     div bl	; ax/bl	-> результат в al, остаток в ah
     71	0029  8A C8			     mov cl, al	; так как	оперируем словами данных в	    +
     72				     регистр счетчика записываем значение деленное на 2
     73	002B  84 E4			     test ah, ah ; Проверка, есть ли остаток
     74	002D  74 02			     jz	noRemainder ; Если остатка нет, переход к	метке	    +
     75				     noRemainder
     76	002F  FE C1			     inc cl	 ; Если был остаток, увеличиваем cl на 1
     77	0031			     noRemainder:
     78					     ; Здесь cl содержит количество слов, учитывая	    +
     79				     нечетное количество байт
     80	0031  32 ED				     xor ch,ch ; очистка	старшего байта счетчика
     81	0033			     cmp_cycle:
     82	0033  8B 04			     mov ax,[si]  ; помещаем первое считанное слово	в ax	    +
     83				     (байты переставлены)
     84	0035  86 E0			     xchg ah, al  ; обменять местами старший и младший	    +
     85				     байты
     86	0037  3D 3031				     cmp ax,3031h ; 3031h ~ '01'
     87	003A  74 11				     je	cmp_true  ; если равно	- пропуск
     88	003C  3D 3233				     cmp ax,3233h ; 3233h ~ '23'
     89	003F  74 0C				     je	cmp_true  ; если равно	- пропуск
     90	0041  3D 3435				     cmp ax,3435h ; 3435h ~ '45'
     91	0044  74 07				     je	cmp_true  ; если равно	- пропуск
     92	0046  86 E0			     xchg ah, al  ; обменять местами старший и младший	    +
     93				     байты
     94	0048  89 05				     mov [di], ax ; запись в выходной массив
     95	004A  83 C7 02				     add di, 2	  ; увеличиваем выходной указатель на +
     96				     2 (работаем со словами)
     97	004D			     cmp_true:
     98	004D  83 C6 02			     add si, 2	  ; увеличиваем входной указатель на 2	    +
     99				     (работаем со словами)
    100	0050  E2 E1				     loop cmp_cycle ; пока регистр счетчика не равен 0    +
    101				     выполняем	цикл cmp_cycle
    102
    103				     ; вывод результата:
    104	0052  BA 001Cr			     mov dx,offset mess2  ; Загружаем смещение	строки mess2 в	    +
    105				     регистр DX
    106	0055  B4 09			     mov ah,9  ; Загружаем 9 в регистр	AH, что			    +
    107				     соответствует	функции "вывод строки" в прерывании DOS+
    108				     21h
    109	0057  CD 21			     int 21h   ; Вызываем DOS interrupt	21h, что выводит строку	    +
    110				     mess2 на	экран
    111
    112	0059  BA 003Er			     mov dx,offset out_str  ; Загружаем смещение строки out_str в   +
    113				     регистр DX
    114	005C  B4 09			     mov ah,9  ; Загружаем 9 в регистр	AH, что			    +
Turbo Assembler	 Version 2.51	     12/09/23 18:55:06	    Page 3
lab2_exe.ASM



    115				     соответствует	функции "вывод строки" в прерывании DOS+
    116				     21h
    117	005E  CD 21			     int 21h   ; Вызываем DOS interrupt	21h, что выводит строку	    +
    118				     out_str на экран
    119
    120				     ; задержка	(ожидание нажатия клавиши):
    121	0060  B4 07			     mov ah,7  ; Устанавливаем 7 в AH, что соответствует	    +
    122				     функции "ввод без эха" в	прерывании DOS 21h
    123	0062  CD 21			     int 21h   ; Вызываем DOS interrupt	21h, что позволяет		    +
    124				     программе	ожидать нажатия клавиши пользователем
    125
    126				     ; завершение:
    127	0064  B8 4C00			     mov ax,4c00h  ; Загружаем	4C00h в AX, что соответствует	    +
    128				     функции "завершение программы" в прерывании DOS 21h
    129	0067  CD 21			     int 21h   ; Вызываем прерывание DOS 21h,	что приводит	к  +
    130				     завершению программы
    131	0069			     c1	ends
    132
    133	0000			     st1 segment para stack 'stack'
    134	0000  64*(????)				 dw 100	dup (?)	; Резервирование памяти под 100 слов	(200+
    135				     байт) для стека. Инициализируются неопределенными   +
    136				     значениями
    137	00C8			     st1 ends
    138
    139				     end start
Turbo Assembler	 Version 2.51	     12/09/23 18:55:06	    Page 4
Symbol Table




Symbol Name			  Type	 Value

??DATE				  Text	 "12/09/23"
??FILENAME			  Text	 "lab2_exe"
??TIME				  Text	 "18:55:06"
??VERSION			  Number 0205
@CPU				  Text	 0101H
@CURSEG				  Text	 ST1
@FILENAME			  Text	 LAB2_EXE
@WORDSIZE			  Text	 2
CMP_CYCLE			  Near	 C1:0033
CMP_TRUE			  Near	 C1:004D
IN_STR				  Byte	 D1:0028
MESS1				  Byte	 D1:0000
MESS2				  Byte	 D1:001C
NOREMAINDER			  Near	 C1:0031
OUT_STR				  Byte	 D1:003E
START				  Near	 C1:0000

Groups & Segments		  Bit Size Align  Combine Class

C1				  16  0069 Para	  Public  CODE
D1				  16  0054 Para	  Public  DATA
ST1				  16  00C8 Para	  Stack	  STACK
