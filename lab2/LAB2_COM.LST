Turbo Assembler	 Version 2.51	     12/09/23 21:44:02	    Page 1
lab2_com.asm



      1				     ;пересылка слов(W) из in_str в out_str 21-ВМз-4	07/12/2023
      2				     ;слова, не равные '01' ~ 3031h, '23' ~ 3233h,	'45' ~ 3435h
      3
      4	0000			     .model tiny  ; Устанавливает модель памяти, где весь код и +
      5				     данные помещаются в одном 64KB сегменте.
      6
      7	0000			     .data
      8				     ; Объявляем строку mess1, которая содержит текст,	    +
      9				     символы перевода строки (10) и возврата каретки (13),
     10				     ;и заканчивается символом '$'
     11	0000  32 31 5F 76 6D 7A	5F+  mess1 db '21_vmz_4|A_Khaleev Input:',10,13,'$'
     12	      34 7C 41 5F 4B 68	61+
     13	      6C 65 65 76 20 49	6E+
     14	      70 75 74 3A 0A 0D	24
     15
     16				     ; Объявляем строку mess2, которая начинается с		    +
     17				     символов перевода строки (10) и возврата каретки (13),
     18				     ;содержит текст 'Output:', затем	еще символы перевода	    +
     19				     строки и возврата каретки, и заканчивается символом+
     20				     '$'
     21	001C  0A 0D 4F 75 74 70	75+  mess2 db 10,13,'Output:',10,13,'$'
     22	      74 3A 0A 0D 24
     23
     24				     ; Объявляем массив in_str, состоящий из 22 элементов,	    +
     25				     каждый из которых инициализируется вопросительным +
     26				     знаком (?),
     27				     ; что означает,	что начальные значения не	определены
     28	0028  16*(??)		     in_str db 22 dup (?)
     29
     30				     ; Объявляем массив out_str,	состоящий из	22 элементов,	    +
     31				     каждый из которых инициализируется символом	'$'
     32	003E  16*(24)		     out_str db	22 dup ('$')
     33
     34				     ; в ассемблере строка заканчивается символом	'$'. Это +
     35				     позволяет	функциям ввода/вывода DOS распознавать	    +
     36				     конец	строки
     37
     38	0054			     .code
     39				     ORG 100h ;	COM-программы начинаются с этой	точки
     40	0100			     start:
     41
     42
     43				     ; приглашение ввода:
     44	0100  BA 0000r			     mov dx,offset mess1  ; Загружаем смещение	строки mess1 в	    +
     45				     регистр DX
     46	0103  B4 09			     mov ah,9		  ; Устанавливаем 9 в регистр AH для	    +
     47				     функции "вывод	строки" в прерывании DOS 21h
     48	0105  CD 21			     int 21h		  ; Вызываем прерывание DOS 21h, выводя	    +
     49				     строку mess1	на экран
     50
     51				     ; ввод:
     52	0107  BA 0028r			     mov dx,offset in_str ; Загружаем смещение	строки in_str в	    +
     53				     регистр DX
     54	010A  C6 06 0028r 10		     mov in_str, 16	  ; Записываем 16 в первый байт in_str,	    +
     55				     ограничивая ввод 16	байтами
     56	010F  B4 0A			     mov ah,10		  ; Устанавливаем 10 в регистр AH для	    +
     57				     функции "buffered input" в	прерывании DOS 21h
Turbo Assembler	 Version 2.51	     12/09/23 21:44:02	    Page 2
lab2_com.asm



     58	0111  CD 21			     int 21h		  ; Вызываем прерывание DOS 21h, читая	    +
     59				     введенные	данные в	буфер in_str
     60
     61				     ;основная часть (модифицированный код из	ЛР1):
     62	0113  BE 002Ar				     mov si,offset in_str+2 ; первые 2 байта	служебные
     63	0116  BF 003Er				     mov di,offset out_str
     64	0119  32 E4				     xor ah, ah	 ; Очистка старшего байта ax
     65	011B  A0 0029r				     mov al,in_str+1 ; помещаем	в al количество		    +
     66				     введенных	байт символов
     67	011E  33 D2				     xor dx, dx	 ; Очистка dx перед	div, так как div		    +
     68				     использует dx:ax
     69	0120  B3 02			     mov bl, 2	 ; Делитель
     70	0122  F6 F3			     div bl	 ; ax/bl -> результат в al, остаток в	ah
     71	0124  8A C8			     mov cl, al	 ; так как оперируем словами данных	в	    +
     72				     регистр счетчика записываем значение деленное на 2
     73	0126  84 E4			     test ah, ah ; Проверка, есть ли остаток
     74	0128  74 02			     jz	noRemainder ; Если остатка нет, переход к	метке	    +
     75				     noRemainder
     76	012A  FE C1			     inc cl	 ; Если был остаток, увеличиваем cl на 1
     77	012C			     noRemainder:
     78					     ; Здесь cl содержит количество слов, учитывая	    +
     79				     нечетное количество байт
     80	012C  32 ED				     xor ch,ch	  ; очистка старшего байта счетчика
     81	012E			     cmp_cycle:
     82	012E  8B 04			     mov ax,[si]  ; помещаем первое считанное слово	в ax	    +
     83				     (байты переставлены)
     84	0130  86 E0			     xchg ah, al  ; обменять местами старший и младший	    +
     85				     байты
     86	0132  3D 3031				     cmp ax,3031h ; 3031h ~ '01'
     87	0135  74 11				     je	cmp_true  ; если равно	- пропуск
     88	0137  3D 3233				     cmp ax,3233h ; 3233h ~ '23'
     89	013A  74 0C				     je	cmp_true  ; если равно	- пропуск
     90	013C  3D 3435				     cmp ax,3435h ; 3435h ~ '45'
     91	013F  74 07				     je	cmp_true  ; если равно	- пропуск
     92	0141  86 E0			     xchg ah, al  ; обменять местами старший и младший	    +
     93				     байты
     94	0143  89 05				     mov [di], ax ; запись в выходной массив
     95	0145  83 C7 02				     add di, 2	  ; увеличиваем выходной указатель на +
     96				     2 (работаем со словами)
     97	0148			     cmp_true:
     98	0148  83 C6 02			     add si, 2	  ; увеличиваем входной указатель на 2	    +
     99				     (работаем со словами)
    100	014B  E2 E1				     loop cmp_cycle ; пока регистр счетчика не равен 0    +
    101				     выполняем	цикл cmp_cycle
    102
    103				     ; вывод результата:
    104	014D  BA 001Cr			 mov dx,offset mess2  ;	Загружаем смещение строки mess2 в	    +
    105				     регистр DX
    106	0150  B4 09			 mov ah,9  ; Загружаем	9 в регистр AH,	что соответствует   +
    107				     функции "вывод	строки" в прерывании DOS 21h
    108	0152  CD 21			 int 21h   ; Вызываем DOS interrupt 21h, что	выводит строку mess2   +
    109				     на экран
    110
    111	0154  BA 003Er			 mov dx,offset out_str	; Загружаем смещение строки out_str в	    +
    112				     регистр DX
    113	0157  B4 09			 mov ah,9  ; Загружаем	9 в регистр AH,	что соответствует   +
    114				     функции "вывод	строки" в прерывании DOS 21h
Turbo Assembler	 Version 2.51	     12/09/23 21:44:02	    Page 3
lab2_com.asm



    115	0159  CD 21			 int 21h   ; Вызываем DOS interrupt 21h, что	выводит строку out_str +
    116				     на экран
    117
    118				     ; задержка	(ожидание нажатия клавиши):
    119	015B  B4 07			 mov ah,7  ; Устанавливаем	7 в AH, что	соответствует	    +
    120				     функции "ввод без эха" в	прерывании DOS 21h
    121	015D  CD 21			 int 21h   ; Вызываем DOS interrupt 21h, что	позволяет		    +
    122				     программе	ожидать нажатия клавиши пользователем
    123
    124				     ; завершение:
    125	015F  B8 4C00			 mov ax,4c00h  ; Загружаем 4C00h в AX, что	соответствует	    +
    126				     функции "завершение программы" в прерывании DOS 21h
    127	0162  CD 21			 int 21h   ; Вызываем прерывание DOS 21h, что приводит к	    +
    128				     завершению программы
    129
    130				     end start
Turbo Assembler	 Version 2.51	     12/09/23 21:44:02	    Page 4
Symbol Table




Symbol Name			  Type	 Value

??DATE				  Text	 "12/09/23"
??FILENAME			  Text	 "lab2_com"
??TIME				  Text	 "21:44:02"
??VERSION			  Number 0205
@CODE				  Text	 DGROUP
@CODESIZE			  Text	 0
@CPU				  Text	 0101H
@CURSEG				  Text	 _TEXT
@DATA				  Text	 DGROUP
@DATASIZE			  Text	 0
@FILENAME			  Text	 LAB2_COM
@MODEL				  Text	 1
@WORDSIZE			  Text	 2
CMP_CYCLE			  Near	 DGROUP:012E
CMP_TRUE			  Near	 DGROUP:0148
IN_STR				  Byte	 DGROUP:0028
MESS1				  Byte	 DGROUP:0000
MESS2				  Byte	 DGROUP:001C
NOREMAINDER			  Near	 DGROUP:012C
OUT_STR				  Byte	 DGROUP:003E
START				  Near	 DGROUP:0100

Groups & Segments		  Bit Size Align  Combine Class

DGROUP				  Group
  _DATA				  16  0054 Word	  Public  DATA
  _TEXT				  16  0164 Word	  Public  CODE
